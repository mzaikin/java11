<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;3.&nbsp;Java Interfaces</title><link rel="stylesheet" type="text/css" href="ocpjd11-upgrade-guide.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Exam 1Z0-817: Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Study Guide"><link rel="up" href="pt01.html" title="Part&nbsp;I.&nbsp;Exam Objectives"><link rel="prev" href="ch02s02.html" title="2.2.&nbsp; Design a service type, load the services using ServiceLoader, check for dependencies of the services including consumer module and provider module"><link rel="next" href="ch03s02.html" title="3.2.&nbsp; Define and write functional interfaces"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;3.&nbsp;Java Interfaces</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s02.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;I.&nbsp;Exam Objectives</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch03s02.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap3"></a>Chapter&nbsp;3.&nbsp;Java Interfaces</h2></div></div></div>
			
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c3s1"></a>3.1.&nbsp;
					 Create and use methods in interfaces
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="bi01.html#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 3.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					Java 9 introduced <code class="code">private</code> methods and <code class="code">private static</code> method in interfaces. In Java 9 (and hence Java 11 too) an interface can have seven 
					different things:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							<p>
								constant variables (since Java 1.0)
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">abstract</code> methods (since Java 1.0)
							</p>
						</li><li class="listitem">
							<p>
								nested types (since Java 2.0)
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">default</code> methods (since Java 8.0)
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">static</code> methods (since Java 8.0)
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">private</code> methods (since Java 9.0)
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">private static</code> methods (since Java 9.0)
							</p>
						</li></ol></div><p>
					The <code class="code">private</code> methods added in Java 9.0 will improve code re-usability inside interfaces and will provide choice to expose only  
					intended method implementations to users. The <code class="code">private</code> methods are only accessible within an interface only and cannot be accessed 
					or inherited from the interface to another interface or class.
				</p>
				<p>
					<span class="bold"><strong>Constant variables</strong></span>
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    String GREETING = "Greeting from Interface";
}
					</pre><p>					
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
        System.out.print(GreeterIntf.GREETING);
    }
}
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Every field declaration in the body of an interface is implicitly <code class="code">public</code>, <code class="code">static</code>, and <code class="code">final</code>. It is permitted 
						to redundantly specify any or all of these modifiers for such fields.
					</p>
				</td></tr></table></div>
				<p>
					Interface variables are <code class="code">static</code> because Java interfaces cannot be instantiated in their own right; the value of the variable must be 
					assigned in a static context in which no instance exists. The <code class="code">final</code> modifier ensures the value assigned to the interface variable is a 
					true constant that cannot be re-assigned by program code.
				</p>
				<p>
					<span class="bold"><strong><code class="code">abstract</code> methods</strong></span>
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    void greet();
}

					</pre><p>
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
        GreeterIntf g = () -&gt; {
            System.out.print("Greeting from Interface");
        };
        g.greet();
    }
}					
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Every method declaration in an interface with body represented by a semicolon is implicitly <code class="code">public</code> and <code class="code">abstract</code>.
					</p>					
				</td></tr></table></div>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						It is a compile-time error if a method declaration that contains the keyword <code class="code">abstract</code> also contains any one of the keywords: 
						<code class="code">private</code>, <code class="code">static</code>, <code class="code">final</code>, <code class="code">native</code>, <code class="code">strictfp</code>, or <code class="code">synchronized</code>.
					</p>
					<p>
						It would be impossible for a class to implement a <code class="code">private abstract</code> method, because <code class="code">private</code> methods are not 
						inherited by subclasses; therefore such a method could never be used.
					</p>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>nested types</strong></span>
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    class GreeterException extends RuntimeException {
        public GreeterException() { super(); };
    }    
    interface Helper {
        String GREETING = "Greeting from Interface";
    }
}
					</pre><p>
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
        try {
            System.out.print(GreeterIntf.Helper.GREETING);
        } catch (GreeterIntf.GreeterException e) {
            // never ignore exception handling !
        }
    }
}
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Interfaces may contain member type declarations. A member type declaration in an interface is implicitly 
						<code class="code">static</code> and <code class="code">public</code>. It is permitted to redundantly specify either or both of 
						these modifiers.
					</p>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong><code class="code">default</code> methods</strong></span>
				</p>
				<p>
					Before Java 8.0, interfaces could have only <code class="code">abstract</code> methods. The implementation of these methods 
					has to be provided in a separate class. So, if a new method is to be added in an interface, then its implementation code 
					has to be provided in all classes implementing this interface. To overcome this issue, Java 8.0 has introduced the concept 
					of <code class="code">default</code> methods which allow the interfaces to have methods with implementation without affecting the 
					classes that implement the interface.
				</p>
				<p>
					Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary backward compatibility with 
					code written for older versions of those interfaces.
				</p>
				<p>
					Unlike <code class="code">abstract</code> interface methods, they are declared with the <code class="code">default</code> keyword at the beginning 
					of the method signature, and they provide an implementation.
				</p>
				<p>
					 An implementing class can override the default implementation provided by the interface.
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    default void greet() {
        System.out.print("Greeting from Interface");    
    }
}
					</pre><p>
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
      GreeterIntf g = new GreeterIntf() { // we do not override default method
      };
      g.greet();
    }
}
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						The <code class="code">default</code> methods are implicitly <code class="code">public</code> &#8212; there's no need to specify the <code class="code">public</code> modifier.
					</p>					
				</td></tr></table></div>
				<p>
					If a class implements two interfaces, both of which have a <code class="code">default</code> method with the same name and parameter types, then you must resolve the conflict.
					</p><pre class="programlisting">
public interface GreeterIntfA {
    default void greet() {
        System.out.println("Greeting from GreeterIntfA");
    }
}
					</pre><p>
					</p><pre class="programlisting">
public interface GreeterIntfB {
    default void greet() {
        System.out.println("Greeting from GreeterIntfB");
    }
}
					</pre><p>
					</p><pre class="programlisting">
public class MyGreeter implements GreeterIntfA, GreeterIntfB {
	// WILL NOT COMPILE !!!    
}

					</pre><p>
					The <code class="code">MyGreeter</code> class inherits two <code class="code">greet()</code> methods provided by the <code class="code">GreeterIntfA</code> and 
					<code class="code">GreeterIntfB</code> interfaces. There is no way for the Java compiler to choose one over the other. The compiler 
					reports an error. You should provide a <code class="code">greet()</code> method in the <code class="code">MyGreeter</code> class and either implement your own 
					greeting, or delegate to one of the conflicting methods, like this:
					</p><pre class="programlisting">
public class MyGreeter implements GreeterIntfA, GreeterIntfB {
    @Override
    public void greet() {
        GreeterIntfA.super.greet();
    }
}
					</pre><p>
					The <code class="code">super</code> keyword lets you call a supertype method. In this case, we need to specify which supertype we want.
				</p>
				<p>
					If a class extends a superclass and implements an interface with <code class="code">default</code> method, inheriting the same method from both,  then 
					only the superclass method matters, and <code class="code">default</code> method from the interface is ignored.  
				</p>
				<p>
					<span class="bold"><strong><code class="code">static</code> methods</strong></span>
				</p>
				<p>
					In Java 8.0 and later you can define <code class="code">static</code> methods in interfaces. Like <code class="code">static</code> methods in classes, you 
					specify that a method definition in an interface is a <code class="code">static</code> method with the <code class="code">static</code> keyword at the 
					beginning of the method signature.
				</p>
				<p>
					A <code class="code">static</code> method can be invoked from other <code class="code">static</code> or from <code class="code">default</code> method.
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    static void greet() {
        System.out.print("Greeting from Interface");    
    }
}
					</pre><p>				
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
      GreeterIntf.greet();
    }
}
					</pre><p>				
				</p>				
				<p>
					A <code class="code">static</code> method cannot be overridden or changed in the implementation class. 
				</p>
				<p>
					A <code class="code">static</code> method cannot be shadowed too, as it part of the interface, not part of implementing the class.
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						The <code class="code">static</code> methods are implicitly <code class="code">public</code> &#8212; there's no need to specify the <code class="code">public</code> modifier.
					</p>					
				</td></tr></table></div>
				<p>
					<span class="bold"><strong><code class="code">private</code> methods</strong></span>
				</p>
				<p>
					As of Java 9.0, methods in an interface can be <code class="code">private</code>. 
				</p>
				<p>
					These <code class="code">private</code> methods will improve code reusability inside interfaces and encapsulation. For example, if two <code class="code">default</code> methods 
					needed to share code, a <code class="code">private</code> method in the interface would allow them to do so, but without exposing that <code class="code">private</code> method 
					to interface implementing class.
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    default void greet() {
        System.out.print(getGreeting());    
    }
    
    private String getGreeting() {
        return "Greeting from Interface";
    }
}
					</pre><p>
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
      GreeterIntf g = new GreeterIntf() {        
      };
      g.greet();
    }
}
					</pre><p>
				</p>
				<p>
					Rules for <code class="code">private</code> methods in interfaces:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							<p>
								We must use <code class="code">private</code> modifier to define them.
							</p>
						</li><li class="listitem">
							<p>
								No <code class="code">private</code> and <code class="code">abstract</code> modifiers together, it will give compiler error.
								The <code class="code">private</code> method means fully implemented method because subclasses cannot inherit and override this method.
								The <code class="code">abstract</code> method means no-implementation method -- subclass must inherit and override this method.
							</p>
						</li><li class="listitem">
							<p>
								No <code class="code">private</code> and <code class="code">default</code> modifiers together, it will give compiler error. The <code class="code">default</code> methods in 
								an interface are always <code class="code">public</code>.
							</p>
						</li><li class="listitem">
							<p>
								The <code class="code">private</code> methods must contain body.
							</p>
						</li></ol></div><p> 
				</p>
				<p>
					 As <code class="code">private</code> methods can only be used in the methods of the interface itself, their use is limited to being helper methods for the other methods 
					 of the interface.
				</p>
				<p>
					<span class="bold"><strong><code class="code">private static</code> methods</strong></span>
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    static void greet() {
        System.out.print(GreeterIntf.getGreeting());    
    }
    
    private static String getGreeting() {
        return "Greeting from Interface";
    }
}					</pre><p>
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
      GreeterIntf.greet();
    }
}					</pre><p>
				</p>
				<p>
					 The <code class="code">private static</code> methods are useful when you have multiple <code class="code">public static</code> methods that share some 
					 common code. So, you can only extract that shared code into a <code class="code">private static</code> method, but not into an instance method 
					 (because <code class="code">static</code> method cannot access instance method without creating an instance of type).
				</p>
				<p>
					A <code class="code">private static</code> methods can be called from instance (i.e. <code class="code">default</code> or <code class="code">private</code> non-static) 
					method or <code class="code">static</code> method inside the interface.
				</p>
				<p>
					A <code class="code">private</code> non-static method is not allowed to be called from <code class="code">static</code> or <code class="code">private static</code> method within the 
					interface (unless an instance of the interface is passed in). 
				</p>
			</div>
			
		</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s02.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="pt01.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch03s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2.2.&nbsp;
					Design a service type, load the services using <code class="code">ServiceLoader</code>, check for dependencies 
					of the services including consumer module and provider module
				&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;3.2.&nbsp;
					Define and write functional interfaces
				</td></tr></table></div></body></html>
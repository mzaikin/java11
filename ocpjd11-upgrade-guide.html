<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Exam 1Z0-817: Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Study Guide</title><link rel="stylesheet" type="text/css" href="ocpjd11-upgrade-guide.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="description" content="The purpose of this document is to help in preparation for Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Test (Exam 1Z0-817). This document should not be used as the only study material for Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Test (Exam 1Z0-817). It might cover not all objective topics, and it might be not enough. I tried to make this document as much accurate as possible, but if you find any error, please let me know."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book"><div class="titlepage"><div><div><h1 class="title"><a name="ocpjd11-upgrade-guide"></a>Exam 1Z0-817: Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Study Guide</h1></div><div><div class="authorgroup">
			<div class="author"><h3 class="author"><span class="firstname">Mikalai</span> <span class="surname">Zaikin</span></h3><div class="affiliation">
					<div class="address"><p><br>
<span class="country">Lithuania</span><br>
<span class="city">Vilnius</span><br>
<code class="email">&lt;<a class="email" href="mailto:mzaikin[at]gmail.com">mzaikin[at]gmail.com</a>&gt;</code><br>
					</p></div>
				</div></div>
		</div></div><div><p class="copyright">Copyright &copy; 2020-2025 Mikalai Zaikin</p></div><div><div class="legalnotice"><a name="d5e14"></a>
			<p>Redistribution of this document is permitted as long as it is not used for profits.</p>
		</div></div><div><p class="pubdate">August 2025</p></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr>
			<tr><td align="left">Revision a188eec75b9b09436656d60791b7f30273e2f581</td><td align="left">Fri Aug 22 16:35:38 2025 +0300</td><td align="left">Mikalai Zaikin</td></tr><tr><td align="left" colspan="3"><p>Minor updates</p></td></tr>
			<tr><td align="left">Revision 5c2adf3a8592b86b5f5ada9f2bebaed78bb41851</td><td align="left">Fri Aug 22 16:19:54 2025 +0300</td><td align="left">Mikalai Zaikin</td></tr><tr><td align="left" colspan="3"><p>Added libs</p></td></tr>
			<tr><td align="left">Revision 74a6ab4434e317e67d130d559cc177fd552571ab</td><td align="left">Fri Aug 22 16:13:04 2025 +0300</td><td align="left">Mikalai Zaikin</td></tr><tr><td align="left" colspan="3"><p>Initial commit</p></td></tr>
		</table></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p>
			<p>
				The purpose of this document is to help in preparation for Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Test (Exam 1Z0-817).
			</p>
			<p>
				This document should not be used as the only study material for Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Test
				(Exam 1Z0-817). It might cover not all objective topics, and it might be not
				enough. I tried to make this document as much accurate as  possible, but if you find any error, please let
				<a class="ulink" href="mailto:mzaikin@gmail.com?subject=Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Guide Comment" target="_top">me</a> know.
			</p>
		</div></div></div><hr></div><div class="toc"><dl class="toc"><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="part"><a href="#partI">I. Exam Objectives</a></span></dt><dd><dl><dt><span class="chapter"><a href="#chap1">1. Understanding Modules</a></span></dt><dd><dl><dt><span class="sect1"><a href="#c1s1">1.1. 
					 Describe the Modular JDK
				</a></span></dt><dt><span class="sect1"><a href="#c1s2">1.2. 
					 Declare modules and enable access between modules
				</a></span></dt><dt><span class="sect1"><a href="#c1s3">1.3. 
					   Describe how a modular project is compiled and run
				</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap2">2. Services in a Modular Application</a></span></dt><dd><dl><dt><span class="sect1"><a href="#c2s1">2.1. 
					  Describe the components of Services including directives
				</a></span></dt><dt><span class="sect1"><a href="#c2s2">2.2. 
					Design a service type, load the services using <code class="code">ServiceLoader</code>, check for dependencies 
					of the services including consumer module and provider module
				</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap3">3. Java Interfaces</a></span></dt><dd><dl><dt><span class="sect1"><a href="#c3s1">3.1. 
					 Create and use methods in interfaces
				</a></span></dt><dt><span class="sect1"><a href="#c3s2">3.2. 
					Define and write functional interfaces
				</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap4">4. Lambda Operations on Streams</a></span></dt><dd><dl><dt><span class="sect1"><a href="#c4s1">4.1. 
					 Extract stream data using <code class="code">map</code>, <code class="code">peek</code>, and <code class="code">flatMap</code> methods
				</a></span></dt><dt><span class="sect1"><a href="#c4s2">4.2. 
					Search stream data using search <code class="code">findFirst</code>, <code class="code">findAny</code>, <code class="code">anyMatch</code>, <code class="code">allMatch</code> and 
					<code class="code">noneMatch</code> methods
				</a></span></dt><dt><span class="sect1"><a href="#c4s3">4.3. 
					 Use the <code class="code">Optional</code> class
				</a></span></dt><dt><span class="sect1"><a href="#c4s4">4.4. 
					 Perform calculations using <code class="code">count</code>, <code class="code">max</code>, <code class="code">min</code>, <code class="code">average</code> and <code class="code">sum</code> stream operations
				</a></span></dt><dt><span class="sect1"><a href="#c4s5">4.5. 
					Sort a collection using lambda expressions
				</a></span></dt><dt><span class="sect1"><a href="#c4s6">4.6. 
					Use <code class="code">Collectors</code> with streams, including the <code class="code">groupingBy</code> and <code class="code">partitioningBy</code> operation
				</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap5">5. Java File I/O (NIO.2)</a></span></dt><dd><dl><dt><span class="sect1"><a href="#c5s1">5.1. 
					Use <code class="code">Path</code> interface to operate on file and directory paths
				</a></span></dt><dt><span class="sect1"><a href="#c5s2">5.2. 
					 Use <code class="code">Files</code> class to check, delete, copy or move a file or directory
				</a></span></dt><dt><span class="sect1"><a href="#c5s3">5.3. 
					 Use Stream API with <code class="code">Files</code>
				</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap6">6. Migration to a Modular Application</a></span></dt><dd><dl><dt><span class="sect1"><a href="#c6s1">6.1. 
					 Migrate the application developed using a Java version prior to SE 9 to SE 11 including top-down and bottom-up migration, splitting a Java SE 8 application into modules for migration
				</a></span></dt><dt><span class="sect1"><a href="#c6s2">6.2. 
					Use <code class="code">jdeps</code> to determine dependencies and identify way to address the cyclic dependencies
				</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap7">7. Local-Variable Type Inference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#c7s1">7.1. 
					  Use local-variable type inference
				</a></span></dt><dt><span class="sect1"><a href="#c7s2">7.2. 
					Create and use lambda expressions with local-variable type inferred parameters
				</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap8">8. Lambda Expressions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#c8s1">8.1. 
					 Create and use lambda expressions
				</a></span></dt><dt><span class="sect1"><a href="#c8s2">8.2. 
					Use lambda expressions and method references
				</a></span></dt><dt><span class="sect1"><a href="#c8s3">8.3. 
					Use built-in functional interfaces including <code class="code">Predicate</code>, <code class="code">Consumer</code>, <code class="code">Function</code>, and <code class="code">Supplier</code>
				</a></span></dt><dt><span class="sect1"><a href="#c8s4">8.4. 
					Use primitive and binary variations of base interfaces of <code class="code">java.util.function</code> package
				</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap9">9. Parallel Streams</a></span></dt><dd><dl><dt><span class="sect1"><a href="#c9s1">9.1. 
					 Develop the code that use parallel streams
				</a></span></dt><dt><span class="sect1"><a href="#c9s2">9.2. 
					Implement decomposition and reduction with streams
				</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap10">10. Language Enhancements</a></span></dt><dd><dl><dt><span class="sect1"><a href="#c10s1">10.1. 
					 Use try-with-resources construct
				</a></span></dt><dt><span class="sect1"><a href="#c10s2">10.2. 
					Develop code that handles multiple Exception types in a single catch block
				</a></span></dt></dl></dd><dt><span class="bibliography"><a href="#d5e3849">Bibliography</a></span></dt></dl></dd><dt><span class="part"><a href="#partII">II. Appendixes</a></span></dt><dd><dl><dt><span class="appendix"><a href="#app1">1. Additional materials</a></span></dt><dd><dl><dt><span class="section"><a href="#a1s1">1.1. How to build JDK module graph</a></span></dt></dl></dd></dl></dd></dl></div>	
	
	<div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="preface"></a>Preface</h1></div></div></div>
		
		<p>
			If you believe you have found an error in the "Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Guide"
			or have a suggestion to improve it, please send an e-mail to
			<a class="ulink" href="mailto:mzaikin@gmail.com?subject=Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Guide Comment" target="_top">me</a>.
			Please, indicate the topic and page URL.
		</p>
	</div>
	<div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="partI"></a>Part&nbsp;I.&nbsp;Exam Objectives</h1></div></div></div>
		
		<div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap1"></a>Chapter&nbsp;1.&nbsp;Understanding Modules</h2></div></div></div>
			
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c1s1"></a>1.1.&nbsp;
					 Describe the Modular JDK
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#JEP_200" title="JEP 200: The Modular JDK">[JEP_200]</a> JEP 200: Modular SDK 
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					JDK was divided into a set of modules that can be combined at compile time, build time, and run time into a variety of configurations including, but not limited to:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Configurations corresponding to the full Java SE Platform, the full JRE, and the full JDK;
							</p>
						</li><li class="listitem">
							<p>
								Configurations roughly equivalent in content to each of the Compact Profiles defined in Java SE 8; and
							</p>
						</li><li class="listitem">
							<p>
								Custom configurations which contain only a specified set of modules possibly augmented by external library and application modules, and the modules 
								transitively required by all of these modules.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					The definition of the modular structure should make a clear distinction between standard modules, whose specifications are governed by the Java Community Process, and 
					modules that are specific to the JDK. It should also distinguish modules that are included in the Java SE Platform Specification, and thereby made mandatory in every 
					Platform Implementation, from all other modules.
				</p>
				<p>
					Project Jigsaw aims to design and implement a standard module system for the Java SE Platform and to apply that system to the Platform itself, and to the JDK. Its primary 
					goals are to make implementations of the Platform more easily scalable down to small devices, improve security and maintainability, enable improved application performance, 
					and provide developers with better tools for programming in the large.
				</p>
				<p>
					The modular structure of the JDK implements the following principles:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							<p>
								Standard modules, whose specifications are governed by the JCP, have names starting with the string "<code class="code">java.</code>".
							</p>
						</li><li class="listitem">
							<p>
								All other modules are merely part of the JDK, and have names starting with the string "<code class="code">jdk.</code>".
							</p>
						</li><li class="listitem">
							<p>
								If a module exports a package that contains a type that contains a public or protected member that, in turn, refers 
								to a type from some other module, then the first module must grant implied readability to the second, via <code class="code">requires 
								transitive</code>. (This ensures that method-invocation chaining works in the obvious way.)
							</p>
						</li><li class="listitem">
							<p>
								A standard module may contain both standard and non-standard API packages. If a standard module exports a standard API 
								package then the export may be qualified; if a standard module exports a non-standard API package then the export must 
								be qualified. In either case, if a standard module exports a package with qualification then the export must be to some 
								subset of the modules in the JDK. If a standard module is a Java SE module, i.e., is included in the Java SE Platform 
								Specification, then it must not export any non-SE API packages, at least not without qualification.
							</p>
						</li><li class="listitem">
							<p>
								A standard module may depend upon one or more non-standard modules. It must not grant implied readability to any non-standard 
								module. If it is a Java SE module then it must not grant implied readability to any non-SE module.
							</p>
						</li><li class="listitem">
							<p>
								A non-standard module must not export any standard API packages. A non-standard module may grant implied readability to a standard module.
							</p>
						</li></ol></div><p>
					An important consequence of principles 4 and 5 is that code that depends only upon Java SE modules will depend only upon standard Java SE types, and thus 
					be portable to all Implementations of the Java SE Platform.
				</p>
				<p>
					<span class="bold"><strong>The module list</strong></span>
				</p>
				<p>
					You can list all JDK modules by running this command:
					</p><pre class="programlisting">
java --list-modules
					</pre><p>
					List of Java 11 modules is shown below:
					</p><pre class="programlisting">
java.base@11.0.2
java.compiler@11.0.2
java.datatransfer@11.0.2
java.desktop@11.0.2
java.instrument@11.0.2
java.logging@11.0.2
java.management@11.0.2
java.management.rmi@11.0.2
java.naming@11.0.2
java.net.http@11.0.2
java.prefs@11.0.2
java.rmi@11.0.2
java.scripting@11.0.2
java.se@11.0.2
java.security.jgss@11.0.2
java.security.sasl@11.0.2
java.smartcardio@11.0.2
java.sql@11.0.2
java.sql.rowset@11.0.2
java.transaction.xa@11.0.2
java.xml@11.0.2
java.xml.crypto@11.0.2
jdk.accessibility@11.0.2
jdk.aot@11.0.2
jdk.attach@11.0.2
jdk.charsets@11.0.2
jdk.compiler@11.0.2
jdk.crypto.cryptoki@11.0.2
jdk.crypto.ec@11.0.2
jdk.crypto.mscapi@11.0.2
jdk.dynalink@11.0.2
jdk.editpad@11.0.2
jdk.hotspot.agent@11.0.2
jdk.httpserver@11.0.2
jdk.internal.ed@11.0.2
jdk.internal.jvmstat@11.0.2
jdk.internal.le@11.0.2
jdk.internal.opt@11.0.2
jdk.internal.vm.ci@11.0.2
jdk.internal.vm.compiler@11.0.2
jdk.internal.vm.compiler.management@11.0.2
jdk.jartool@11.0.2
jdk.javadoc@11.0.2
jdk.jcmd@11.0.2
jdk.jconsole@11.0.2
jdk.jdeps@11.0.2
jdk.jdi@11.0.2
jdk.jdwp.agent@11.0.2
jdk.jfr@11.0.2
jdk.jlink@11.0.2
jdk.jshell@11.0.2
jdk.jsobject@11.0.2
jdk.jstatd@11.0.2
jdk.localedata@11.0.2
jdk.management@11.0.2
jdk.management.agent@11.0.2
jdk.management.jfr@11.0.2
jdk.naming.dns@11.0.2
jdk.naming.rmi@11.0.2
jdk.net@11.0.2
jdk.pack@11.0.2
jdk.rmic@11.0.2
jdk.scripting.nashorn@11.0.2
jdk.scripting.nashorn.shell@11.0.2
jdk.sctp@11.0.2
jdk.security.auth@11.0.2
jdk.security.jgss@11.0.2
jdk.unsupported@11.0.2
jdk.unsupported.desktop@11.0.2
jdk.xml.dom@11.0.2
jdk.zipfs@11.0.2
					</pre><p> 
				</p>
				<p>
					<span class="bold"><strong>The module graph</strong></span>
				</p>
				<p>
					The modular structure of the JDK can be visualized as a graph: Each module is a node, and there is a directed edge from one module to another if the first depends 
					upon the second. The full module graph has too many edges to be displayed easily.
				</p>
				<p>
					Here is the <a class="ulink" href="images/java11-graph.png" target="_top">Java SE 11 Module Graph</a>. 
				</p>
				<p>
					Please take a look at appendix for the instruction how you can re-create it: <a class="xref" href="#a1s1" title="1.1.&nbsp;How to build JDK module graph">&#8220;How to build JDK module graph&#8221;</a> 
				</p>
				<p>
					Herewith a guided tour of the Java 11 module graph:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Standard Java SE modules (<code class="code">java.</code>) are colored Cyan; non-SE modules (<code class="code">jdk.</code>) are colored Dark Sea Green.							
							</p>
						</li><li class="listitem">
							<p>
								If one module depends upon another, then there is an edge from the first module to the second. 							
							</p>
						</li><li class="listitem">
							<p>
								At the very bottom is the <code class="code">java.base</code> module, which contains essential classes such as <code class="code">java.lang.Object</code> 
								and <code class="code">java.lang.String</code>. The base module depends upon no module, and every other module depends upon the base module. 
							</p>
						</li><li class="listitem">
							<p>
								Near the top is the <code class="code">java.se</code> module, which gathers together all of the modules that comprise the Java SE Platform. This is an example 
								of an <span class="emphasis"><em>aggregator module</em></span>, which collects and re-exports the content of other modules but adds no content of its own. A run-time 
								system configured to contain the <code class="code">java.se</code> module will contain all of the API packages of the Java SE Platform. A module is included in 
								the Java SE Platform Specification if, and only if, it is a standard module reachable from the <code class="code">java.se</code> module.		
							</p>
						</li><li class="listitem">
							<p>
								The non-standard modules (<code class="code">jdk.</code>) include debugging and serviceability tools and APIs, development tools, and various service providers, which 
								are made available to other modules via the existing <code class="code">java.util.ServiceLoader</code> mechanism.
							</p>
						</li><li class="listitem">
							<p>
								The <code class="code">java.smartcardio</code> module is standard but not part of the Java SE Platform Specification, hence its name starts with the 
								string "<code class="code">java.</code>" but it is not reachable from the <code class="code">java.se</code> module.
							</p>
						</li></ul></div><p>					
				</p>
				<p>
					<span class="bold"><strong>Using <code class="code">jlink</code> to build Java Runtime Environments</strong></span>
				</p>
				<p>
					Since Java 9 the Java Platform Module System (JPMS) has divided the monolithic <code class="code">rt.jar</code> and <code class="code">tools.jar</code> files into more than 70 
					distinct modules.					
				</p>
				<p>
					As of JDK 9 also eliminated the distinction between the Java Development Kit (JDK) and the Java Runtime Environment (JRE). In the past, there 
					was a sub-directory in the JDK called <code class="code">jre</code> which only contained things that were required to run a Java application.
				</p>
				<p>
					In JDK 9 and later, the idea is to build Java Runtime Environments that are tailored to the requirements of a specific application. Rather 
					than including all modules, you need only include the <code class="code">java.base</code> module (which all runtimes must include by definition) as well 
					as any other modules the application references. All <code class="code">transitive</code> module dependencies must also be included. JDK 9 and later 
					provides the <code class="code">jlink</code> command to assemble and optimize a set of modules and their dependencies into a custom runtime image.
				</p>
				<p>
					Let's create a sample modular application, as shown below:
					</p><pre class="programlisting">
C:\1Z0-817-JLINK
&#9474;   module-info.java
&#9474;
&#9492;&#9472;&#9472;&#9472;app
        App.java
					</pre><p>
					<code class="code">module-info.java</code>:
					</p><pre class="programlisting">
module MOD {    
}
					</pre><p>
					<code class="code">App.java</code>:
					</p><pre class="programlisting">
package app;

public class App {
    public static void main(String[] args) {
        System.out.println("Hello jlink !");
    }
}
					</pre><p>
				</p>
				<p>
					To run this program, we only need <code class="code">App</code>, <code class="code">String</code>, System, and <code class="code">Object</code> classes.
				</p>
				<p>
					With help of <code class="code">jlink</code> command line utility we can create our own small JRE that contains only the relevant classes 
					and packages that application needs to use, without wasting memory and disk space.
				</p>
				<p>
					 Let's compile the code:
					 </p><pre class="programlisting">
C:\1Z0-817-jlink&gt;javac -p . module-info.java app/App.java
					 </pre><p>
					 </p><pre class="programlisting">
C:\1Z0-817-JLINK
&#9474;   module-info.class
&#9474;   module-info.java
&#9474;
&#9492;&#9472;&#9472;&#9472;app
        App.class
        App.java
					 </pre><p>
				</p>
				<p>
					Now, create the modular JAR:
					</p><pre class="programlisting">
C:\1Z0-817-jlink&gt;jar cf app.jar -C . .
					</pre><p>
				</p>
				<p>
					In order to use <code class="code">jlink</code>, we need to know the list of the Java SE modules that the application uses and 
					that we should include in our custom JRE. Let's use the <code class="code">jdeps</code> command to list the modules used in the 
					application:
					</p><pre class="programlisting">
C:\1Z0-817-jlink&gt;jdeps --list-deps app.jar
   java.base
					</pre><p>
				</p>
				<p>
					To create a custom JRE for a module based application we use the <code class="code">jlink</code> command:
					</p><pre class="programlisting">
C:\1Z0-817-jlink&gt;jlink --add-modules java.base --output java-runtime
					</pre><p>
				</p>
				<p>
					The comma separated list of modules after the <code class="code">-&#8211;add-modules</code> option tells <code class="code">jlink</code> which modules to 
					include in the new JRE.
				</p>
				<p>
					The <code class="code">-&#8211;output</code> option defines the target directory where our custom JRE should be generated.
				</p>
				<p>
					The size of custom JRE (created with Java 11) is about 39 Mbytes:
					</p><pre class="programlisting">
C:\1Z0-817-jlink\java-runtime&gt;dir /s
...
     Total Files Listed:
              91 File(s)     41,226,208 bytes
					</pre><p> 
				</p>
				<p>
					To test our new JRE, let's try to run our module by navigating inside the <code class="code">bin</code> 
					folder of our <code class="code">java-runtime</code> directory and run the command:
					</p><pre class="programlisting">
C:\1Z0-817-jlink\java-runtime\bin&gt;java.exe -p ../../app.jar --module MOD/app.App
Hello jlink !
					</pre><p>
				</p>
				<p>
					You can also create a custom JRE with executable launcher scripts (for Windows and Linux). For this, you need to run 
					the <code class="code">jlink</code> command that has an extra <code class="code">-&#8211;launcher</code> option to create launcher with the application module 
					and main class (NOTE: delete old custom JRE before creating new):
					</p><pre class="programlisting">
C:\1Z0-817-jlink&gt;jlink -p ./app.jar --add-modules java.base,MOD --output java-runtime --launcher app=MOD/app.App
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817-jlink\java-runtime\bin&gt;dir app*
 
  Directory of C:\1Z0-817-jlink\java-runtime\bin

05/25/2019  00:45                91 app
05/25/2019  00:45               100 app.bat
               2 File(s)            191 bytes
					</pre><p>
					Generated <code class="code">app.bat</code>:
					</p><pre class="programlisting">
@echo off
set JLINK_VM_OPTIONS=
set DIR=%~dp0
"%DIR%\java" %JLINK_VM_OPTIONS% -m MOD/app.App %*
					</pre><p>
					Run the script:
					</p><pre class="programlisting">
C:\1Z0-817-jlink\java-runtime\bin&gt;app.bat
Hello jlink !
					</pre><p>
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c1s2"></a>1.2.&nbsp;
					 Declare modules and enable access between modules
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 15.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					A Java platform module consists of:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								A collection of packages							
							</p>
						</li><li class="listitem">
							<p>
								Optionally, resource files and other files such as native libraries							
							</p>
						</li><li class="listitem">
							<p>
								A list of the accessible packages in the module							
							</p>
						</li><li class="listitem">
							<p>
								A list of all modules on which this module depends						
							</p>
						</li></ul></div><p>
				</p>
				<p>
					There are four types of modules in the Java Platform Module System (JPMS):
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								System Modules
							</p>
							<p>
								These are the modules listed when we run the <code class="code">java --list-modules</code> command. They include the 
								Java SE (<code class="code">java.</code>) and JDK (<code class="code">jdk.</code>) modules.
							</p>
						</li><li class="listitem">
							<p>
								Application Modules
							</p>
							<p>
								These modules are what we usually want to build. They are named and defined in the <code class="code">module-info.java</code> file,
								which compiled into <code class="code">module-info.class</code> file and included in JAR file.
							</p>
						</li><li class="listitem">
							<p>
								Automatic Modules
							</p>
							<p>
								Module system  automatically creates an automatic module for plain JARs (with no module descriptor). 
							</p>
							<p>
								If the JAR defines the <code class="code">Automatic-Module-Name</code> header in its manifest (<code class="code">META-INF/MANIFEST.MF</code>), 
								it defines the module's name, otherwise the JAR file name is used to determine the name.
							</p>
							<p>
								Since the JAR contains no information which packages are considered public APIs and which are not, the module 
								system exports all packages and also opens them for deep reflection.
							</p>
							<p>
								Since a plain JAR expresses no <code class="code">requires</code> clauses, the module system lets automatic modules read all other modules.
							</p>
						</li><li class="listitem">
							<p>
								Unnamed Module
							</p>
							<p>
								When a class or JAR is loaded onto the classpath, but not the module path, it is automatically added to the unnamed module. 
								It is a catch-all module to maintain backward compatibility with previously-written Java code.
							</p>
							<p>
								All classes within the unnamed module can read all other module (named or unnamed) without any explicit declaration of any kind.
							</p>
							<p>
								The packages exported by unnamed module can only be read by another unnamed module. It is not possible that a named module 
								can read (requires) the unnamed module. Because to explicitly use '<code class="code">requires</code>' clause in a <code class="code">module-info.java</code> or 
								use a command line option to add the module, we need a module name.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					When creating an appication module, it is important that its name is unique. It is expected that module names will follow the "reverse domain
					name" convention, just like package names. For example "<code class="code">by.boot.java</code>"
				</p>
				<p>
					A module name can be the same as package name, however it can be different too, for example <code class="code">java.sql</code> module 
					contains <code class="code">java.sql</code> and <code class="code">javax.sql</code> packages:
					</p><pre class="programlisting">
C:\Program Files\Java\jdk-11.0.2&gt;java --describe-module java.sql
java.sql@11.0.2
exports java.sql
exports javax.sql
requires java.transaction.xa transitive
requires java.logging transitive
requires java.xml transitive
requires java.base mandated
uses java.sql.Driver
					</pre><p>
				</p>
				<p>
					To declare an application module, a module declaration needs to be specified. This is done in a special file called 
					<code class="code">module-info.java</code>. As you can see from the file extension, this is a <code class="code">.java</code> file that gets compiled 
					into a <code class="code">.class</code> file by the Java compiler.
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
}
					</pre><p>
					There could be additional directives between curly braces, but all of them are optional.  
				</p>
				<p>
					Next, create a new class for the module:
					</p><pre class="programlisting">
package by.boot.java.pkg.logger;
public class MyLogger {
    public static void main(String[] args) {
        System.out.println("MyLogger - main() method called");
    }
}
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Module may not have classes with unnamed package (i.e. those which belong to "default" package)
					</p>
				</td></tr></table></div>
				<p>
					Special <code class="code">module-info.java</code> file must be at the root of Java class packages. Place sources as follows:
					</p><pre class="programlisting">
C:\1Z0-817
&#9492;&#9472;&#9472;&#9472;mod1
    &#9474;   module-info.java
    &#9474;
    &#9492;&#9472;&#9472;&#9472;by
        &#9492;&#9472;&#9472;&#9472;boot
            &#9492;&#9472;&#9472;&#9472;java
                &#9492;&#9472;&#9472;&#9472;pkg
                    &#9492;&#9472;&#9472;&#9472;logger
                            MyLogger.java
					</pre><p>
				</p>
				<p>
					Compile the sources (normally this will be done by IDE for you, but for learning purposes we do it from command line):
					</p><pre class="programlisting">
C:\1Z0-817\mod1&gt;javac module-info.java
C:\1Z0-817\mod1&gt;javac by/boot/java/pkg/logger/MyLogger.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817
&#9492;&#9472;&#9472;&#9472;mod1
    &#9474;   module-info.class
    &#9474;   module-info.java
    &#9474;
    &#9492;&#9472;&#9472;&#9472;by
        &#9492;&#9472;&#9472;&#9472;boot
            &#9492;&#9472;&#9472;&#9472;java
                &#9492;&#9472;&#9472;&#9472;pkg
                    &#9492;&#9472;&#9472;&#9472;logger
                            MyLogger.class
                            MyLogger.java
					</pre><p>
				</p>
				<p>
					To run a modular application, you specify the module path, which is similar to the class path, but 
					contains modules. You also specify the main class in the format <code class="code">modulename/classname</code>:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java --module-path ./mod1 --module by.boot.java.mod.logger/by.boot.java.pkg.logger.MyLogger
MyLogger - main() method called
					</pre><p>
					Instead of <code class="code">--module-path</code> and <code class="code">--module</code>, you can use the single-letter options
					<code class="code">-p</code> and <code class="code">-m</code>:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p ./mod1 -m by.boot.java.mod.logger/by.boot.java.pkg.logger.MyLogger
MyLogger - main() method called
					</pre><p>
				</p>
				<p>
					You can create a modular JAR file using <code class="code">jar</code> utility:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar --create --file log.jar --main-class by.boot.java.pkg.logger.MyLogger --module-version 1.0.0 -C mod1 .
					</pre><p>
					it creates a modular JAR with the following structure:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar -tvf log.jar
     0 Thu Mar 21 23:07:34 AST 2019 META-INF/
   112 Thu Mar 21 23:07:34 AST 2019 META-INF/MANIFEST.MF
   299 Thu Mar 21 23:07:34 AST 2019 module-info.class
     0 Wed Mar 20 23:30:22 AST 2019 by/
     0 Wed Mar 20 23:30:28 AST 2019 by/boot/
     0 Wed Mar 20 23:30:36 AST 2019 by/boot/java/
     0 Wed Mar 20 23:30:40 AST 2019 by/boot/java/pkg/
     0 Wed Mar 20 23:34:54 AST 2019 by/boot/java/pkg/logger/
   465 Wed Mar 20 23:34:54 AST 2019 by/boot/java/pkg/logger/MyLogger.class
   179 Wed Mar 20 23:31:06 AST 2019 by/boot/java/pkg/logger/MyLogger.java
    37 Wed Mar 20 23:24:24 AST 2019 module-info.java
   					</pre><p>
				</p>
				<p>
					Make a note of <code class="code">META-INF/MANIFEST.MF</code> content:
					</p><pre class="programlisting">
Manifest-Version: 1.0
Created-By: 11.0.2 (Oracle Corporation)
Main-Class: by.boot.java.pkg.logger.MyLogger
					</pre><p>
				</p>				
				<p>
					You can also use <code class="code">jar</code> utility to check structure of the module:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar -d -f log.jar
by.boot.java.mod.logger@1.0.0 jar:file:///C:/1Z0-817/log.jar/!module-info.class
requires java.base mandated
contains by.boot.java.pkg.logger
main-class by.boot.java.pkg.logger.MyLogger
					</pre><p>
				</p>
				<p>
					Finally, you can run the <code class="code">Main-Class</code> from the created modular JAR:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p ./log.jar -m by.boot.java.mod.logger
MyLogger - main() method called
					</pre><p>
					If the main class would not have beed defined, you can provide it explicitly:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p ./log.jar -m by.boot.java.mod.logger/by.boot.java.pkg.logger.MyLogger
MyLogger - main() method called
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong><code class="code">requires</code> directive</strong></span>
				</p>
				<p>
					By default our module implicitly requires only <code class="code">java.base</code> which contains basic modules:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java --describe-module java.base
java.base@11.0.2
exports java.io
exports java.lang
...
exports java.math
exports java.net
exports java.nio
exports java.security
exports java.text
exports java.time
exports java.util
exports java.util.concurrent
exports java.util.concurrent.atomic
exports java.util.concurrent.locks
exports java.util.function
exports java.util.jar
...
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						All standard Java SE modules have implicit and mandatory dependency on <code class="code">java.base</code>. You do not need 
						to define dependency on <code class="code">java.base</code> explicitly.  
					</p>
				</td></tr></table></div>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						It is not allowed to have circular dependencies between modules. If module <code class="code">A</code> requires module <code class="code">B</code>, then 
						module <code class="code">B</code> cannot also require module <code class="code">A</code>.  
					</p>
				</td></tr></table></div>				
				<p>
					Imagine you want to use <code class="code">java.util.logging</code> package which resides in the <code class="code">java.logging</code> module. In this 
					case you must explicitly request it. Update the class first:
					</p><pre class="programlisting">
package by.boot.java.pkg.logger;

import java.util.logging.Logger;

public class MyLogger {
    
    private static final Logger LOG = Logger.getLogger(MyLogger.class.getName());
    
    public static void main(String[] args) {
        System.out.println("MyLogger - main() method called");
    }
    
    public static void log() {
        LOG.info("MyLogger - log() method called");
    }
}
					</pre><p>
					recompile the class:
					</p><pre class="programlisting">
C:\1Z0-817\mod1&gt;javac by/boot/java/pkg/logger/MyLogger.java
					</pre><p>
					So far so good. But as soon as you run the class you get an exception:
					</p><pre class="programlisting">

C:\1Z0-817&gt;java -p ./mod1 -m by.boot.java.mod.logger/by.boot.java.pkg.logger.MyLogger

Exception in thread "main" java.lang.IllegalAccessError: class by.boot.java.pkg.logger.MyLogger (in module by.boot.java.mod.logger) 
cannot access class java.util.logging.Logger (in module java.logging) because module by.boot.java.mod.logger does not read module java.logging
        at by.boot.java.mod.logger/by.boot.java.pkg.logger.MyLogger.&lt;clinit&gt;(MyLogger.java:7)

					
					</pre><p>
					in order to fix the problem we must add <code class="code">requires</code> directive to <code class="code">module-info.java</code>, which allows us to
					declare dependencies:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires java.logging;
}
					</pre><p>
					Now  <code class="code">by.boot.java.mod.logger</code> module has both a runtime and a compile-time dependency on 
					<code class="code">java.logging</code> module. And all public types exported from a dependency are accessible 
					by our module when we use this directive.
				</p>
				<p>
					Recompile the module declaration <code class="code">module-info.java</code> file and re-run <code class="code">MyLogger</code> class:
					</p><pre class="programlisting">
C:\1Z0-817\mod1&gt;javac module-info.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\mod1&gt;java -p . -m by.boot.java.mod.logger/by.boot.java.pkg.logger.MyLogger
MyLogger - main() method called
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong><code class="code">requires static</code> directive</strong></span>
				</p>
				<p>
					You can use <code class="code">requires static</code> to specify that a module dependency is required in the compile time, but optional in the runtime, for example:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires static java.logging;
}
					</pre><p>
					Static dependencies are useful for frameworks and libraries. Suppose that you are building a library to work with different kinds of databases. The 
					library module can use static dependencies to require different kinds of JDBC drivers. At compile time, the library&#8217;s code can access types defined 
					in those drivers. At runtime, users of the library can add only the drivers they want to use. If the dependencies are not static, users of the library 
					have to add all supported drivers to pass the module resolution checks.
				</p>
				<p>
					<span class="bold"><strong><code class="code">exports</code> directive</strong></span>
				</p>
				<p>
					Assume we create new client module which uses our logger module. We already know that we must declare in <code class="code">module-info.java</code> which modules 
					are required:  
					</p><pre class="programlisting">
module by.boot.java.mod.client {
    requires by.boot.java.mod.logger;
}
					</pre><p>
					and a client class:
					</p><pre class="programlisting">
package by.boot.java.pkg.client;

import by.boot.java.pkg.logger.MyLogger;

public class MyClient {
    public static void main(String[] args) {
        MyLogger.log();
    }
}
					</pre><p>
				</p>
				<p>
					The project with two modules will look as follows:
					</p><pre class="programlisting">
C:\1Z0-817
&#9500;&#9472;&#9472;&#9472;mod1
&#9474;   &#9474;   module-info.class
&#9474;   &#9474;   module-info.java
&#9474;   &#9474;
&#9474;   &#9492;&#9472;&#9472;&#9472;by
&#9474;       &#9492;&#9472;&#9472;&#9472;boot
&#9474;           &#9492;&#9472;&#9472;&#9472;java
&#9474;               &#9492;&#9472;&#9472;&#9472;pkg
&#9474;                   &#9492;&#9472;&#9472;&#9472;logger
&#9474;                           MyLogger.class
&#9474;                           MyLogger.java
&#9474;
&#9492;&#9472;&#9472;&#9472;mod2
    &#9474;   module-info.java
    &#9474;
    &#9492;&#9472;&#9472;&#9472;by
        &#9492;&#9472;&#9472;&#9472;boot
            &#9492;&#9472;&#9472;&#9472;java
                &#9492;&#9472;&#9472;&#9472;pkg
                    &#9492;&#9472;&#9472;&#9472;client
                            MyClient.java
					</pre><p>
					Now compile the new code:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p ./mod1 mod2/module-info.java
					</pre><p>
					As soon as you try to compile <code class="code">MyClient.java</code> it fails:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p ./mod1 mod2/by/boot/java/pkg/client/MyClient.java
mod2\by\boot\java\pkg\client\MyClient.java:3: error: package by.boot.java.pkg.logger is not visible
import by.boot.java.pkg.logger.MyLogger;
                       ^
  (package by.boot.java.pkg.logger is declared in module by.boot.java.mod.logger, which is not in the module graph)
1 error					
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						By default, a module doesn&#8217;t expose any of its API to other modules. This strong encapsulation was 
						one of the key motivators for creating the module system in the first place.  
					</p>
				</td></tr></table></div>
				<p>
					As you can see, the <code class="code">by.boot.java.mod.logger</code> module classes are not visible in the <code class="code">by.boot.java.mod.client</code>
					module, even after we declared it as required. Our code is significantly more secure, but now we need to explicitly open 
					our API up to the world if we want it to be usable.
				</p>
				<p>
					We need to use the <code class="code">exports</code> directive to expose all <code class="code">public</code> members of the <code class="code">by.boot.java.pkg.logger</code> package:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires java.logging;
    exports by.boot.java.pkg.logger;
}
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						You define <span class="bold"><strong>module name</strong></span> with <code class="code">requires</code> directive.  
					</p>
					<p>
						You define <span class="bold"><strong>package name</strong></span> with <code class="code">exports</code> directive.  
					</p>
				</td></tr></table></div>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						When you export a package, you only export types in this package but not types in its subpackages.  
					</p>
				</td></tr></table></div>
				<p>
					The same Java package can only be exported by a single Java module at runtime. You cannot have two (or more) modules that 
					export the same package in use at the same time. The JVM will complain at startup if you do. A Java package may not split 
					members (classes, interfaces, enums) between multiple modules.
				</p>
				<p>	
					Re-compile logger module definition:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac mod1/module-info.java mod1/by/boot/java/pkg/logger/MyLogger.java
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						You may not export empty or non-existent package:
						</p><pre class="programlisting">
C:\1Z0-817&gt;javac mod1/module-info.java mod1/by/boot/java/pkg/logger/MyLogger.java
mod1\module-info.java:4: error: package is empty or does not exist: aaa
    exports aaa;
            ^
1 error
						</pre><p>  
					</p>
				</td></tr></table></div>	
				<p>
					Now you can compile and run client class:
					</p><pre class="programlisting">
C:\1Z0-817\mod2&gt;javac -p ../mod1; module-info.java by/boot/java/pkg/client/MyClient.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\mod2&gt;java -p ../mod1;. -m by.boot.java.mod.client/by.boot.java.pkg.client.MyClient
Mar 22, 2019 11:59:29 PM by.boot.java.pkg.logger.MyLogger log
INFO: MyLogger - log() method called
					</pre><p>
					The project structure looks as follows:
					</p><pre class="programlisting">
C:\1Z0-817
&#9500;&#9472;&#9472;&#9472;mod1
&#9474;   &#9474;   module-info.class
&#9474;   &#9474;   module-info.java
&#9474;   &#9474;
&#9474;   &#9492;&#9472;&#9472;&#9472;by
&#9474;       &#9492;&#9472;&#9472;&#9472;boot
&#9474;           &#9492;&#9472;&#9472;&#9472;java
&#9474;               &#9492;&#9472;&#9472;&#9472;pkg
&#9474;                   &#9492;&#9472;&#9472;&#9472;logger
&#9474;                           MyLogger.class
&#9474;                           MyLogger.java
&#9474;
&#9492;&#9472;&#9472;&#9472;mod2
    &#9474;   module-info.class
    &#9474;   module-info.java
    &#9474;
    &#9492;&#9472;&#9472;&#9472;by
        &#9492;&#9472;&#9472;&#9472;boot
            &#9492;&#9472;&#9472;&#9472;java
                &#9492;&#9472;&#9472;&#9472;pkg
                    &#9492;&#9472;&#9472;&#9472;client
                            MyClient.class
                            MyClient.java
					</pre><p>
				</p>
				<p>
					If you fail to list all modules in the modules path option, you get a <code class="code">java.lang.module.FindException</code>:
					</p><pre class="programlisting">
C:\1Z0-817\mod2&gt;java -p . -m by.boot.java.mod.client/by.boot.java.pkg.client.MyClient
Error occurred during initialization of boot layer
java.lang.module.FindException: Module by.boot.java.mod.logger not found, required by by.boot.java.mod.client
					</pre><p>  					
				</p>
				<p>
					<span class="bold"><strong><code class="code">exports...to</code> directive</strong></span>
				</p>
				<p>
					When you are using <code class="code">exports</code> directive to export a package in the module declaration, this package is visible to all
					modules that use <code class="code">requires</code> directive to require it. Sometimes you may want to limit the visibility of certain packages
					to some modules only.
				</p>
				<p>
					 You can restrict which modules have access to your packages by using the <code class="code">exports ... to &lt;module name&gt;</code> syntax:
					 </p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires java.logging;
    exports by.boot.java.pkg.logger to by.boot.java.mod.client;
}
					 </pre><p>
				</p>
				<p>
					<span class="bold"><strong>Open modules</strong></span>
				</p>
				<p>
					In the module declaration, you can add the modifier <code class="code">open</code> before module to declare it as an open module. An
					open module grants compile time access to explicitly exported packages only, but it grants access to types in
					all its packages at runtime:
					</p><pre class="programlisting">
open module by.boot.java.mod.logger {
    requires java.logging;
}
					</pre><p>
					Re-compile the <code class="code">by.boot.java.mod.logger</code> module definition and re-run the client:
					</p><pre class="programlisting">
C:\1Z0-817\mod1&gt;javac module-info.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p ./mod1;./mod2 -m by.boot.java.mod.client/by.boot.java.pkg.client.MyClient
Mar 23, 2019 11:06:33 PM by.boot.java.pkg.logger.MyLogger log
INFO: MyLogger - log() method called
					</pre><p>
					NOTE: since we have already compiled <code class="code">MyClient</code> class, we succeeded, because all packages accessible at runtime. However, 
					if we want to re-compile <code class="code">MyClient.java</code>, then <code class="code">exports</code> declaration will be a must 
					(e.g. <code class="code">exports by.boot.java.pkg.logger to by.boot.java.mod.client;</code>).  				
				</p>
				<p>
					Before Java 9 (and Java 11), it was possible to use reflection to examine every type and member in a package, even 
					the <code class="code">private</code> ones by using <code class="code">field.setAccessible(true)</code>. 
				</p>
				<p>
					The <code class="code">open</code> modifier also grants reflective access to all types in all packages. All types include <code class="code">private</code>
					types and their <code class="code">private</code> members. If you use the reflection API and suppress Java language access checks using the method 
					<code class="code">AccessibleObject.setAccessible(true)</code> &#8212; you can access <code class="code">private</code> types and members in open modules.
				</p>
				<p>
					Restore <code class="code">by.boot.java.mod.logger</code> module definition as follows:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires java.logging;
    exports by.boot.java.pkg.logger to by.boot.java.mod.client;
}
					</pre><p>
					and add new <code class="code">AccessLog</code> class in the <code class="code">by.boot.java.mod.client</code> module:
					</p><pre class="programlisting">
package by.boot.java.pkg.client;

import by.boot.java.pkg.logger.MyLogger;
import java.lang.reflect.Field;

public class AccessLog {
    public static void main(String[] args) throws Exception {
        MyLogger myClass = new MyLogger();
        Field field1 = myClass.getClass().getDeclaredField("LOG"); // private field LOG in MyLogger 
        field1.setAccessible(true);
        System.out.print(field1.get(myClass).getClass().getCanonicalName());
    }
}					
					</pre><p>
					Compile both changed sources:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p ./mod1;./mod2 ./mod1/module-info.java ./mod1/by/boot/java/pkg/logger/MyLogger.java

C:\1Z0-817&gt;javac -p ./mod1; ./mod2/module-info.java ./mod2/by/boot/java/pkg/client/AccessLog.java
					</pre><p>
					and run the <code class="code">AccessLog</code>, which attempts to read <code class="code">private</code> field via reflection:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p ./mod1;./mod2 -m by.boot.java.mod.client/by.boot.java.pkg.client.AccessLog

Exception in thread "main" java.lang.reflect.InaccessibleObjectException: Unable to make field private static final java.util.logging.Logger 
by.boot.java.pkg.logger.MyLogger.LOG accessible: module by.boot.java.mod.logger does not "opens by.boot.java.pkg.logger" 
to module by.boot.java.mod.client                                                                                                                                 
        at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:340)
        at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:280)
        at java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:176)
        at java.base/java.lang.reflect.Field.setAccessible(Field.java:170)
        at by.boot.java.mod.client/by.boot.java.pkg.client.AccessLog.main(AccessLog.java:10)
					</pre><p>
				</p>
				<p>
					In order to fix code, make the <code class="code">by.boot.java.mod.logger</code> module open, and in the same time you can
					remove <code class="code">exports</code> directive, since we do not need to compile <code class="code">AccessLog</code> class:
					</p><pre class="programlisting">
open module by.boot.java.mod.logger {
    requires java.logging;
}

					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817
&#9500;&#9472;&#9472;&#9472;mod1
&#9474;   &#9474;   module-info.class
&#9474;   &#9474;   module-info.java
&#9474;   &#9474;
&#9474;   &#9492;&#9472;&#9472;&#9472;by
&#9474;       &#9492;&#9472;&#9472;&#9472;boot
&#9474;           &#9492;&#9472;&#9472;&#9472;java
&#9474;               &#9492;&#9472;&#9472;&#9472;pkg
&#9474;                   &#9492;&#9472;&#9472;&#9472;logger
&#9474;                           MyLogger.class
&#9474;                           MyLogger.java
&#9474;
&#9492;&#9472;&#9472;&#9472;mod2
    &#9474;   module-info.class
    &#9474;   module-info.java
    &#9474;
    &#9492;&#9472;&#9472;&#9472;by
        &#9492;&#9472;&#9472;&#9472;boot
            &#9492;&#9472;&#9472;&#9472;java
                &#9492;&#9472;&#9472;&#9472;pkg
                    &#9492;&#9472;&#9472;&#9472;client
                            AccessLog.class
                            AccessLog.java
                            MyClient.class
                            MyClient.java
					</pre><p>
					Recompile <code class="code">by.boot.java.mod.logger</code> module definition:
					</p><pre class="programlisting">
C:\1Z0-817\mod1&gt;javac module-info.java					
					</pre><p>
 					And re-run <code class="code">AccessLog</code> class:
 					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p ./mod1;./mod2 -m by.boot.java.mod.client/by.boot.java.pkg.client.AccessLog
java.util.logging.Logger
 					</pre><p>
 					As you can see, open module granted access to private field via reflection API.
				</p>
				<p>
					<span class="bold"><strong><code class="code">opens</code> directive</strong></span>
				</p>
				<p>
					The <code class="code">opens</code> directive specifies the name of a package to be opened by the current module. This makes 
					<code class="code">public</code> and <code class="code">protected</code> types in the package, and their <code class="code">public</code> and <code class="code">protected</code> 
					members, be accessible to code in other modules at run time only. 
				</p>
				<p>
					It also makes all types in the package, and all their members, be accessible via the reflection libraries of the Java SE Platform.
				</p>
				<p>
					You can use <code class="code">opens</code> directive to open individual packages to other modules. You can access open packages using the
					reflection API at runtime. Just like open modules, all types in an open package and all their members (including <code class="code">private</code>) can be
					reflected by the reflection API:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires java.logging;
    exports by.boot.java.pkg.logger to by.boot.java.mod.client;
    opens by.boot.java.pkg.logger;
}
					</pre><p>
					You can also qualify open packages using <code class="code">to &lt;module name&gt;</code>:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires java.logging;
    exports by.boot.java.pkg.logger to by.boot.java.mod.client;
    opens by.boot.java.pkg.logger to by.boot.java.mod.client;
}
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong><code class="code">requires transitive</code> directive</strong></span>
				</p>
				<p>
					The module readability relationship is not transitive by default. In our example <code class="code">by.boot.java.mod.logger</code> module  can read <code class="code">java.logging</code> module,
					and <code class="code">by.boot.java.mod.client</code> module can read <code class="code">by.boot.java.mod.logger</code>. But <code class="code">by.boot.java.mod.client</code> cannot read classes from 
					<code class="code">java.logging</code> module. 
				</p>
				<p>
					Let's update code of <code class="code">MyLogger</code> and add <code class="code">getLog</code> method:
					</p><pre class="programlisting">
public class MyLogger {
	...    
    public static Logger getLog() {
        return LOG;
    }
}
					</pre><p>
					Re-compile the code:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p ./mod1;./mod2 ./mod1/module-info.java ./mod1/by/boot/java/pkg/logger/MyLogger.java
					</pre><p>
					Now <code class="code">MyLogger</code> class returns to outer world <code class="code">java.util.logging</code> package's type.
				</p>
				<p>
					Then update code of <code class="code">MyClient</code> class to get instance of <code class="code">java.util.logging.Logger</code> class:
					</p><pre class="programlisting">
import java.util.logging.Logger;

public class MyClient {
    public static void main(String[] args) {        
        ...
        Logger l = MyLogger.getLog();
    }
}
					</pre><p>
					Try to compile:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p ./mod1;./mod2 ./mod2/module-info.java ./mod2/by/boot/java/pkg/client/MyClient.java
.\mod2\by\boot\java\pkg\client\MyClient.java:3: error: package by.boot.java.pkg.logger is not visible
import by.boot.java.pkg.logger.MyLogger;
                       ^
  (package by.boot.java.pkg.logger is declared in module by.boot.java.mod.logger, which does not export it)
.\mod2\by\boot\java\pkg\client\MyClient.java:4: error: package java.util.logging is not visible
import java.util.logging.Logger;
                ^
  (package java.util.logging is declared in module java.logging, but module by.boot.java.mod.client does not read it)
2 errors
					</pre><p>
					As it shows, <code class="code">java.logging</code> module (and specifically <code class="code">java.util.logging.Logger</code>) is not 
					visible in <code class="code">by.boot.java.mod.client</code>. 
				</p>
				<p>
					It is the same situation we had in the beginning, and it can be resolved by adding <code class="code">requires java.logging;</code> directive
					to <code class="code">by.boot.java.mod.client</code> module's <code class="code">module-info.java</code>.
				</p>
				<p>
					This can be a tedious task when many modules depend on each other. Since this is a common usage scenario, Java 11 provides 
					built-in support for it. The <code class="code">requires</code> declaration can be extended to add the modifier 
					<code class="code">transitive</code> to declare the dependency as transitive. The transitive modules that a module
					depends on are readable by any module that depends upon this module. This is called implicit readability.
				</p>
				<p>
					In order to fix, edit <code class="code">module-info.java</code> of <code class="code">by.boot.java.mod.logger</code> module adding <code class="code">transitive</code> modifier:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires transitive java.logging;
    exports by.boot.java.pkg.logger to by.boot.java.mod.client;
    opens by.boot.java.pkg.logger to by.boot.java.mod.client;
}
					</pre><p>
					Now try to compile the code again, and it compiles without errors:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p ./mod1;./mod2 ./mod1/module-info.java ./mod1/by/boot/java/pkg/logger/MyLogger.java

C:\1Z0-817&gt;javac -p ./mod1;./mod2 ./mod2/module-info.java ./mod2/by/boot/java/pkg/client/MyClient.java
					</pre><p>
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c1s3"></a>1.3.&nbsp;
					   Describe how a modular project is compiled and run
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 15.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Unnamed module</strong></span>
				</p>
				<p>
					From Java 9 and forward, all Java classes must be located in a module for the Java VM to use them. But in Java 9 (and Java 11 too) you can still use the <code class="code">-classpath</code> (synonyms:
					<code class="code">-cp</code> and <code class="code">--class-path</code>) argument to the Java VM when running an application. On the classpath you can include all your older Java classes, just like you have 
					done before Java 9. All classes found on the classpath will be included in what Java calls the <span class="bold"><strong>unnamed module</strong></span>.
				</p>
				<p>
					The unnamed module <code class="code">exports</code> all its packages. However, the classes in the unnamed module are only readable by other classes in the unnamed module. No named module can read the 
					classes of the unnamed module.
				</p>
				<p>
					If a package is exported by a named module, but also found in the unnamed module, the package from the named module will be used.
				</p>
				<p>
					The unnamed module <code class="code">opens</code> all its packages. However, the classes in the unnamed module are only accessible via Reflection API by other classes in the unnamed module. 
					No named module can access via Reflection API the classes of the unnamed module.
				</p>
				<p>
					All classes in the unnamed module <code class="code">requires</code> all modules found on the module path. All classes in the unnamed module can read all classes exported by all 
					the Java modules found on the module path.
				</p>
				<p>
					Let's check scenario when named module code depends on unnamed module code. Create non-modular <code class="code">greeter.jar</code> with the <code class="code">p1.Greeter</code> class:
					</p><pre class="programlisting">
package p1;

public class Greeter {
    public static void greet() {
        System.out.println("Greeting from Java 8 !");
    }
}
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\LIB
&#9474;
&#9492;&#9472;&#9472;&#9472;p1
        Greeter.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\lib&gt;javac p1/Greeter.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\lib&gt;jar cvf greeter.jar p1
added manifest
adding: p1/(in = 0) (out= 0)(stored 0%)
adding: p1/Greeter.class(in = 409) (out= 288)(deflated 29%)
adding: p1/Greeter.java(in = 138) (out= 113)(deflated 18%)
					</pre><p>
				</p>
				<p>
					Now create named module for client:
					</p><pre class="programlisting">
package p2;

import p1.Greeter;

public class Client {
    public static void main(String[] args) {
        Greeter.greet();
    }
}
					</pre><p>
					with module definition:
					</p><pre class="programlisting">
module MOD { }
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\MOD3
&#9474;   module-info.java
&#9474;
&#9492;&#9472;&#9472;&#9472;p2
        Client.java
					</pre><p>
				</p>
				<p>
					Try to compile:
					</p><pre class="programlisting">
C:\1Z0-817\mod3&gt;javac -cp ../lib/greeter.jar module-info.java p2/Client.java
p2\Client.java:3: error: package p1 is not visible
import p1.Greeter;
       ^
  (package p1 is declared in the unnamed module, but module p1 does not read it)
1 error
					</pre><p>
					As you can see, named module <code class="code">MOD</code> cannot access at compile (and runtime) time class from unnamed module added via <code class="code">-cp</code> option.
				</p>
				<p>
					Now, try the opposite scenario: accessing named module (<code class="code">Greeter</code>) from unnamed module (<code class="code">Client</code>).					 				
				</p>
				<p>
					Create modular JAR first:
					</p><pre class="programlisting">
package p1;

public class Greeter {
    public static void greet() {
        System.out.println("Greeting from Java 9 !");
    }
}

					</pre><p>
					<code class="code">module-info.java</code>:
					</p><pre class="programlisting">
module MOD { 
	exports p1;
}
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\mod4&gt;javac module-info.java p1/Greeter.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\MOD4
&#9474;   module-info.class
&#9474;   module-info.java
&#9474;
&#9492;&#9472;&#9472;&#9472;p1
        Greeter.class
        Greeter.java
					</pre><p>
					Create a modular JAR:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar --create --file greeter.jar -C mod4 .
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar -tvf greeter.jar
     0 Fri Mar 29 23:16:54 AST 2019 META-INF/
    66 Fri Mar 29 23:16:54 AST 2019 META-INF/MANIFEST.MF
   186 Fri Mar 29 23:16:54 AST 2019 module-info.class
    14 Fri Mar 29 23:13:04 AST 2019 module-info.java
     0 Fri Mar 29 23:14:20 AST 2019 p1/
   409 Fri Mar 29 23:14:20 AST 2019 p1/Greeter.class
   138 Fri Mar 29 23:13:20 AST 2019 p1/Greeter.java
					</pre><p>
				</p>
				<p>
					Now, create unnamed client module:
					</p><pre class="programlisting">
package p2;

import p1.Greeter;

public class Client {
    public static void main(String[] args) {
        Greeter.greet();
    }
}
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\LIB1
&#9492;&#9472;&#9472;&#9472;p2
        Client.java
					</pre><p>
					Compile:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -cp greeter.jar lib1/p2/Client.java
					</pre><p>
					Create non-modular executable JAR file:
					</p><pre class="programlisting">
jar --create --file client.jar --main-class p2.Client -C lib1 .
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar -tvf client.jar
     0 Fri Mar 29 23:30:54 AST 2019 META-INF/
    89 Fri Mar 29 23:30:54 AST 2019 META-INF/MANIFEST.MF
     0 Fri Mar 29 23:30:24 AST 2019 p2/
   301 Fri Mar 29 23:30:24 AST 2019 p2/Client.class
   140 Fri Mar 29 22:48:34 AST 2019 p2/Client.java
					</pre><p>
					Run the client:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p greeter.jar --add-modules MOD -jar client.jar
Greeting from Java 9 !
					</pre><p>
					This demonstrated unnamed module access to named module.
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						When you are trying to launch an application from a non-modular JAR so you have to explicitly resolve required 
						modules by <code class="code">--add-modules</code>
					</p>
					<p>
						The required named modules have to be on module graph, e.g. add by <code class="code">--module-path</code> (or by <code class="code">-p</code>) 						
					</p>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Automatic modules</strong></span>
				</p>
				<p>
					Automatic modules are named modules which are automatically created from a non-modular JARs. It happens when the JAR is placed on the <span class="bold"><strong>module path</strong></span> 
					(as dependency) of a modular application via <code class="code">--module-path</code> or <code class="code">-p</code> options.
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						A JAR file that does not have a <code class="code">module-info.class</code> in its top-level directory is a non-modular JAR. 						
					</p>
				</td></tr></table></div>
				<p>
					A non-modular JAR becomes modular (automatic module) JAR when used by a modular application via <code class="code">--module-path</code> option (and becomes part of the unnamed module when 
					used by a modular application via <code class="code">--class-path</code> option).
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Automatic module <code class="code">exports</code> all its packages.
					</p>
					<p>
						Automatic module <code class="code">requires</code> all other modules on the module path. 		
					</p>
				</td></tr></table></div>
				<p>
					Let's create non-modular JAR:
					</p><pre class="programlisting">
package p1;

public class Greeter {
    public static void greet() {
        System.out.println("Greeting from automatic module !");
    }
}
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\LIB2
&#9492;&#9472;&#9472;&#9472;p1
        Greeter.java
					</pre><p>
					Compile:
					</p><pre class="programlisting">
C:\1Z0-817\lib2&gt;javac p1/Greeter.java
					</pre><p>
					Create JAR:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar --create --file greeter-lib.jar -C lib2 .
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						<code class="code">--file greeter-lib.jar</code> and <code class="code">--file=greeter-lib.jar</code> are both valid syntaxes.
					</p>
				</td></tr></table></div>
				<p>
					Get description of the new automatic module:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar --file greeter-lib.jar --describe-module
No module descriptor found. Derived automatic module.

greeter.lib automatic
requires java.base mandated
contains p1
					</pre><p>
				</p>
				<p>
					Create new module application in <code class="code">mod5</code> directory:
					</p><pre class="programlisting">
package p2;

import p1.Greeter;

public class Client {
    public static void main(String[] args) {
        Greeter.greet();
    }
}
					</pre><p>
					As you saw above, the automatic module name will be <code class="code">greeter.lib</code> and client application <code class="code">requires</code> it:
					</p><pre class="programlisting">
module MOD { 
    requires greeter.lib;
}
					</pre><p>
					Compile:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p greeter-lib.jar mod5/module-info.java mod5/p2/Client.java
					</pre><p> 
					</p><pre class="programlisting">
C:\1Z0-817\MOD5
&#9474;   module-info.class
&#9474;   module-info.java
&#9474;
&#9492;&#9472;&#9472;&#9472;p2
        Client.class
        Client.java
					</pre><p>
					Run:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p greeter-lib.jar;mod5 -m MOD/p2.Client
Greeting from automatic module !
					</pre><p>
					Optionally create module JAR and check dependencies:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar --create --file client-mod.jar -C mod5 .
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar --file client-mod.jar --describe-module
MOD jar:file:///C:/1Z0-817/client-mod.jar/!module-info.class
requires greeter.lib
requires java.base mandated
contains p2
					</pre><p>
				</p>
				<p>
					Optionally check dependencies of the modular client:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jdeps --module-path client-mod.jar;greeter-lib.jar -s --module MOD
MOD -&gt; greeter.lib
MOD -&gt; java.base
					</pre><p>				
				</p>
				<p>
					<span class="bold"><strong>Automatic module name derivation</strong></span>
				</p>
				<p>
					If the JAR file has the attribute "<code class="code">Automatic-Module-Name</code>" in its main manifest (<code class="code">META-INF/MANIFEST.MF</code>) then its value is the module 
					name. The module name is otherwise derived from the name of the JAR file.
				</p>
				<p>
					The version, and the module name when the attribute "<code class="code">Automatic-Module-Name</code>" is not present, are derived from the file name of the JAR file as follows:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								The "<code class="code">.jar</code>" suffix is removed.
							</p>
						</li><li class="listitem">
							<p>
								If the name matches the regular expression "<code class="code">-(\\d+(\\.|$))</code>" then the module name will be derived from the subsequence 
								preceding the hyphen of the first occurrence. The subsequence after the hyphen is parsed as a <code class="code">Version</code> and ignored if it 
								cannot be parsed as a <code class="code">Version</code>.
							</p>
						</li><li class="listitem">
							<p>
								All non-alphanumeric characters (<code class="code">[^A-Za-z0-9]</code>) in the module name are replaced with a dot ("."), all repeating dots are 
								replaced with one dot, and all leading and trailing dots are removed.							
							</p>
						</li><li class="listitem">
							<p>
								As an example, a JAR file named "<code class="code">foo-bar.jar</code>" will derive a module name "<code class="code">foo.bar</code>" and no version. A JAR file named 
								"<code class="code">foo-bar-1.2.3-SNAPSHOT.jar</code>" will derive a module name "<code class="code">foo.bar</code>" and "<code class="code">1.2.3-SNAPSHOT</code>" as the version
							</p>
						</li></ul></div><p>
				</p>
				<p>
					The set of packages in the module is derived from the non-directory entries in the JAR file that have names ending in "<code class="code">.class</code>". A candidate 
					package name is derived from the name using the characters up to, but not including, the last forward slash. All remaining forward slashes are replaced 
					with dot ("."). If the resulting string is a legal package name then it is assumed to be a package name. For example, if the JAR file contains 
					the entry "<code class="code">p/q/Foo.class</code>" then the package name derived is "<code class="code">p.q</code>".
				</p>
				<p>
					The contents of entries starting with <code class="code">META-INF/services/</code> are assumed to be service configuration files. If the name of a file (that follows 
					<code class="code">META-INF/services/</code>) is a legal class name then it is assumed to be the fully-qualified class name of a service type. The entries in 
					the file are assumed to be the fully-qualified class names of provider classes.
				</p>
				<p>
					If the JAR file has a <code class="code">Main-Class</code> attribute in its main manifest, its value is a legal class name, and its package is in the set of 
					packages derived for the module, then the value is the module main class.
				</p>
				<p>
					<span class="bold"><strong>Java command line options for modules</strong></span>				
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">--module-path</code> (<code class="code">-p</code>)
							</p>
							<p>
								Specifies the module path. We need to provide one or more directories that will contain modules.  Also can contain JAR files.
								</p><pre class="programlisting">
java -p greeter-lib.jar;mod5 -m MOD/p2.Client
								</pre><p>
							</p>							
						</li><li class="listitem">
							<p>
								<code class="code">--module-source-path</code>
							</p>
							<p>
								Specify where to find input source files for multiple modules.
							</p>
							<p>
								Assume <code class="code">src</code> directory contains several modules directories:
								</p><pre class="programlisting">
C:\1Z0-817\SRC
&#9500;&#9472;&#9472;&#9472;modA
&#9474;       module-info.class
&#9474;
&#9492;&#9472;&#9472;&#9472;modB
        module-info.class
								</pre><p>
								Then you can use:
								</p><pre class="programlisting">
javac --module-source-path src ...
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">--describe-module</code> (<code class="code">-d</code>)
							</p>
							<p>
								Describe the module:
								</p><pre class="programlisting">
java --describe-module java.base

java.base@11.0.2
exports java.io
exports java.lang
...
								</pre><p>
								or describe module contained in JAR:
								</p><pre class="programlisting">
C:\1Z0-817&gt;jar --describe-module --file=client-mod.jar

MOD jar:file:///C:/1Z0-817/client-mod.jar/!module-info.class
requires greeter.lib
requires java.base mandated
contains p2
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">--add-modules</code>
							</p>
							<p>
								Adds the specified modules to the default set of modules.
								</p><pre class="programlisting">
jlink --module-path modA;modB --add-modules MOD --output greeterapp 
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">--list-modules</code>
							</p>
							<p>
								List all observable modules in Java
								</p><pre class="programlisting">
java --list-modules
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">--module &lt;module_name&gt;</code> (<code class="code">-m</code>) for <code class="code">javac</code> compiler command
							</p>
							<p>
								Compile only the specified module, check timestamps
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">--module &lt;module&gt;[/&lt;mainclass&gt;]</code> (<code class="code">-m</code>) for <code class="code">java</code> interpreter command
							</p>
							<p>
								Executes the main class in a module:
								</p><pre class="programlisting">
java -p service.jar;provider.jar;service-client -m modC/app.Client
								</pre><p>
							</p>							
						</li></ul></div><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						<code class="code">--add-exports</code>, <code class="code">--add-opens</code>, <code class="code">--add-modules</code>, 
						<code class="code">--add-reads</code>, and <code class="code">--patch-module</code> are NOT part of the Java 11 exam.
					</p>
				</td></tr></table></div>
			</div>
		</div>
		<div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap2"></a>Chapter&nbsp;2.&nbsp;Services in a Modular Application</h2></div></div></div>
			
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c2s1"></a>2.1.&nbsp;
					  Describe the components of Services including directives
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#SERVICE_LOADER_JAVA_DOC" title="ServiceLoader JavaDoc">[SERVICE_LOADER_JAVA_DOC]</a> ServiceLoader JavaDoc
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					Java since version 6 supported service-provider loading facility via the <code class="code">java.util.ServiceLoader</code> class. 
					Using Service Loader you can have a service provider interface (SPI) simply called Service, and multiple implementations of the SPI simply 
					called Service Providers. These Service Providers in Java 8 and earlier are located in the classpath and loaded at 
					run time. 
				</p>
				<p>
					Since Java 9 you can develop Services and Service Providers as modules. A service module declares one or more interfaces whose 
					implementations will be provided at run time by some provider modules. A provider module declares what implementations of service interfaces it 
					<code class="code">provides</code>.The module that discovers and loads service providers must contain a <code class="code">uses</code> directive in its declaration.
 
				</p>
				<p>
					<span class="bold"><strong>Developing Service module</strong></span> 
				</p>
				<p>
					Let's say we have a service interface <code class="code">p1.GreeterIntf</code>:
					</p><pre class="programlisting">
package p1;

public interface GreeterIntf {
    public abstract void greet();
}
					</pre><p>
					Export the <code class="code">p1</code> package in <code class="code">module-info.java</code>:
					</p><pre class="programlisting">
module modS {
    exports p1;
}
					</pre><p>
					Compile:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac service/module-info.java service/p1/GreeterIntf.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\SERVICE
&#9474;   module-info.class
&#9474;   module-info.java
&#9474;
&#9492;&#9472;&#9472;&#9472;p1
        GreeterIntf.class
        GreeterIntf.java
					</pre><p>
					Package as JAR:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar --create --file service.jar -C service .
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Developing Service Provider module</strong></span>
				</p>
				<p>
					Let's create service interface implementation:
					</p><pre class="programlisting">
package p2;

import p1.GreeterIntf;

public class GreeterImpl implements GreeterIntf {

    @Override
    public void greet() {
        System.out.println("Greeting from GreeterImpl !");
    }    
}
					</pre><p>
				</p>
				<p>
					A service provider will use "<code class="code">provides ... with ...</code>" directive to declare what service interface it intends to use (by using 
					<code class="code">provides</code> keyword) and what implementation of the interface it wants to expose (by using <code class="code">with</code> keyword).
					</p><pre class="programlisting">
module modP {
    requires modS;
    provides p1.GreeterIntf with p2.GreeterImpl;
}
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						We don't have to specify the service implementation in a file under the resource directory <code class="code">META-INF/services</code> as of Java 9.
					</p>
				</td></tr></table></div>
				<p>
					Compile the code:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p service.jar provider/module-info.java provider/p2/GreeterImpl.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\PROVIDER
&#9474;   module-info.class
&#9474;   module-info.java
&#9474;
&#9492;&#9472;&#9472;&#9472;p2
        GreeterImpl.class
        GreeterImpl.java
					</pre><p>
					Create provider JAR:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar --create --file provider.jar -C provider .
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Developing Service client application</strong></span>
				</p>
				<p>
					Create a Client class:
					</p><pre class="programlisting">

package app;

import java.util.ServiceLoader;
import p1.GreeterIntf;

public class Client {
    public static void main(String[] args) {
        ServiceLoader&lt;GreeterIntf&gt; services = ServiceLoader.load(GreeterIntf.class);
        services.findFirst().ifPresent(s -&gt; s.greet());
    }
}


					</pre><p>
				</p>
				<p>
					In order for a service to be used, its providers need to be discovered and loaded. The <code class="code">ServiceLoader</code> class
					does the work of discovering and loading the service providers. The module that discovers and loads service providers must 
					contain a <code class="code">uses &lt;service interface name&gt;</code> directive in its declaration.
				</p>
				<p>
					If a module uses the ServiceLoader&lt;GreeterIntf&gt; class to load the instances
					of service providers for a service interface named <code class="code">p1.GreeterIntf</code>, the module declaration must contain the 
					<code class="code">uses p1.GreeterIntf</code> declaration as follows:
					</p><pre class="programlisting">
module modC {
    requires modS;
    uses p1.GreeterIntf;
}
					</pre><p>
				</p>
				<p>
					Compile the client code:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p service.jar service-client/module-info.java service-client/app/Client.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\SERVICE-CLIENT
&#9474;   module-info.class
&#9474;   module-info.java
&#9474;
&#9492;&#9472;&#9472;&#9472;app
        Client.class
        Client.java
					</pre><p>
				</p>
				<p>
					Run the client code:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p service.jar;provider.jar;service-client -m modC/app.Client

Greeting from GreeterImpl !					
					</pre><p>
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c2s2"></a>2.2.&nbsp;
					Design a service type, load the services using <code class="code">ServiceLoader</code>, check for dependencies 
					of the services including consumer module and provider module
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#SERVICE_LOADER_JAVA_DOC" title="ServiceLoader JavaDoc">[SERVICE_LOADER_JAVA_DOC]</a> ServiceLoader JavaDoc
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Designing services</strong></span>
				</p>
				<p>
					A service is a single type, usually an interface or abstract class. A concrete class can be used, but this 
					is not recommended. The type may have any accessibility. The methods of a service are highly domain-specific, so 
					this API specification cannot give concrete advice about their form or function. However, there are two general guidelines:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							<p>
								A service should declare as many methods as needed to allow service providers to communicate their 
								domain-specific properties and other quality-of-implementation factors. An application which obtains a 
								service loader for the service may then invoke these methods on each instance of a service provider, 
								in order to choose the best provider for the application.
							</p>						
						</li><li class="listitem">
							<p>
								A service should express whether its service providers are intended to be direct implementations of the 
								service or to be an indirection mechanism such as a "proxy" or a "factory". Service providers tend to be 
								indirection mechanisms when domain-specific objects are relatively expensive to instantiate; in this case, 
								the service should be designed so that service providers are abstractions which create the "real" implementation 
								on demand. For example, the <code class="code">CodecFactory</code> service expresses through its name that its service 
								providers are factories for codecs, rather than codecs themselves, because it may be expensive or complicated 
								to produce certain codecs.
							</p>						
						</li></ol></div><p>
				</p>
				<p>
					<span class="bold"><strong>Developing service providers</strong></span>
				</p>
				<p>
					A service provider is a single type, usually a concrete class. An interface or abstract class is permitted because it may declare a 
					<code class="code">static provider()</code> method, discussed later. The type must be <code class="code">public</code> and must not be an inner class.
				</p>
				<p>
					A service provider and its supporting code may be developed in a module, which is then deployed on the application module path 
					or in a modular image. Alternatively, a service provider and its supporting code may be packaged as a JAR file and deployed on 
					the application class path. The advantage of developing a service provider in a module is that the provider can be fully 
					encapsulated to hide all details of its implementation.
				</p>
				<p>
					An application that obtains a service loader for a given service is indifferent to whether providers of the service are 
					deployed in modules or packaged as JAR files. The application instantiates service providers via the service loader's 
					iterator, or via <code class="code">Provider</code> objects in the service loader's stream, without knowledge of the service providers' 
					locations.
				</p>
				<p>
					We can update <code class="code">app.Client</code> class (from previous section) as follows:
					</p><pre class="programlisting">
package app;

import java.util.ServiceLoader;
import java.util.ServiceLoader.Provider;
import p1.GreeterIntf;

public class Client {
    public static void main(String[] args) {
        ServiceLoader.load(GreeterIntf.class)
                .stream()                
                .filter((Provider p) -&gt; p.type().getSimpleName().startsWith("Greeter"))
                .map(Provider::get)
                .findFirst()
                .ifPresent(s -&gt; s.greet());
    }
}
					</pre><p>
					An instance of the <code class="code">ServiceLoader.Provider</code> interface represents a service provider. Its <code class="code">type()</code> method
					returns the <code class="code">Class</code> object of the service implementation. The <code class="code">get()</code> method instantiates and returns the
					service provider. When you use the <code class="code">stream()</code> method, each element in the stream is of the <code class="code">ServiceLoader.Provider</code> 
					type. You can filter the stream based on the class name or type of the provider, which will not instantiate the provider. You can 
					use the <code class="code">type()</code> method in your filters. When you find the desired provider, call the <code class="code">get()</code> method to 
					instantiate the provider. This way, you instantiate a provider when you know you need it, not when you are iterating through 
					all providers.
				</p>
				<p>
					<span class="bold"><strong>Deploying service providers as modules</strong></span>
				</p>
				<p>
					A service provider that is developed in a module must be specified in a <code class="code">provides</code> directive in the module declaration. The 
					<code class="code">provides</code> directive specifies both the service and the service provider; this helps to locate the provider when another 
					module, with a <code class="code">uses</code> directive for the service, obtains a service loader for the service. It is strongly recommended that 
					the module does not export the package containing the service provider. There is no support for a module specifying, in a <code class="code">provides</code> 
					directive, a service provider in another module.
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						This a bad example of module definition:
						</p><pre class="programlisting">
module modP {
    requires modS;
    provides p1.GreeterIntf with p2.GreeterImpl;
    exports p2; // BAD !!! We should not export implementation of the service 
}
						</pre><p>
					</p>
				</td></tr></table></div>
				<p>
					A service provider that is developed in a module has no control over when it is instantiated, since that occurs at the behest of the 
					application, but it does have control over how it is instantiated:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								If the service provider declares a <code class="code">provider()</code> method, then the service loader invokes that method to obtain an 
								instance of the service provider. A provider method is a <code class="code">public static</code> method named "provider" with no formal 
								parameters and a return type that is assignable to the service's interface or class.
							</p>
							<p>
								In this case, the service provider itself NEED NOT be assignable to the service's interface or class.
							</p>
						</li><li class="listitem">
							<p>
								If the service provider does not declare a <code class="code">provider()</code> method, then the service provider is instantiated directly, via 
								its provider constructor. A provider constructor is a public constructor with no formal parameters.
							</p>
							<p>
								In this case, the service provider MUST be assignable to the service's interface or class.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					A service provider that is deployed as an automatic module on the application module path must have a provider constructor. 
					There is no support for a <code class="code">provider()</code> method in this case.
				</p>
				<p>
					Let's create new service provider:
					</p><pre class="programlisting">
package p3;

import p1.GreeterIntf;

public class MyProvider {
    public static GreeterIntf provider() {
        return new GreeterIntf() {
            @Override
            public void greet() {
                System.out.println("Greeting from MyProvider !");
            }
        };
    }
}

					</pre><p>
					</p><pre class="programlisting">
module modPP {
    requires modS;
    provides p1.GreeterIntf with p3.MyProvider;
}
					</pre><p>
					if you update the client class filter as follows:
					</p><pre class="programlisting">
...					
.filter((Provider p) -&gt; p.type().getSimpleName().startsWith("GreeterIntf"))
...
					</pre><p>
					The output will be:
					</p><pre class="programlisting">
Greeting from MyProvider !
					</pre><p>															
				</p>
				<p>
					Two points here: (a) the <code class="code">provider()</code> method was used to instantiate service implementation, and (b) the service provider type (<code class="code">MyProvider</code>)
					is not assignable to service interface (<code class="code">GreeterIntf</code>).
				</p>
				<p>
					<span class="bold"><strong>Service module dependency</strong></span>
				</p>
				<p>
					Run the command:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar --describe-module --file=service.jar

modS jar:file:///C:/1Z0-817/service.jar/!module-info.class
exports p1
requires java.base mandated					
					</pre><p>
					As you can see is depends on <code class="code">java.base</code> module in our case (it always implicitly added).
				</p>
				<p>
					<span class="bold"><strong>Provider module dependency</strong></span>
				</p>
				<p>
					Run the command:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar --describe-module --file=provider.jar

modP jar:file:///C:/1Z0-817/provider.jar/!module-info.class
requires java.base mandated
requires modS
provides p1.GreeterIntf with p2.GreeterImpl
contains p2
					</pre><p>
					As you can see is depends on <code class="code">java.base</code> and <code class="code">modS</code> service module.
				</p>				
				<p>
					<span class="bold"><strong>Client module dependency</strong></span>
				</p>
				<p>
					Run the command:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar --create --file service-client.jar -C service-client .

C:\1Z0-817&gt;jar --describe-module --file=service-client.jar

modC jar:file:///C:/1Z0-817/service-client.jar/!module-info.class
requires java.base mandated
requires modS
uses p1.GreeterIntf
contains app
					</pre><p>
					As you can see is depends on <code class="code">java.base</code> and <code class="code">modS</code> service module. 
					The client module (<code class="code">modC</code>) does not depend on provider module (<code class="code">modP</code>) 
					and not aware of it at compile time.
				</p>				
			</div>
		</div>
		<div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap3"></a>Chapter&nbsp;3.&nbsp;Java Interfaces</h2></div></div></div>
			
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c3s1"></a>3.1.&nbsp;
					 Create and use methods in interfaces
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 3.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					Java 9 introduced <code class="code">private</code> methods and <code class="code">private static</code> method in interfaces. In Java 9 (and hence Java 11 too) an interface can have seven 
					different things:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							<p>
								constant variables (since Java 1.0)
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">abstract</code> methods (since Java 1.0)
							</p>
						</li><li class="listitem">
							<p>
								nested types (since Java 2.0)
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">default</code> methods (since Java 8.0)
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">static</code> methods (since Java 8.0)
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">private</code> methods (since Java 9.0)
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">private static</code> methods (since Java 9.0)
							</p>
						</li></ol></div><p>
					The <code class="code">private</code> methods added in Java 9.0 will improve code re-usability inside interfaces and will provide choice to expose only  
					intended method implementations to users. The <code class="code">private</code> methods are only accessible within an interface only and cannot be accessed 
					or inherited from the interface to another interface or class.
				</p>
				<p>
					<span class="bold"><strong>Constant variables</strong></span>
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    String GREETING = "Greeting from Interface";
}
					</pre><p>					
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
        System.out.print(GreeterIntf.GREETING);
    }
}
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Every field declaration in the body of an interface is implicitly <code class="code">public</code>, <code class="code">static</code>, and <code class="code">final</code>. It is permitted 
						to redundantly specify any or all of these modifiers for such fields.
					</p>
				</td></tr></table></div>
				<p>
					Interface variables are <code class="code">static</code> because Java interfaces cannot be instantiated in their own right; the value of the variable must be 
					assigned in a static context in which no instance exists. The <code class="code">final</code> modifier ensures the value assigned to the interface variable is a 
					true constant that cannot be re-assigned by program code.
				</p>
				<p>
					<span class="bold"><strong><code class="code">abstract</code> methods</strong></span>
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    void greet();
}

					</pre><p>
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
        GreeterIntf g = () -&gt; {
            System.out.print("Greeting from Interface");
        };
        g.greet();
    }
}					
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Every method declaration in an interface with body represented by a semicolon is implicitly <code class="code">public</code> and <code class="code">abstract</code>.
					</p>					
				</td></tr></table></div>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						It is a compile-time error if a method declaration that contains the keyword <code class="code">abstract</code> also contains any one of the keywords: 
						<code class="code">private</code>, <code class="code">static</code>, <code class="code">final</code>, <code class="code">native</code>, <code class="code">strictfp</code>, or <code class="code">synchronized</code>.
					</p>
					<p>
						It would be impossible for a class to implement a <code class="code">private abstract</code> method, because <code class="code">private</code> methods are not 
						inherited by subclasses; therefore such a method could never be used.
					</p>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>nested types</strong></span>
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    class GreeterException extends RuntimeException {
        public GreeterException() { super(); };
    }    
    interface Helper {
        String GREETING = "Greeting from Interface";
    }
}
					</pre><p>
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
        try {
            System.out.print(GreeterIntf.Helper.GREETING);
        } catch (GreeterIntf.GreeterException e) {
            // never ignore exception handling !
        }
    }
}
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Interfaces may contain member type declarations. A member type declaration in an interface is implicitly 
						<code class="code">static</code> and <code class="code">public</code>. It is permitted to redundantly specify either or both of 
						these modifiers.
					</p>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong><code class="code">default</code> methods</strong></span>
				</p>
				<p>
					Before Java 8.0, interfaces could have only <code class="code">abstract</code> methods. The implementation of these methods 
					has to be provided in a separate class. So, if a new method is to be added in an interface, then its implementation code 
					has to be provided in all classes implementing this interface. To overcome this issue, Java 8.0 has introduced the concept 
					of <code class="code">default</code> methods which allow the interfaces to have methods with implementation without affecting the 
					classes that implement the interface.
				</p>
				<p>
					Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary backward compatibility with 
					code written for older versions of those interfaces.
				</p>
				<p>
					Unlike <code class="code">abstract</code> interface methods, they are declared with the <code class="code">default</code> keyword at the beginning 
					of the method signature, and they provide an implementation.
				</p>
				<p>
					 An implementing class can override the default implementation provided by the interface.
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    default void greet() {
        System.out.print("Greeting from Interface");    
    }
}
					</pre><p>
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
      GreeterIntf g = new GreeterIntf() { // we do not override default method
      };
      g.greet();
    }
}
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						The <code class="code">default</code> methods are implicitly <code class="code">public</code> &#8212; there's no need to specify the <code class="code">public</code> modifier.
					</p>					
				</td></tr></table></div>
				<p>
					If a class implements two interfaces, both of which have a <code class="code">default</code> method with the same name and parameter types, then you must resolve the conflict.
					</p><pre class="programlisting">
public interface GreeterIntfA {
    default void greet() {
        System.out.println("Greeting from GreeterIntfA");
    }
}
					</pre><p>
					</p><pre class="programlisting">
public interface GreeterIntfB {
    default void greet() {
        System.out.println("Greeting from GreeterIntfB");
    }
}
					</pre><p>
					</p><pre class="programlisting">
public class MyGreeter implements GreeterIntfA, GreeterIntfB {
	// WILL NOT COMPILE !!!    
}

					</pre><p>
					The <code class="code">MyGreeter</code> class inherits two <code class="code">greet()</code> methods provided by the <code class="code">GreeterIntfA</code> and 
					<code class="code">GreeterIntfB</code> interfaces. There is no way for the Java compiler to choose one over the other. The compiler 
					reports an error. You should provide a <code class="code">greet()</code> method in the <code class="code">MyGreeter</code> class and either implement your own 
					greeting, or delegate to one of the conflicting methods, like this:
					</p><pre class="programlisting">
public class MyGreeter implements GreeterIntfA, GreeterIntfB {
    @Override
    public void greet() {
        GreeterIntfA.super.greet();
    }
}
					</pre><p>
					The <code class="code">super</code> keyword lets you call a supertype method. In this case, we need to specify which supertype we want.
				</p>
				<p>
					If a class extends a superclass and implements an interface with <code class="code">default</code> method, inheriting the same method from both,  then 
					only the superclass method matters, and <code class="code">default</code> method from the interface is ignored.  
				</p>
				<p>
					<span class="bold"><strong><code class="code">static</code> methods</strong></span>
				</p>
				<p>
					In Java 8.0 and later you can define <code class="code">static</code> methods in interfaces. Like <code class="code">static</code> methods in classes, you 
					specify that a method definition in an interface is a <code class="code">static</code> method with the <code class="code">static</code> keyword at the 
					beginning of the method signature.
				</p>
				<p>
					A <code class="code">static</code> method can be invoked from other <code class="code">static</code> or from <code class="code">default</code> method.
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    static void greet() {
        System.out.print("Greeting from Interface");    
    }
}
					</pre><p>				
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
      GreeterIntf.greet();
    }
}
					</pre><p>				
				</p>				
				<p>
					A <code class="code">static</code> method cannot be overridden or changed in the implementation class. 
				</p>
				<p>
					A <code class="code">static</code> method cannot be shadowed too, as it part of the interface, not part of implementing the class.
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						The <code class="code">static</code> methods are implicitly <code class="code">public</code> &#8212; there's no need to specify the <code class="code">public</code> modifier.
					</p>					
				</td></tr></table></div>
				<p>
					<span class="bold"><strong><code class="code">private</code> methods</strong></span>
				</p>
				<p>
					As of Java 9.0, methods in an interface can be <code class="code">private</code>. 
				</p>
				<p>
					These <code class="code">private</code> methods will improve code reusability inside interfaces and encapsulation. For example, if two <code class="code">default</code> methods 
					needed to share code, a <code class="code">private</code> method in the interface would allow them to do so, but without exposing that <code class="code">private</code> method 
					to interface implementing class.
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    default void greet() {
        System.out.print(getGreeting());    
    }
    
    private String getGreeting() {
        return "Greeting from Interface";
    }
}
					</pre><p>
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
      GreeterIntf g = new GreeterIntf() {        
      };
      g.greet();
    }
}
					</pre><p>
				</p>
				<p>
					Rules for <code class="code">private</code> methods in interfaces:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							<p>
								We must use <code class="code">private</code> modifier to define them.
							</p>
						</li><li class="listitem">
							<p>
								No <code class="code">private</code> and <code class="code">abstract</code> modifiers together, it will give compiler error.
								The <code class="code">private</code> method means fully implemented method because subclasses cannot inherit and override this method.
								The <code class="code">abstract</code> method means no-implementation method -- subclass must inherit and override this method.
							</p>
						</li><li class="listitem">
							<p>
								No <code class="code">private</code> and <code class="code">default</code> modifiers together, it will give compiler error. The <code class="code">default</code> methods in 
								an interface are always <code class="code">public</code>.
							</p>
						</li><li class="listitem">
							<p>
								The <code class="code">private</code> methods must contain body.
							</p>
						</li></ol></div><p> 
				</p>
				<p>
					 As <code class="code">private</code> methods can only be used in the methods of the interface itself, their use is limited to being helper methods for the other methods 
					 of the interface.
				</p>
				<p>
					<span class="bold"><strong><code class="code">private static</code> methods</strong></span>
				</p>
				<p>
					</p><pre class="programlisting">
public interface GreeterIntf {
    static void greet() {
        System.out.print(GreeterIntf.getGreeting());    
    }
    
    private static String getGreeting() {
        return "Greeting from Interface";
    }
}					</pre><p>
					</p><pre class="programlisting">
public class Client {
    public static void main(String[] args) {
      GreeterIntf.greet();
    }
}					</pre><p>
				</p>
				<p>
					 The <code class="code">private static</code> methods are useful when you have multiple <code class="code">public static</code> methods that share some 
					 common code. So, you can only extract that shared code into a <code class="code">private static</code> method, but not into an instance method 
					 (because <code class="code">static</code> method cannot access instance method without creating an instance of type).
				</p>
				<p>
					A <code class="code">private static</code> methods can be called from instance (i.e. <code class="code">default</code> or <code class="code">private</code> non-static) 
					method or <code class="code">static</code> method inside the interface.
				</p>
				<p>
					A <code class="code">private</code> non-static method is not allowed to be called from <code class="code">static</code> or <code class="code">private static</code> method within the 
					interface (unless an instance of the interface is passed in). 
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c3s2"></a>3.2.&nbsp;
					Define and write functional interfaces
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>								
								<a class="xref" href="#JAVA_UTIL_FUNCTION" title="Java SE 11 Java Doc - Package java.util.function">[JAVA_UTIL_FUNCTION]</a> Java SE 11 Java Doc - Package java.util.function 
							</p>
							<p>								
								<a class="xref" href="#JLS_11" title="The Java&reg; Language Specification. Java SE 11 Edition">[JLS_11]</a> 9.8. Functional Interfaces 
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Functional interfaces</strong></span> provide target types for lambda expressions and
					method references. Each functional interface has a <span class="bold"><strong>single abstract method</strong></span> (SAM),
					called the <span class="bold"><strong>functional method</strong></span> for that functional interface, to which
					the lambda expression's parameter and return types are matched or adapted.
				</p>
				<p>
					Functional interfaces can provide a target type in multiple contexts, such as assignment context, method invocation, or cast context:
					</p><pre class="programlisting">
// Assignment context
Predicate&lt;String&gt; p = String::isEmpty;					
					</pre><p>
					</p><pre class="programlisting">
// Method invocation context
stream.filter(e -&gt; e.getSize() &gt; 10)...
					</pre><p>
					</p><pre class="programlisting">
// Cast context
stream.map((ToIntFunction) e -&gt; e.getSize())...
					</pre><p>
				</p>
				<p>
					All the existing single method interfaces like <code class="code">Runnable</code>, <code class="code">Callable</code>, 
					<code class="code">Comparator</code>, and <code class="code">ActionListener</code> as of Java 8.0 (and later) are functional interfaces and
					lambdas can be used anywhere a single abstract method interface is used.
				</p>
				<p>
					<span class="bold"><strong>@FunctionalInterface annotation</strong></span>
				</p>
				<p>
					Java 8.0 have introduced a new annotation <code class="code">@FunctionalInterface</code> to mark an interface as
					such. It's basically to communicate intent but also allows the compiler to do some additional checks.
				</p>
				<div class="warning" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Warning]" src="images.admon/warning.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						The <code class="code">@FunctionalInterface</code> annotation is optional, it is a "hint" for Java compiler.
					</p>
				</td></tr></table></div>
				<p>
					For example, this interface compiles successfully:
					</p><pre class="programlisting">
public interface MyInterface {
}
					</pre><p>
				</p>
				<p>
					But when you indicate that it should be a <span class="bold"><strong>functional interface</strong></span>:
					</p><pre class="programlisting">
// Compilation fails !
@FunctionalInterface
public interface MyInterface {
}
					</pre><p>
					The compiler will raise an error as there is no abstract method. It says that "<code class="code">MyInterface</code> is
					not a functional interface" as "no abstract method was found". It will also
					error if we try and add a second method:
					</p><pre class="programlisting">
// Compilation fails !
@FunctionalInterface
public interface MyInterface {
    void doIt();
    void doItNow();
}
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Default methods in interfaces</strong></span>
				</p>
				<p>
					Since Java 8.0 interfaces support <code class="code">default</code> and <code class="code">public static</code> methods. A default method is an instance method
					defined in an interface whose method header begins with the <code class="code">default</code> keyword; it
					also provides a <span class="bold"><strong>code body</strong></span>. Every class that implements the interface
					inherits the interface's default methods and can override them.
				</p>
				<p>
					Since functional interface requires a single <span class="bold"><strong>abstract</strong></span> method, this code will NOT
					compile, as it is invalid functional interface:
					</p><pre class="programlisting">
// Compilation fails !
@FunctionalInterface
public interface MyDefInterface {
    default void doIt() { /* cool implementation */ }
}
					</pre><p>
					But this functional interface will compile successfully:
					</p><pre class="programlisting">
@FunctionalInterface
public interface MyDefInterface {
    default void doIt() { /* cool implementation */ }
    void doItNow(); // Single Abstract Method (SAM)
}
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Static methods in interfaces</strong></span>
				</p>
				<p>
					A static method is a method that's associated with the class in which it's defined, rather than with any
					object created from that class. Every instance of the class shares the static methods of the class. Java
					since release 8.0 also lets <code class="code">public static</code> methods be defined in interfaces where they can 
					assist <code class="code">default</code> methods.
				</p>
				<p>
					Like static methods in classes, you specify that a method definition in an interface is a
					static method with the <code class="code">static</code> keyword at the beginning of the method signature. All method
					declarations in an interface, including static methods, are implicitly <code class="code">public</code>, so you can omit the
					<code class="code">public</code> modifier.
				</p>
				<div class="warning" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Warning]" src="images.admon/warning.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
 						Since Java 9.0 onwards you can <span class="emphasis"><em>explicitly</em></span> provide 
 						<code class="code">private</code> modifier for <code class="code">static</code> methods in interfaces.
					</p>
				</td></tr></table></div>
				<p>
					When you implement an interface that contains a static method, the static method is still part of the
					interface and not part of the implementing class. For this reason, you cannot prefix the method with the
					class name. Instead, you must prefix the method with the interface name.
				</p>
				<p>
					Since functional interface requires a single <span class="bold"><strong>abstract</strong></span> method, this code will NOT
					compile, as it is invalid functional interface:
					</p><pre class="programlisting">
// Compilation fails !
@FunctionalInterface
public interface MyStatInterface {
    static void doIt() { /* cool implementation */ }
}
					</pre><p>
					But this functional interface will compile successfully:
					</p><pre class="programlisting">
@FunctionalInterface
public interface MyStatInterface {
    static void doIt() { /* cool implementation */ }
    void doItNow();
}
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Public methods of java.lang.Object in functional interfaces</strong></span>
				</p>
				<p>
					If an interface declares an abstract method overriding one of the <code class="code">public</code> methods of
					<code class="code">java.lang.Object</code>, that also DOES NOT count toward the interface's <code class="code">abstract</code>
					method count since any implementation of the interface will have an implementation from
					<code class="code">java.lang.Object</code> or elsewhere.
				</p>
				<p>
					For example, <code class="code">java.util.Comparator</code> is a functional interface even though it declared two
					<code class="code">abstract</code> methods:
					</p><pre class="programlisting">

package java.util;

@FunctionalInterface
public interface Comparator&lt;T&gt; {

    int compare(T o1, T o2); // This is SAM

    boolean equals(Object obj); // ignored as it's a public method from java.lang.Object

    ...
}

					</pre><p>
					The reason is because one of these abstract methods - <code class="code">equals()</code> -- has signature identical to
					<code class="code">public</code> method in <code class="code">java.lang.Object</code> class:
					</p><pre class="programlisting">
public class Object {
    ...
    public boolean equals(Object obj) {
        return (this == obj);
    }
    ...
}
					
					</pre><p>
				</p>
				<p>
					This is NOT a funtional interface:
					</p><pre class="programlisting">
// Compilation fails !
@FunctionalInterface
interface MyInterface {
    int doIt(); 
    Object clone(); // not ignored, as it's not a public (but protected) method from java.lang.Object
}
					</pre><p>
					Although only <code class="code">doIt()</code> is an abstract method which is not part of the <code class="code">java.lang.Object</code>, 
					the interface is not functional, as <code class="code">clone()</code> method is not <code class="code">public</code> in the <code class="code">Object</code> class:
					</p><pre class="programlisting">
public class Object {
    ...
    @HotSpotIntrinsicCandidate
    protected native Object clone() throws CloneNotSupportedException;
    ...
}
					</pre><p>
				</p>
			</div>
		</div>
		<div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap4"></a>Chapter&nbsp;4.&nbsp;Lambda Operations on Streams</h2></div></div></div>
			
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c4s1"></a>4.1.&nbsp;
					 Extract stream data using <code class="code">map</code>, <code class="code">peek</code>, and <code class="code">flatMap</code> methods
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 8. Streams.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					Stream is a sequence of elements from a source supporting sequential and parallel aggregate operations.
					The <span class="emphasis"><em>source</em></span> here refers to a <code class="code">Collection</code> (e.g. <code class="code">java.util.List</code>,
					<code class="code">java.util.Set</code>)	or an array	which provides data	to a <code class="code">Stream</code>. The <code class="code">Stream</code>
					keeps the order of the data as it is in the source.
				</p>
				<p>
					</p><pre class="programlisting">

List&lt;String&gt; list = Arrays.asList("Java", "is", "not", "great");
list.stream()
    .filter(s -&gt; !s.startsWith("n"))
    .map(String::toUpperCase)
    .forEach(s -&gt; System.out.print(s + " "));
}

					</pre><p>
					output:
					</p><pre class="programlisting">
JAVA IS GREAT
					</pre><p>
				</p>
				<p>
					A <code class="code">Collection</code> (source) is an in-memory data structure to hold values and before we start using
					<code class="code">Collection</code>, all the values should have been populated. Whereas a <code class="code">Stream</code> is a data
					structure that is computed on-demand.
				</p>
				<p>
					<code class="code">Stream</code> does not store data, it operates on the source data structure (<code class="code">Collection</code> or array)
					and produce pipelined data that we can use and perform specific operations. For example, we can create a <code class="code">Stream</code>
					from a <code class="code">java.util.List</code> and filter it based on a condition as shown above.
				</p>
				<p>
					<span class="bold"><strong>Intermediate Operations</strong></span>
				</p>
				<p>
					Stream API operations that returns a new <code class="code">java.util.stream.Stream</code> are called
					<span class="bold"><strong>intermediate operations</strong></span>. Most of the times, these operations are lazy in
					nature, computation on the source data is only performed when the terminal operation is initiated, and
					source elements are consumed only as needed. Intermediate operations are never the final result producing
					operations. Commonly used intermediate operations are <code class="code">filter(...)</code> and <code class="code">map(...)</code>.
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Stream.filter(...)</code></strong></span>
							</p>
							<p>
								You can filter a stream using the <code class="code">Stream.filter(...)</code> method:
								</p><pre class="programlisting">

Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);

								</pre><p>
								 Here is a stream filtering example:
								</p><pre class="programlisting">
stream.filter(s -&gt; !s.startsWith("n"));
								</pre><p>
								The <code class="code">filter(...)</code> method takes a <code class="code">Predicate</code> functional interface as parameter.
								The <code class="code">Predicate</code> interface takes a single parameter and returns a <code class="code">boolean</code>
								primitive. If you look at the lambda expression above, you can see that it takes a single
								parameter <code class="code">s</code> and returns a <code class="code">boolean</code> -- the result of the
								<code class="code">!s.startsWith("n")</code> method call.
							</p>
							<p>
								When you call the <code class="code">filter(...)</code> method on a <code class="code">Stream</code>, the filter
								passed as parameter to the <code class="code">filter(...)</code> method is stored internally. No filtering takes place
								yet (lazy processing).
							</p>
							<p>
								The parameter passed to the <code class="code">filter(...)</code> function determines what items in the stream
								should be processed, and which that should be excluded from the processing. If the
								<code class="code">Predicate.test(T t)</code> method of the parameter passed to
								<code class="code">filter(...)</code> returns <code class="code">true</code> for an item, that means it should
								be processed. If <code class="code">false</code> is returned, the item is not processed.
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Stream.map(...)</code></strong></span>
							</p>
							<p>
								 It is possible to map the items in a collection to other objects using
								 <code class="code">Stream.map(...)</code> method:
								 </p><pre class="programlisting">

&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);

								 </pre><p>
								 In other words, for each item in the collection you create a new object based on that item. Here
								 is a simple Java stream mapping example:
								 </p><pre class="programlisting">
stream.map(s -&gt; s.toUpperCase());
								 </pre><p>
								This example maps all strings in the items collection to their uppercase equivalents.
							</p>
							<p>
								NOTE: this example does not actually perform the mapping (all intermediate operations are lazy).
								It only configures the stream for mapping. Once one of the stream processing methods are invoked,
								the mapping will be performed.
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Stream.distinct()</code></strong></span>
							</p>
							<p>
								The <code class="code">Stream.distinct()</code> method in stream API returns stream with distinct
								elements. Whether or not element is distinct is decided by <code class="code">equals()</code> method of
								<code class="code">Object</code> class.
							</p>
							<p>
								</p><pre class="programlisting">

Stream&lt;T&gt; distinct();

								</pre><p>
								Here is a simple example:
								</p><pre class="programlisting">

List&lt;String&gt; list = Arrays.asList("aA","AA","Aa", "Aa", "AA");
long l = list.stream().distinct().count();
System.out.println("Number of distinct elements : " + l);

								</pre><p>
								Output:
								</p><pre class="programlisting">
Number of distinct elements : 3
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Stream.peek(...)</code></strong></span>
							</p>
							<p>
								 The <code class="code">Stream.peek(...)</code> returns <code class="code">Stream</code> itself after applying the action passed as
								 <code class="code">Consumer</code> object.
							</p>
							<p>
								</p><pre class="programlisting">

Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)

								</pre><p>
								The <code class="code">Stream.peek(...)</code> is extremely useful during debugging. It allows you to peek into the stream
								before an action is encountered. Here is a simple example:
								</p><pre class="programlisting">

Stream&lt;String&gt; words = Stream.of("lower", "case", "text");
List&lt;String&gt; list = words
    .peek(s -&gt; System.out.println(s))
    .map(s -&gt; s.toUpperCase())
    .collect(Collectors.toList());
System.out.println(list);

								</pre><p>
								Output:
								</p><pre class="programlisting">
lower
case
text
[LOWER, CASE, TEXT]
								</pre><p>
							</p>
						</li></ul></div><p>
				</p>
				<p>
					<span class="bold"><strong>Terminal Operations</strong></span>
				</p>
				<p>
					Stream API operations that returns a result or produce a side effect. Once the terminal method is called
					on a stream, it consumes the stream and after that we can not use stream. Terminal operations are eager
					in nature i.e. they process all the elements (unless it's a short-circuiting terminal operation) in the 
					stream before returning the result. Commonly used terminal
					methods are <code class="code">forEach</code>, <code class="code">toArray</code>, <code class="code">min</code>, <code class="code">max</code>,
					<code class="code">findFirst</code>, <code class="code">anyMatch</code>, <code class="code">allMatch</code>, etc. You can identify terminal
					methods from the return type, <span class="bold"><strong>they will never return a <code class="code">Stream</code></strong></span>.
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Stream.collect(...)</code></strong></span>
							</p>
							<p>
								<code class="code">Stream.collect(...)</code> is a terminal operation to transform the elements of
								the stream into a different kind of result, e.g. a <code class="code">java.util.List</code>, <code class="code">java.util.Set</code>
								or <code class="code">java.util.Map</code>:
								</p><pre class="programlisting">

&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);

								</pre><p>
							</p>
							<p>
								<code class="code">Stream.collect(...)</code> accepts a <code class="code">Collector</code> interface which consists
								of several operations including: <code class="code">supplier()</code>, <code class="code">accumulator()</code>, a
								<code class="code">combiner()</code>, <code class="code">finisher()</code>:
								</p><pre class="programlisting">

public interface Collector&lt;T, A, R&gt; {
    Supplier&lt;A&gt; supplier();

    BiConsumer&lt;A, T&gt; accumulator();

    BinaryOperator&lt;A&gt; combiner();

    Function&lt;A, R&gt; finisher();

    ...

}

								</pre><p>
								Java 11 supports various built-in
								collectors via the <code class="code">java.util.stream.Collectors</code> <code class="code">final</code> class. So for the most common operations you
								do not have to implement a <code class="code">Collector</code> yourself:
								</p><pre class="programlisting">

List&lt;String&gt; list = Arrays.asList("Java", "is", "not", "great");
List&lt;String&gt; filtered = list.stream()
    .filter(item -&gt; item.startsWith("J"))
    .collect(Collectors.toList());
System.out.print(filtered.get(0));

								</pre><p>
								This example creates a stream, adds a filter, and collects all object accepted by the filter in a
								<code class="code">java.util.List</code>. The filter only accepts items (strings) which start with the
								character <code class="code">J</code>. The resulting <code class="code">java.util.List</code> thus contains all strings from the
								original list which starts with the character <code class="code">J</code>. Output is:
								</p><pre class="programlisting">
Java
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Stream.min(...) / Stream.max(...)</code></strong></span>
							</p>
							<p>
								The <code class="code">Stream.min(...)</code> and <code class="code">Stream.max(...)</code> methods are stream processing
								terminal methods. Once these are called, the stream will be iterated, filtering and mapping
								applied, and the minimum or maximum value in the stream will be returned:
								</p><pre class="programlisting">

Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator);

Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);

								</pre><p>
							</p>
							<p>
								The <code class="code">Stream.min(...)</code> and <code class="code">Stream.max(...)</code> methods return an
								<code class="code">Optional</code> instance which has a <code class="code">get()</code> method, which you use to
								obtain the value. In case the <code class="code">Optional</code> has no value the <code class="code">get()</code> method will
								throw <code class="code">NoSuchElementException</code>.
							</p>
							<p>
								The <code class="code">Stream.min(...)</code> and <code class="code">Stream.max(...)</code> methods take a <code class="code">java.util.Comparator</code>
								as parameter. The <code class="code">Comparator.comparing(...)</code> method creates a
								<code class="code">Comparator</code> based on the lambda expression passed to it. In fact, the
								<code class="code">comparing(...)</code> method takes a <code class="code">Function</code> which is a functional interface
								suited for lambda expressions. It takes one parameter and returns a value:
								</p><pre class="programlisting">

Comparator&lt;Person&gt; byLastName = Comparator.comparing(Person::getLastName);

								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Stream.findAny()</code></strong></span>
							</p>
							<p>
								The <code class="code">Stream.findAny()</code> finds any element in the stream, which may be cheaper than
								<code class="code">findFirst()</code> for some streams. This is a <span class="bold"><strong>short circuit terminal operation</strong></span>.
								A short circuit terminal operation potentially allows processing of a stream to stop early without
								examining all the elements.
								</p><pre class="programlisting">

Optional&lt;T&gt; findAny();

								</pre><p>
								Here is an example:
								</p><pre class="programlisting">

List&lt;String&gt; list = Arrays.asList("Java", "is", "not", "great");
Optional&lt;String&gt; result = list.stream()
    .filter(item -&gt; item.contains("t"))
    .findAny();
System.out.print(result.get());

								</pre><p>
								This example processes elements from collection one by one and gets the first element that contains
								character <code class="code">t</code>, and then passes to <code class="code">findAny</code> method. The <code class="code">findAny</code>
								method immediately stops pipeline execution, so no further elements will be processed. The possible 
								output is:
								</p><pre class="programlisting">
not
								</pre><p>
								</p><div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
									<p>
										It will <span class="emphasis"><em>most likely</em></span> return '<code class="code">not</code>' but there is no 
										guarantee for this. Printing '<code class="code">great</code>' also a possible option.
									</p>
								</td></tr></table></div><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Stream.findFirst()</code></strong></span>
							</p>
							<p>
								The method <code class="code">findFirst()</code> provides the first element from the stream. The return value
								is an <code class="code">Optional</code>, in case of an empty stream an empty optional.
								</p><pre class="programlisting">

Optional&lt;T&gt; findFirst();

								</pre><p>
								It will return first element from stream and then will not process any further elements, as it is
								a <span class="bold"><strong>short circuit terminal operation</strong></span>.
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Stream.count()</code></strong></span>
							</p>
							<p>
								The <code class="code">Stream.count()</code> method simply returns the number of elements in the
								stream after filtering has been applied.
								</p><pre class="programlisting">
long count();
								</pre><p>
								Here is an example:
								</p><pre class="programlisting">

List&lt;String&gt; list = Arrays.asList("Java", "is", "not", "great");
long l = list.stream()
    .filter(item -&gt; item.startsWith("J"))
    .count();
System.out.print(l);

								</pre><p>
								This example iterates the stream and keeps all elements that start with the character <code class="code">J</code>,
								and then counts these elements. The <code class="code">count()</code> method returns a <code class="code">long</code> which is
								the count of elements in the stream after filetering it:
								</p><pre class="programlisting">
1
								</pre><p>
							</p>
						</li></ul></div><p>
				</p>
				<p>
					<span class="bold"><strong>Stream Pipelines</strong></span>
				</p>
				<p>
					To perform a computation, stream operations are composed into a <span class="bold"><strong>stream pipeline</strong></span>.
					A stream pipeline consists of:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								a source (which might be an array, a <code class="code">Collection</code>, a generator function, an I/O channel, etc.)
							</p>
						</li><li class="listitem">
							<p>
								zero or more intermediate operations (which transform a <code class="code">Stream</code> into another
								<code class="code">Stream</code>, such as <code class="code">filter(Predicate p)</code>)
							</p>
						</li><li class="listitem">
							<p>
								a terminal operation (which produces a result or side-effect, such as <code class="code">count()</code>
								or <code class="code">forEach(Consumer c)</code>)
							</p>
						</li></ul></div><p>
					 Streams are lazy; computation on the source data is only performed when the terminal operation is initiated,
					 and source elements are consumed only as needed.
				</p>
				<p>
					<span class="bold"><strong>Applying a function to each element of a stream</strong></span>
				</p>
				<p>
					Streams support the method <code class="code">map()</code>, which takes a <code class="code">java.util.function.Function</code> as an argument. 
					The function is applied to each element, mapping it into a new element (the word mapping is used because it has a meaning similar to
					transforming but with the nuance of "creating a new version of" rather than "modifying"). For example, in the
					following code you pass a method reference <code class="code">Employee::getName</code> to the <code class="code">map(...)</code> method to
					extract the names of the employees in the stream:
					</p><pre class="programlisting">
public class Employee {
    private String name;
    public Employee(String n) {
        name = n;
    }
    public String getName() {
        return name;
    }
}
					</pre><p>
					</p><pre class="programlisting">

Stream&lt;Employee&gt; emps = Stream.of(new Employee("Mikalai"), new Employee("Volha"));
Stream&lt;String&gt; names = emps.map(Employee::getName);
List&lt;String&gt; staff = names.collect(Collectors.toList());
System.out.print(staff);

					</pre><p>
					Output:
					</p><pre class="programlisting">
[Mikalai, Volha]
					</pre><p>
				</p>
				<p>
					Because the method <code class="code">Employee.getName()</code> returns a <code class="code">String</code>, the stream outputted
					by the <code class="code">map()</code> method is of type <code class="code">Stream&lt;String&gt;</code>.
				</p>
				<p>
					For example, if you wanted to find out the length of the name of each employee, you could do this by
					chaining another <code class="code">map(...)</code> as follows:
					</p><pre class="programlisting">

Stream&lt;Employee&gt; emps = Stream.of(new Employee("Mikalai"), new Employee("Volha"));
Stream&lt;String&gt; names = emps.map(Employee::getName);
Stream&lt;Integer&gt; lengths = names.map(n -&gt; n.length());
List&lt;Integer&gt; list = lengths.collect(Collectors.toList());
System.out.println(list);

					</pre><p>
					Output:
					</p><pre class="programlisting">
[7, 5]
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Primitive stream specializations</strong></span>
				</p>
				<p>
					Java 8.0 introduced three <span class="bold"><strong>primitive specialized stream interfaces</strong></span> that
					support specialized methods (like <code class="code">max()</code>, <code class="code">sum()</code>, <code class="code">average()</code>) to
					work with streams of numbers: <code class="code">IntStream</code>, <code class="code">DoubleStream</code>, and <code class="code">LongStream</code>,
					that respectively specialize the elements of a stream to be <code class="code">int</code> primitives,
					<code class="code">double</code> primitives, and <code class="code">long</code> primitives -- and thereby avoid hidden boxing costs.
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						The <code class="code">java.util.stream.Stream</code> interface has <code class="code">max(...)</code> and <code class="code">min(...)</code> methods, but they
						are not with empty parameter list as in <code class="code">IntStream</code>, <code class="code">DoubleStream</code>,
						<code class="code">LongStream</code> and require a <code class="code">Comparator</code> interface passed in as a parameter:
					</p>
					<p>
						The <code class="code">java.util.stream.Stream</code> interface does not have <code class="code">average()</code> and <code class="code">sum()</code> methods.
					</p>
				</td></tr></table></div>
				<p>
					Each of these three interfaces brings new methods to perform common numeric reductions such as <code class="code">sum()</code>
					to calculate the sum of a numeric stream and <code class="code">max()</code> to find the maximum element. In addition,
					they have methods to convert back to a stream of <code class="code">Object</code>s when necessary.
				</p>
				<p>
					<span class="bold"><strong>Mapping to a numeric stream</strong></span>
				</p>
				<p>
					The most common methods you will use to convert a stream to a primitive specialized version are <code class="code">Stream.mapToInt()</code>,
					<code class="code">Stream.mapToDouble()</code>, and <code class="code">Stream.mapToLong()</code>. These methods work exactly like the
					method <code class="code">Stream.map()</code> that you saw earlier but return a specialized stream instead of a
					<code class="code">Stream&lt;T&gt;</code>. For example, you can use <code class="code">mapToInt()</code> as follows to calculate the
					longest name of the employees:
					</p><pre class="programlisting">

Stream&lt;Employee&gt; emps = Stream.of(new Employee("Mikalai"), new Employee("Volha"), new Employee("Ivan"));
Stream&lt;String&gt; names = emps.map(e -&gt; e.getName());
IntStream lengths = names.mapToInt(n -&gt; n.length());
int i = lengths.max().getAsInt();
System.out.print(i);

					</pre><p>
					Here, the method <code class="code">mapToInt()</code> extracts all the lenghts from each name (represented as an <code class="code">int</code>)
					and returns an <code class="code">IntStream</code> as the result (rather than a <code class="code">Stream&lt;Integer&gt;</code>). You can
					then call the <code class="code">max()</code> method defined on the <code class="code">IntStream</code> interface to calculate the
					longest name. <code class="code">IntStream</code> also supports other convenience methods such as <code class="code">sum()</code>,
					<code class="code">min()</code>, and <code class="code">average()</code>.
				</p>			
				<p>
					<span class="bold"><strong><code class="code">Stream.flatMap(...)</code></strong></span>
				</p>
				<p>
					</p><pre class="programlisting">

&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)

					</pre><p>
					The <code class="code">Stream.flatMap(...)</code> method returns a stream consisting of the results of replacing
					each element of this stream with the contents of a mapped stream produced by applying the provided
					mapping function to each element. The function produces a stream for each input
					element and the output streams are flattened. Performs one-to-many mapping.
				</p>
				<p>
					The <code class="code">Stream.flatMap(...)</code> operation works as follows:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								It takes an input stream and produces an output stream using a mapping function.
							</p>
						</li><li class="listitem">
							<p>
								The mapping function takes an element from the input stream and maps the element to a
								stream. The type of input element and the elements in the mapped stream may be different.
								This step produces a stream of streams. Suppose the input stream is a
								<code class="code">Stream&lt;T&gt;</code> and the mapped stream is
								<code class="code">Stream&lt;Stream&lt;R&gt;&gt;</code> where <code class="code">T</code> and <code class="code">R</code> may be
								the same or different.
							</p>
						</li><li class="listitem">
							<p>
								Finally, it flattens the output stream (that is, a stream of streams) to produce a stream. That
								is, the <code class="code">Stream&lt;Stream&lt;R&gt;&gt;</code> is flattened to <code class="code">Stream&lt;R&gt;</code>.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					Let's look at a simple example. We have got a <code class="code">Stream</code> of lists of names, and we want all
					the names from these in sequences. We can solve this problem using an approach like
					the one in example below:
					</p><pre class="programlisting">

List&lt;String&gt; names1 = Arrays.asList("Dzmitry", "John");
List&lt;String&gt; names2 = Arrays.asList("David", "Laura");
Stream&lt;List&lt;String&gt;&gt; s = Stream.of(names1, names2);
s.flatMap(names -&gt; names.stream()).forEach(System.out::println);

					</pre><p>
					output:
					</p><pre class="programlisting">
Dzmitry
John
David
Laura
					</pre><p>
				</p>
				<p>
					We replace the <code class="code">List&lt;String&gt;</code> with a <code class="code">Stream&lt;String&gt;</code> using the
					<code class="code">stream()</code> method, and <code class="code">flatMap</code> does the rest. The <code class="code">flatMap</code>'s associated
					functional interface is the same as <code class="code">map</code>'s &#8212; the <code class="code">Function</code> &#8212; but its return type
					is restricted to streams and not any value.
				</p>
				<p>
					The <code class="code">flatMap(...)</code> transforms each element of a stream into another form (just like <code class="code">map(...)</code>),
					and generates sub-streams of the newly formed elements. Finally, it flattens all of the sub-streams into a single
					stream of elements. As the <code class="code">flatMap(...)</code> is a map type of function, it also takes a function
					and applies (maps) that function to each of the element in the stream.
				</p>
				<p>
					The difference between <code class="code">map(...)</code> and <code class="code">flatMap(...)</code> is:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								The <code class="code">map(...)</code> accepts a function that returns a mapped element and then the <code class="code">map(...)</code>
								function returns a stream of such elements (1 to 1).
							</p>
						</li><li class="listitem">
							<p>
								The <code class="code">flatMap</code> accepts a function that returns streams of the mapped elements and then
								the <code class="code">flatMap</code> finally returns a collective stream of all of the sub-streams that are
								created by the each execution of the passed function (1 to 0...n).
							</p>
						</li></ul></div><p>
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c4s2"></a>4.2.&nbsp;
					Search stream data using search <code class="code">findFirst</code>, <code class="code">findAny</code>, <code class="code">anyMatch</code>, <code class="code">allMatch</code> and 
					<code class="code">noneMatch</code> methods
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 8. Streams.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Java stream order of processing</strong></span>
				</p>
				<p>
					Streams may or may not have a defined <span class="bold"><strong>encounter order</strong></span>. Whether or not a stream 
					has an encounter order depends on the source and the intermediate operations. Certain stream sources (such as 
					<code class="code">java.util.List</code> or arrays) are intrinsically ordered, whereas others (such as <code class="code">java.util.HashSet</code>) 
					are not. Some intermediate operations, such as <code class="code">sorted()</code>, may impose an encounter order on an otherwise 
					unordered stream, and others may render an ordered stream unordered, such as <code class="code">BaseStream.unordered()</code>. 
					Further, some terminal operations may ignore encounter order, such as <code class="code">forEach()</code>.
				</p>
				<p>
					If a stream is ordered, most operations are constrained to operate on the elements in their encounter 
					order; if the source of a stream is a <code class="code">List</code> containing <code class="code">[1, 2, 3]</code>, then the result of 
					executing <code class="code">map(x -&gt; x*2)</code> must be <code class="code">[2, 4, 6]</code>.
					</p><pre class="programlisting">

List&lt;Integer&gt; ints = List.of(1, 2, 3);
Stream&lt;Integer&gt; str = ints.stream();
Spliterator&lt;Integer&gt; spl = str.spliterator();
System.out.print(spl.hasCharacteristics(Spliterator.ORDERED));


					</pre><p>
					</p><pre class="programlisting">
true
					</pre><p>
					However, if the source has no defined encounter order, then any permutation of the 
					values <code class="code">[2, 4, 6]</code> would be a valid result.
					</p><pre class="programlisting">

HashSet&lt;Integer&gt; ints = new HashSet&lt;&gt;();
ints.add(1); ints.add(2); ints.add(3);
Stream&lt;Integer&gt; str = ints.stream();
Spliterator&lt;Integer&gt; spl = str.spliterator();
System.out.print(spl.hasCharacteristics(Spliterator.ORDERED));

					</pre><p>
					</p><pre class="programlisting">
false					
					</pre><p>
				</p>
				<p>
					For sequential streams, the presence or absence of an encounter order does not affect performance, only 
					determinism. If a stream is ordered, repeated execution of identical stream pipelines on an identical source 
					will produce an identical result; if it is not ordered, repeated execution might produce different results.
				</p>
				<p>
					For parallel streams, relaxing the ordering constraint can sometimes enable more efficient execution			
				</p>
				<p>
					<span class="bold"><strong>Finding the first element - <code class="code">findFirst()</code></strong></span>
				</p>
				<p>
					For ordered streams you may wish to find the first element. There is the <code class="code">findFirst()</code> method for this:
					</p><pre class="programlisting">

Optional&lt;T&gt; findFirst();

					</pre><p>
					For example, given a list of integers, finds the first number that is divisible by <code class="code">7</code>:
					</p><pre class="programlisting">

List&lt;Integer&gt; ints = List.of(1, 6, 22, 21, 35, 36);
Optional&lt;Integer&gt; result = ints.stream().filter(i -&gt; i % 7 == 0).findFirst();
result.ifPresentOrElse(System.out::print, () -&gt; System.out.print("No results found"));

					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Finding an element - <code class="code">findAny()</code></strong></span>
				</p>
				<p>
					The <code class="code">findAny()</code> method returns an arbitrary element of the current stream.
					</p><pre class="programlisting">

Optional&lt;T&gt; findAny();

					</pre><p>
					It can be used in conjunction with other stream operations. For example, you may wish to find any manager
					from employee list. You can combine the <code class="code">filter(...)</code> method and <code class="code">findAny</code>
					to express this query:
					</p><pre class="programlisting">
public class Employee {
    public static final int MANAGER=100;
    public int type;
    public String name;

    public Employee(int t, String n) {
        type = t;
        name = n;
    }
}
					</pre><p>
					</p><pre class="programlisting">

Stream&lt;Employee&gt; emps = Stream.of(new Employee(100, "John"), new Employee(100, "Jane"), new Employee(99, "Deb"));
Optional&lt;Employee&gt; mgr = emps.filter(a -&gt; a.type == Employee.MANAGER).findAny();
System.out.print(mgr.get().name);

					</pre><p>
					The stream pipeline will be optimized behind the scenes to perform a single pass and finish as
					soon as a result is found by using short-circuiting.
				</p>
				<p>
					You may wonder why Java 8.0 introduced both <code class="code">findFirst()</code> and <code class="code">findAny()</code>. The reason behind
					<code class="code">findAny()</code> is to give a more flexible alternative to <code class="code">findFirst()</code>. If you are
					not interested in getting a specific element, this gives the implementing stream more flexibility in case
					it is a parallel stream.
				</p>
				<p>
					<span class="bold"><strong>No effort will be made to randomize the element returned</strong></span>, it just does
					not give the same guarantees as <code class="code">findFirst()</code>, and might therefore be faster.
				</p>
				<p>
				    The behavior of <code class="code">findAny()</code> operation is explicitly nondeterministic; it is free to select
				    any element in the stream. This is to allow for maximal performance in parallel operations; the cost
				    is that multiple invocations on the same source may not return the same result. If a stable result is
				    desired, use <code class="code">findFirst()</code> instead.
				</p>
				<p>
					<span class="bold"><strong>Checking to see if a predicate matches at least one element - <code class="code">anyMatch(...)</code></strong></span>
				</p>
				<p>
					The <code class="code">anyMatch(...)</code> method can be used to answer the question "Is there an element in the stream
					matching the given predicate?" It accepts <code class="code">Predicate</code> as parameter:
					</p><pre class="programlisting">

boolean anyMatch(Predicate&lt;? super T&gt; predicate);

					</pre><p>
				</p>
				<p>
					For example, you can use it to find out whether company has an employee with name "<code class="code">Mikalai</code>":
					</p><pre class="programlisting">

Stream&lt;Employee&gt; emps = Stream.of(new Employee(100, "Minerva"), new Employee(100, "Mikalai"), new Employee(99, "Michael"));
boolean b = emps.anyMatch(e -&gt; "Mikalai".equalsIgnoreCase(e.name));
if (b) {
    System.out.print("There is an employee with name 'Mikalai'");
}

					</pre><p>
					The <code class="code">anyMatch(...)</code> method returns a <code class="code">boolean</code> and is therefore a terminal operation.
				</p>
				<p>
					<span class="bold"><strong>Checking to see if a predicate matches all elements - <code class="code">allMatch(...)</code></strong></span>
				</p>
				<p>
					The <code class="code">allMatch(...)</code> method works similarly to <code class="code">anyMatch(...)</code> but will check to see
					if all the elements of the stream match the given predicate:
					</p><pre class="programlisting">

boolean allMatch(Predicate&lt;? super T&gt; predicate);

					</pre><p>
					For example, you can use it to find out
					whether all employee names start with "<code class="code">Mi</code>":
					</p><pre class="programlisting">

Stream&lt;Employee&gt; emps = Stream.of(new Employee(100, "Minerva"), new Employee(100, "Mikalai"), new Employee(99, "Michael"));
boolean b = emps.allMatch(e -&gt; e.name.startsWith("Mi"));
if (b) {
    System.out.println("All employee names start with 'Mi'");
}

					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Checking to see if a predicate does not match any element - <code class="code">noneMatch(...)</code></strong></span>
				</p>
				<p>
					The opposite of <code class="code">allMatch(...)</code> is <code class="code">noneMatch(...)</code>. It ensures that no elements in the
					stream match the given predicate:
					</p><pre class="programlisting">

boolean noneMatch(Predicate&lt;? super T&gt; predicate);

					</pre><p>
					For example, you can use it to find out whether company has an employee with
					name "<code class="code">Gandalf</code>":
					</p><pre class="programlisting">

Stream&lt;Employee&gt; emps = Stream.of(new Employee(100, "Minerva"), new Employee(100, "Mikalai"), new Employee(99, "Michael"));
boolean b = emps.noneMatch(e -&gt; e.name.equals("Gandalf"));
if (b) {
    System.out.print("Gandalf is employed by some other company !");
}

					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Remember method signatures:
					</p>
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								All <code class="code">findXxx()</code> methods have no arguments and return <code class="code">Optional</code>.
							</p>
						</li><li class="listitem">
							<p>
								All <code class="code">xxxMatch(...)</code> methods accept a <code class="code">Predicate</code> and return a <code class="code">boolean</code> primitive.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Some operations do not need to process the whole stream to produce a result. For example,
						you need to evaluate a large boolean expression chained with "<code class="code">&amp;&amp;</code>" operators. You need only find
						out that one expression is <code class="code">false</code> to deduce that the whole expression will return
						<code class="code">false</code>, no matter how long the expression is; there is no need to evaluate the
						entire expression. This is what short-circuiting refers to.
					</p>
					<p>
						In relation to streams, operations <code class="code">anyMatch(...)</code>, <code class="code">allMatch(...)</code>,
						<code class="code">noneMatch(...)</code>, <code class="code">findFirst()</code>, and <code class="code">findAny()</code>
						do not need to process the whole stream to produce a result. As soon as an element is found, a
						result can be produced. These are <span class="bold"><strong>short-circuiting terminal operations</strong></span>.
					</p>
				</td></tr></table></div>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c4s3"></a>4.3.&nbsp;
					 Use the <code class="code">Optional</code> class
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 8. Section 7. The Optional Type.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					A <code class="code">java.util.Optional&lt;T&gt;</code> object is either a wrapper for an <code class="code">Object</code> of type
					<code class="code">T</code> or a wrapper for no object. It is intended as a safer alternative than a reference of
					type <code class="code">T</code> that refers to an <code class="code">Object</code> or <code class="code">null</code>.
				</p>
				<p>
					Following is the declaration for <code class="code">java.util.Optional&lt;T&gt;</code> class:
					</p><pre class="programlisting">

public final class Optional&lt;T&gt; extends Object {
    ...
}

					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Creating Optional objects</strong></span>
				</p>
				<p>
					The first step before working with <code class="code">Optional</code> is to learn how to create optional objects. There are
					several ways:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<span class="bold"><strong>Empty <code class="code">Optional</code></strong></span>
							</p>
							<p>
								You can get hold of an empty optional object using the static factory method
								<code class="code">Optional.empty()</code>:
								</p><pre class="programlisting">

Optional&lt;String&gt; str = Optional.empty();

								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Optional</code> from a non-null value</strong></span>
							</p>
							<p>
								You can also create an optional from a non-null value with the <code class="code">static</code> factory method
								<code class="code">Optional.of(...)</code>:
								</p><pre class="programlisting">

String str = "ABC";
Optional&lt;String&gt; optStr = Optional.of(str);

								</pre><p>
							</p>
							<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
								<p>
									If <code class="code">str</code> were <code class="code">null</code>, a <code class="code">NullPointerException</code> would
									be immediately thrown!
								</p>
							</td></tr></table></div>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Optional</code> from <code class="code">null</code>able value</strong></span>
							</p>
							<p>
								Finally, by using the <code class="code">static</code> factory method <code class="code">Optional.ofNullable(...)</code>, you can
								create an <code class="code">Optional</code> object that may hold a <code class="code">null</code> value:
								</p><pre class="programlisting">

String str = null;
Optional&lt;String&gt; optStr = Optional.ofNullable(str);

								</pre><p>
								In the example above, since the <code class="code">str</code> is <code class="code">null</code>, the resulting
								<code class="code">Optional</code> object would be <span class="bold"><strong>empty</strong></span>.
							</p>
							<p> 
								The <code class="code">ofNullable(...)</code> method is intended as a bridge from the use of <code class="code">null</code>
								values to optional values. The <code class="code">Optional.ofNullable(obj)</code> returns
								<code class="code">Optional.of(obj)</code> if <code class="code">obj</code> is not <code class="code">null</code>, and
								<code class="code">Optional.empty()</code> otherwise.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					<span class="bold"><strong>Unwrapping an <code class="code">Optional</code></strong></span>
				</p>
				<p>
					The <code class="code">Optional</code> class provides several instance methods to read the value contained
					by an <code class="code">Optional</code> instance.
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">Optional.get()</code> - is the simplest but also the least safe of these methods. It returns
								the wrapped value if present but throws a <code class="code">NoSuchElementException</code> otherwise. For this
								reason, using this method is almost always a bad idea unless you are really sure the optional
								contains a value.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">Optional.orElse(T other)</code> it allows you to provide a default value for when the optional
								does not contain a value.
							</p>
							<p>
								NOTE: the <code class="code">other</code> value may be <code class="code">null</code>.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">Optional.orElseGet(Supplier&lt;? extends T&gt; other)</code> is the lazy counterpart of the
								<code class="code">orElse</code> method, because the supplier is invoked only if the optional contains no
								value. You should use this method either when the default value is time-consuming to create
								or you want to be sure this is done only if the optional is empty.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">&lt;X extends Throwable&gt; Optional.orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code> is similar to
								the <code class="code">get()</code> method in that it throws an exception when the optional is empty, but in
								this case it allows you to choose the type of exception that you want to throw.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">Optional.ifPresent(Consumer&lt;? super T&gt; consumer)</code> lets you execute the action
								given as argument if a value is present; otherwise no action is taken.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">Optional.isPresent()</code> returns <code class="code">true</code> if the <code class="code">Optional</code> contains
								a value, <code class="code">false</code> otherwise.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">Optional.isEmpty()</code> returns <code class="code">true</code> if the <code class="code">Optional</code> is empty, 
								<code class="code">false</code> otherwise.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					<span class="bold"><strong>Converting an <code class="code">Optional</code> into a <code class="code">Stream</code></strong></span>
				</p>
				<p>
					The <code class="code">Optional.stream()</code> method allows you to convert an <code class="code">Optional</code> to a <code class="code">Stream</code>.
				</p>
				<p>
					If the <code class="code">Optional</code> contains a value, it will return a <code class="code">Stream</code> containing only that 
					value, otherwise, it will return an empty <code class="code">Stream</code>:
					</p><pre class="programlisting">

Optional&lt;Integer&gt; in = Optional.of(1);
in.stream()
    .filter(i -&gt; i &gt; 0)
    .forEach(System.out::println);

					</pre><p>
					</p><pre class="programlisting">
1
					</pre><p>
					The <code class="code">Optional.stream()</code> method can be helpful when you are dealing with a stream of 
					<code class="code">Optional</code> elements. It will help to filter out empty optionals and keep the ones 
					with values.
				</p>
				<p>
					Assume we have a list of optionals received from a method, and some of the optionals are empty:					
					</p><pre class="programlisting">

Stream&lt;Optional&lt;String&gt;&gt; stream = Stream.of(
    Optional.of("Java"),
    Optional.empty(), 
    Optional.of("is"),
    Optional.empty(), 
    Optional.of("good"));

					</pre><p>
					In Java 8.0 you could remove empty optionals as follows:
					</p><pre class="programlisting">

List&lt;String&gt; list = stream
    .flatMap(o -&gt; o.isPresent() ? Stream.of(o.get()) : Stream.empty())
    .collect(Collectors.toList());

					</pre><p>
					In Java 9.0 and later you can remove empty optionals with shorter code using <code class="code">flatMap()</code>:
					</p><pre class="programlisting">

List&lt;String&gt; list = stream 
    .flatMap(Optional::stream)
    .collect(Collectors.toList());

					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>The <code class="code">map()</code> and <code class="code">flatMap()</code> in <code class="code">Optional</code></strong></span>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Both <code class="code">Optional.map()</code> and <code class="code">Optional.flatMap()</code> 
						return an <code class="code">Optional</code>.
					</p>
					<p>
						Use <code class="code">Optional.map()</code> if the function returns the object you need; or 
						<code class="code">Optional.flatMap()</code> if the function returns an <code class="code">Optional</code>.
					</p>
				</td></tr></table></div>
				<p>
					 If the function returns the exact type we need:
					 </p><pre class="programlisting">

Optional&lt;String&gt; s = Optional.of("Java");
s = s.map(String::toUpperCase); // function returns String
s.ifPresent(System.out::print);

					 </pre><p>
					 If we have a function that returns an <code class="code">Optional</code> then using <code class="code">map()</code> would lead 
					 to a nested structure of optionals, as the <code class="code">map()</code> does an additional wrapping. Use 
					 <code class="code">flatMap()</code> to keep a flat structure:
					 </p><pre class="programlisting">

Optional&lt;String&gt; s = Optional.of("Java");
s = s.flatMap(val -&gt; Optional.of(val.toUpperCase())); // function returns Optional&lt;String&gt;
s.ifPresent(System.out::print);

					 </pre><p>
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c4s4"></a>4.4.&nbsp;
					 Perform calculations using <code class="code">count</code>, <code class="code">max</code>, <code class="code">min</code>, <code class="code">average</code> and <code class="code">sum</code> stream operations
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 8. 
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong><code class="code">Stream</code> data methods</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">Stream.min(...)</code> and <code class="code">Stream.max(...)</code>
							</p>
							<p>
								 The <code class="code">min(...)</code> and <code class="code">max(...)</code> methods are <code class="code">Stream</code> terminal operations. Once these are
								 called, the stream will be iterated, filtering and mapping applied, and the minimum or maximum value in the stream will
								 be returned.
							</p>
							<p>
								Here is a Java <code class="code">Stream.min(...)</code> example:
								</p><pre class="programlisting">
String shortest = items.stream()
    .min(Comparator.comparing(item -&gt; item.length()))
    .get();
								</pre><p>
							</p>
							<p>
								 The <code class="code">min(...)</code> and <code class="code">max(...)</code> methods return an <code class="code">Optional</code> instance which has
								 a <code class="code">get()</code> method, which you use to obtain the value. In case the stream has no elements the
								 <code class="code">get()</code> method will throw <code class="code">NoSuchElementException</code>.
							</p>
							<p>
								The <code class="code">Stream.min(...)</code> and <code class="code">Stream.max(...)</code> methods take a <code class="code">Comparator</code> interface as
								parameter. The <code class="code">Comparator.comparing(...)</code> method creates a <code class="code">Comparator</code> based on the lambda
								expression passed to it. In fact, the <code class="code">comparing(...)</code> method takes a <code class="code">Function</code> which is a
								functional interface suited for lambda expressions. It takes one parameter and returns a value.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">Stream.count()</code>
							</p>
							<p>
								The <code class="code">Stream.count()</code> method simply returns the number of elements in the stream after filtering has been applied.
								Here is an example:
								</p><pre class="programlisting">
long count = items.stream()
    .filter(item -&gt; item.startsWith("J"))
    .count();
								</pre><p>
							</p>
							<p>
								 This example iterates the stream and keeps all elements that start with the character <code class="code">J</code>, and then
								 counts these elements.
							</p>
							<p>
								The <code class="code">count()</code> method returns a <code class="code">long</code> which is the count of elements in the stream.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					<span class="bold"><strong>Primitive streams</strong></span>
				</p>
				<p>
					The stream library has specialized types <code class="code">IntStream</code>, <code class="code">LongStream</code>, and
					<code class="code">DoubleStream</code> that store primitive values directly, without using wrappers. If you
					want to store <code class="code">short</code>, <code class="code">char</code>, <code class="code">byte</code>, and <code class="code">boolean</code>,
					use an  <code class="code">IntStream</code>, and for  <code class="code">float</code>, use a  <code class="code">DoubleStream</code>.
				</p>
				<p>
					When you have a stream of objects, you can transform it to a primitive type stream with the
					<code class="code">mapToInt</code>, <code class="code">mapToLong</code>, or <code class="code">mapToDouble</code> methods:
					</p><pre class="programlisting">

Stream&lt;String&gt; words = ...;
IntStream lengths = words.mapToInt(String::length);

					</pre><p>
				</p>
				<p>
					There are methods  <code class="code">sum()</code>,  <code class="code">average()</code>,  <code class="code">max()</code>, and  <code class="code">min()</code> that return
					the sum, average, maximum, and minimum. These methods are defined for <code class="code">XxxStream</code> and not defined
					for <code class="code">Stream</code>:
					</p><pre class="programlisting">

IntStream stream = IntStream.of(2, 4, 6);
int max = stream.max().getAsInt(); // max() returns OptionalInt

stream = IntStream.of(2, 4, 6);
int min = stream.min().getAsInt(); // min() returns OptionalInt

stream = IntStream.of(2, 4, 6);
double average = stream.average().getAsDouble(); // average() returns OptionalDouble

stream = IntStream.of(2, 4, 6);
int sum = stream.sum(); // sum() returns int

System.out.println("max : " + max);
System.out.println("min : " + min);
System.out.println("average : " + average);
System.out.println("sum : " + sum);

					</pre><p>
					</p><pre class="programlisting">
max : 6
min : 2
average : 4.0
sum : 12
					</pre><p>
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c4s5"></a>4.5.&nbsp;
					Sort a collection using lambda expressions
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 8.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Sorting a <code class="code">Stream</code></strong></span>
				</p>
				<p>
					Java streams API has several sorting methods.
				</p>
				<p>
					Below example shows the stream of employees is mapped to the employee names and then there is a <code class="code">sorted()</code>
					method, which returns the sorted stream of employee names. Remember, the <code class="code">Stream.sorted()</code> 
					is a <span class="emphasis"><em>stateful intermediate operation</em></span> which  
					does not take any parameter here, and hence it will sort the list in natural order.
				</p>
				<p>
					</p><pre class="programlisting">
public class Employee {
    public String name;

    public Employee(String n) {
        name = n;
    }
}
					</pre><p>
					</p><pre class="programlisting">

Stream&lt;Employee&gt; emps = Stream.of(new Employee("John"), new Employee("Jane"), new Employee("Jack"));
List&lt;String&gt; sl = emps
    .map(e -&gt; e.name)
    .sorted()
    .collect(Collectors.toList());
System.out.print(sl);

					</pre><p>
					Output:
					</p><pre class="programlisting">
[Jack, Jane, John]
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						The <code class="code">Stream.sorted()</code> method without parameters requires a stream of <code class="code">Comparable</code> elements!
					</p>
					<p>
						If the elements of this stream are not <code class="code">Comparable</code>, a <code class="code">java.lang.ClassCastException</code> may be thrown
						when the terminal operation is executed.
					</p>
					<p>
						For ordered streams, the sort is stable. For unordered streams, no stability guarantees are made.
					</p>
					
				</td></tr></table></div>
				<p>
					We can use our own sorting logic by calling <code class="code">Stream.sorted(...)</code> intermediate operation 
					and passing a <code class="code">Comparator</code> interface as a parameter. The <code class="code">comparing(...)</code> and few other
					useful <code class="code">static</code> and <code class="code">default</code> methods have been added to the 
					<code class="code">java.util.Comparator</code> interface in Java 8.0 to simplify these scenarios.
				</p>
				<p>
					Here is an example how the	<code class="code">Comparator.comparing(...)</code> method is used to provide a custom 
					sorting logic (e.g. when elements do not implement <code class="code">java.lang.Comparable</code> interface or when the same 
					elements need to be sorted by different algorithms).
					</p><pre class="programlisting">
public class Employee {
    public String name;

    public Employee(String n) {
        name = n;
    }
    
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}
					</pre><p>
					</p><pre class="programlisting">

Stream&lt;Employee&gt; emps = Stream.of(new Employee("Nathaniel"), new Employee("Steve"), new Employee("Nick"));
List&lt;Employee&gt; sl = emps
    .sorted(Comparator.comparing(e -&gt; e.name.length()))
    .collect(Collectors.toList());
System.out.print(sl);

					</pre><p>
					The output of the above code is employee list in sorted by name length order:
					</p><pre class="programlisting">
[Nick, Steve, Nathaniel]
					</pre><p>
				</p>
				<p>
					<code class="code">Comparator.thenComparing(...)</code> is a <code class="code">default</code> method of the <code class="code">Comparator</code> interface
					introduced in Java 8.0. If we have two <code class="code">Comparator</code> interface instances, and we want to do a
					sorting by composite condition (by first comparator and then by second comparator), we can use both
					comparators invoking <code class="code">thenComparing(...)</code> on first instance and passing in the second instance.
					Find the example below:
					</p><pre class="programlisting">

Stream&lt;Employee&gt; emps = Stream.of(
    new Employee("Nathaniel"), new Employee("Jane"),
    new Employee("Steve"), new Employee("Nick"),
    new Employee("Jack"));

Comparator&lt;Employee&gt; c1 = Comparator.comparing(e -&gt; e.name.length());
Comparator&lt;Employee&gt; c2 = (e1, e2) -&gt; e1.name.compareTo(e2.name);

List&lt;Employee&gt; sl = emps
    .sorted(c1.thenComparing(c2))
    .collect(Collectors.toList());
System.out.println(sl);

					</pre><p>
					The output of the above code is employee list in sorted by name length order, and in case name lengths
					are equal, such employees are sorted by name alphabetical order:
					</p><pre class="programlisting">
[Jack, Jane, Nick, Steve, Nathaniel]
					</pre><p>
				</p>
				<p>
					You can sort a stream in the reverse order by preparing a simple <code class="code">Comparator</code> instance for 
					the sort and then calling <code class="code">reversed()</code> method on it to get the reversed 
					version of that <code class="code">Comparator</code>:
					</p><pre class="programlisting">

Comparator&lt;Employee&gt; byNameLengthDesc = Comparator.comparing((Employee e) -&gt; e.name.length()).reversed();
Stream&lt;Employee&gt; emps = Stream.of(new Employee("Nathaniel"), new Employee("Steve"), new Employee("Nick"));
List&lt;Employee&gt; sl = emps
    .sorted(byNameLengthDesc)
    .collect(Collectors.toList());
System.out.print(sl);
					
					</pre><p>
					</p><pre class="programlisting">
[Nathaniel, Steve, Nick]
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Sorting a <code class="code">List</code></strong></span>
				</p>
				<p>
					The <code class="code">java.util.Collections.sort(...)</code> method sorts the specified <code class="code">List</code> into ascending order, 
					according to the natural ordering of its elements. All elements in the list must implement the 
					<code class="code">Comparable</code> interface. Furthermore, all elements in the list must be mutually comparable:
					</p><pre class="programlisting">

List&lt;String&gt; emps = new ArrayList&lt;&gt;();
emps.add("Nathaniel"); emps.add("Steve"); emps.add("Nick");
Collections.sort(emps);
System.out.print(emps);
					
					</pre><p>
					</p><pre class="programlisting">
[Nathaniel, Nick, Steve]
					</pre><p>
				</p>
				<div class="warning" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Warning]" src="images.admon/warning.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						If you initialize a list like this, it will fail at runtime, as the factory method creates <span class="bold"><strong>immutable</strong></span> 
						list object and sorting modifies exactly the same list object:
						</p><pre class="programlisting">

List&lt;String&gt; emps = List.of("Nathaniel", "Steve","Nick");
						
						</pre><p> 
					</p>
				</td></tr></table></div>
				<p>
					If the objects in the list do not implement <code class="code">Comparable</code>, you should provide your custom 
					<code class="code">Comparator</code>:
					</p><pre class="programlisting">

List&lt;Employee&gt; emps = new ArrayList&lt;&gt;();        
emps.add(new Employee("Nathaniel"));
emps.add(new Employee("Steve")); 
emps.add(new Employee("Nick"));
Comparator&lt;Employee&gt; c = (e1, e2) -&gt; e1.name.compareTo(e2.name);
Collections.sort(emps, c);
System.out.print(emps);
					
					</pre><p>
					</p><pre class="programlisting">
[Nathaniel, Nick, Steve]
					</pre><p>
				</p>
				<p>
					Or the same logic by using <code class="code">Comparator.comparing(...)</code> method:
					</p><pre class="programlisting">

Comparator&lt;Employee&gt; c = Comparator.comparing(e -&gt; e.name);

					</pre><p>
					Or using method reference syntax (assume <code class="code">Employee</code> has <code class="code">String getName()</code> method which 
					returns <code class="code">name</code>):
					</p><pre class="programlisting">

Comparator&lt;Employee&gt; c = Comparator.comparing(Employee::getName);

					</pre><p>
				</p>
				<p>
					As of Java 8.0 the <code class="code">java.util.List</code> interface has <code class="code">default void sort(Comparator&lt;? super E&gt; c)</code> method which 
					can sort own elements:
					</p><pre class="programlisting">

List&lt;Employee&gt; emps = new ArrayList&lt;&gt;();        
emps.add(new Employee("Nathaniel"));
emps.add(new Employee("Steve")); 
emps.add(new Employee("Nick"));
Comparator&lt;Employee&gt; c = Comparator.comparing(Employee::getName);
emps.sort(c);
System.out.print(emps);
					
					</pre><p>
					</p><pre class="programlisting">
[Nathaniel, Nick, Steve]
					</pre><p>			
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c4s6"></a>4.6.&nbsp;
					Use <code class="code">Collectors</code> with streams, including the <code class="code">groupingBy</code> and <code class="code">partitioningBy</code> operation
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 8.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					When you are done with a stream, you often just want to look at the results instead of reducing them to a value.
				</p>
				<p>
					You can use <code class="code">Stream.collect(...)</code> method. It takes three arguments:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							<p>
								A  supplier to make new instances of the target object, for example, a constructor for a hash set
							</p>
						</li><li class="listitem">
							<p>
								An accumulator that adds an element to the target, for example, an <code class="code">add</code> method
							</p>
						</li><li class="listitem">
							<p>
								An combiner that merges two objects into one, such as <code class="code">addAll</code>
							</p>
						</li></ol></div><p>
				</p>
				<p>
					There is a convenient <code class="code">Collector</code> interface for these three functions, and a  <code class="code">Collectors</code>
					class with factory methods for common collectors. To collect a stream into a list or set, you can simply call:
					</p><pre class="programlisting">

List&lt;String&gt; result = stream.collect(Collectors.toList());

					</pre><p>
					or
					</p><pre class="programlisting">

Set&lt;String&gt; result = stream.collect(Collectors.toSet());

					</pre><p>
					or if you want to control which kind of set you get, use the following call instead:
					</p><pre class="programlisting">

TreeSet&lt;String&gt; result = stream.collect(Collectors.toCollection(TreeSet::new));

					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						<code class="code">java.util.stream.Collector</code> is an interface.
					</p>
					<p>
						<code class="code">java.util.stream.Collectors</code> is a <code class="code">final</code> class whose
						<code class="code">static</code> methods return pre-defined <code class="code">Collector</code> implementations.
					</p>
				</td></tr></table></div>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Collectors.averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code></strong></span>
							</p>
							<p>
								<code class="code">Collectors.averagingDouble</code> calculates the average of stream element as <code class="code">double</code> data type.
								It returns a <code class="code">Collector</code> instance. The <code class="code">collect</code> method of stream can accept the
								<code class="code">Collector</code> instance and will return the average value calculated by
								<code class="code">Collectors.averagingDouble</code>.
							</p>
							<p>
								</p><pre class="programlisting">

List&lt;String&gt; list = Arrays.asList("A", "BB", "CCC", "DDDD", "CCCCC");
double result = list.stream().collect(Collectors.averagingDouble(s -&gt; s.length()));
System.out.println(result);

								</pre><p>
								output:
								</p><pre class="programlisting">
3.0
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Collectors.groupingBy(Function&lt;? super T,? extends K&gt; classifier)</code></strong></span>
							</p>
							<p>
								A "group by" operation on input elements of type <code class="code">T</code>, grouping elements according to a
								classification function, and returning the results in a map.
							</p>
							<p>
								</p><pre class="programlisting">
public class Employee {
    private String name;
    private String department;

    public Employee(String n, String d) {
        name = n;
        department = d;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDepartment() {
        return department;
    }

    public void setDepartment(String department) {
        this.department = department;
    }

    @Override
    public String toString() {
        return getName() + " from " + getDepartment() + " dept";
    }
}
								</pre><p>
							</p>
							<p>
								A common database operation is to group items in a set, based on one or more properties. It can
								be easily translated in a single, very readable statement by rewriting it in a more functional style
								as encouraged by Java 8.0. Suppose you want to group employees in a company based on
								their department. You can easily perform this task using a collector returned by the
								<code class="code">Collectors.groupingBy</code> factory method as follows:
							</p>
							<p>
								</p><pre class="programlisting">

Employee e1 = new Employee("Mikalai", "Development");
Employee e2 = new Employee("Volha", "HR");
Employee e3 = new Employee("Anastasia", "Management");
Employee e4 = new Employee("Daria", "Management");
Employee e5 = new Employee("Ivan", "Management");

Stream&lt;Employee&gt; str = Stream.of(e1, e2, e3, e4, e5);

// Group Employees by department
Map&lt;String, List&lt;Employee&gt;&gt; map = str.collect(Collectors.groupingBy(Employee::getDepartment));

System.out.println(map.get("Management"));

								</pre><p>
								Here, we passing to the <code class="code">groupingBy</code> method a <code class="code">Function</code> (expressed in the form
								of a method reference) extracting the corresponding department for each <code class="code">Employee</code> in the
								stream. We call this <code class="code">Function</code> a classification function because it is used to classify
								the elements of the stream into different groups. The result of this grouping operation is a
								<code class="code">java.util.Map</code> having as map key the value returned by the classification function and as
								corresponding map value a list of all the items in the stream having that classified value:
								</p><pre class="programlisting">
[Anastasia from Management dept, Daria from Management dept, Ivan from Management dept]
								</pre><p>
							</p>
							<p>
								It is possible to pass a second collector to the <code class="code">groupingBy</code> method to achieve a
								multilevel grouping. For instance, it is possible to count the number of employees in
								each department, by passing the <code class="code">Collectors.counting()</code> collector as a second
								argument to the <code class="code">groupingBy</code> collector:
								</p><pre class="programlisting">

// Counting Employees by department
Map&lt;String, Long&gt; map = str.collect(Collectors.groupingBy(Employee::getDepartment, Collectors.counting()));
System.out.println(map.get("Management"));

								</pre><p>
								output:
								</p><pre class="programlisting">
3
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Collectors.joining()</code></strong></span>
							</p>
							<p>
								The collector returned by the <code class="code">Collectors.joining()</code> factory method concatenates into a
								single string all strings resulting from invoking the <code class="code">toString()</code> method on each object
								in the stream. This means you can concatenate the names of all the employees in the company as
								follows:
								</p><pre class="programlisting">
String names = str.map(Employee::getName).collect(Collectors.joining());
								</pre><p>
								Note that <code class="code">joining()</code> internally makes use of a <code class="code">StringBuilder</code> to append
								the generated strings into one. It produces the following string:
								</p><pre class="programlisting">
MikalaiVolhaAnastasiaDariaIvan
								</pre><p>
								which is not very readable.
							</p>
							<p>
								Fortunately, the joining factory method has an overloaded version
								that accepts a delimiter string between two consecutive elements, so you can obtain a
								comma-separated list of the employees' names with:
								</p><pre class="programlisting">
String names = str.map(Employee::getName).collect(Collectors.joining(", "));
								</pre><p>
								It produces the following string:
								</p><pre class="programlisting">
Mikalai, Volha, Anastasia, Daria, Ivan
								</pre><p>
							</p>
							<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
								<p>
									<code class="code">Collectors.joining("")</code> is equivalent to <code class="code">Collectors.joining()</code>
								</p>
							</td></tr></table></div>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong><code class="code">Collectors.partitioningBy(Predicate&lt;? super T&gt; predicate)</code></strong></span>
							</p>
							<p>
								Partitions the input elements according to a <code class="code">Predicate</code>.
							</p>
							<p>
								When the classifier function is a <code class="code">Predicate</code> function (that is, a function returning
								a <code class="code">boolean</code> value), the stream elements are partitioned into two lists: those where
								the function returns <code class="code">true</code> and <code class="code">false</code>. In this case, it is more efficient to
								use  <code class="code">partitioningBy</code> instead of  <code class="code">groupingBy</code>. For example, here we split
								all employees into those that are managers, and all others:
								</p><pre class="programlisting">

Employee e1 = new Employee("Mikalai", "Development");
Employee e2 = new Employee("Volha", "HR");
Employee e3 = new Employee("Anastasia", "Management");
Employee e4 = new Employee("Daria", "Management");
Employee e5 = new Employee("Ivan", "Management");
Stream&lt;Employee&gt; str = Stream.of(e1, e2, e3, e4, e5);

// Parition Employees to managers and others
Map&lt;Boolean, List&lt;Employee&gt;&gt; map = str.collect(Collectors.partitioningBy(e -&gt; "Management".equals(e.getDepartment())));

System.out.println(map.get(Boolean.TRUE));

								</pre><p>
								resulting in:
								</p><pre class="programlisting">
[Anastasia from Management dept, Daria from Management dept, Ivan from Management dept]
								</pre><p>
								You can think of partitioning as a special case of grouping. Partitioning may only use <code class="code">Boolean</code>
								as <code class="code">Map</code> key, so you can have maximum two entries (each entry represented by a list of
								stream elements) in the resulting map.
							</p>
						</li></ul></div><p>
				</p>
			</div>			
		</div>
		<div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap5"></a>Chapter&nbsp;5.&nbsp;Java File I/O (NIO.2)</h2></div></div></div>
			
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c5s1"></a>5.1.&nbsp;
					Use <code class="code">Path</code> interface to operate on file and directory paths
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#JAVA_NIO_FILE_SUMMARY" title="Java NIO.2 File package summary">[JAVA_NIO_FILE_SUMMARY]</a> Java NIO.2 File package summary
							</p>
						</li><li class="listitem">
							<p>
								<a class="xref" href="#PATH_OPERATIONS" title="Path operations">[PATH_OPERATIONS]</a> Path operations
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					A <code class="code">java.nio.file.Path</code> object is somewhat analogous to a <code class="code">java.io.File</code> object as it can represent
					a file or directory on the file system. A <code class="code">Path</code> object is more abstract though, in that it is a sequence of
					names that represent a directory hierarchy (that may or may not include a file) on the file system. There are no methods
					in the <code class="code">Path</code> interface that allow working with directories or files. The defined methods are for working
					with or manipulating <code class="code">Path</code> objects only, resolving one <code class="code">Path</code> to another. (There is one method
					that can be used to obtain a <code class="code">java.io.File</code> object from a <code class="code">java.nio.file.Path</code>, <code class="code">toFile</code>.
					Likewise the <code class="code">java.io.File</code> class now contains a <code class="code">toPath</code> method.) To work with files and directories,
					<code class="code">Path</code> objects are used in conjunction with the <code class="code">java.nio.file.Files</code> class. The <code class="code">java.nio.file.Files</code>
					class consists entirely of static methods for manipulating directories and files, including copy, move and functions for
					working with symbolic links.
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Implementations of <code class="code">java.nio.file.Path</code> interface are immutable and safe for use by multiple concurrent threads.
					</p>
				</td></tr></table></div>
				<p>
					In Java 6.0 and earlier you do that:
					</p><pre class="programlisting">
File file = new File("README.TXT");
					</pre><p>
				</p>
				<p>
					Since Java 7.0 you do that:
					</p><pre class="programlisting">
// Paths class consists exclusively of static methods that return a Path by
// converting a path string or URI

Path path = Paths.get("README.TXT");
					</pre><p>
				</p>
				<p>
					To make the migration to Java 7.0 (or later) easier, the <code class="code">File</code> class has a new method <code class="code">toPath()</code> that allows you
					to transform <code class="code">File</code> to <code class="code">Path</code>:
					</p><pre class="programlisting">
Path path = new File("README.TXT").toPath();
					</pre><p>
				</p>
				<p>
					Like <code class="code">File</code>, a <code class="code">Path</code> can also refer to a not existing file. That is only file path, NOT the data
					containing in a file.
				</p>
				<p>
					The following code snippet defines a <code class="code">Path</code> instance and then invoke several methods to obtain information about
					the path. Assume we have following folders structure on Windows platform:
					</p><pre class="programlisting">
C:\home\zaikin\foo
					</pre><p>
				</p>
				<div class="warning" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Warning]" src="images.admon/warning.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						NOTE: None of listed below methods requires that the file corresponding to the <code class="code">Path</code> existed. 
						If the path does not exist physically on the disk, no runtime exception is thrown.  
					</p>
				</td></tr></table></div>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Create <code class="code">Path</code>:
								</p><pre class="programlisting">
Path path = Paths.get("C:\\home\\zaikin\\foo");
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								</p><pre class="programlisting">
String s = path.toString();
								</pre><p>
								returns
								</p><pre class="programlisting">
C:\home\zaikin\foo
								</pre><p>
							</p>
							<p>
								The <code class="code">toString()</code> method returns the string representation of the <code class="code">Path</code>. If the path
								was created using <code class="code">FileSystems.getDefault().getPath(String)</code> or <code class="code">Paths.get(...)</code> (the latter
								is a convenience method for <code class="code">getPath</code>), the method performs minor syntactic cleanup. For example, in
								a UNIX operating system, it will correct the input string <code class="code">//home/zaikin/foo</code> to <code class="code">/home/zaikin/foo</code>.
							</p>
						</li><li class="listitem">
							<p>
								</p><pre class="programlisting">
Path p = path.getFileName()
								</pre><p>
								returns
								</p><pre class="programlisting">
foo
								</pre><p>
							</p>
							<p>
								 The <code class="code">getFileName()</code> method returns the name of the file or directory denoted by this path as a <code class="code">Path</code> object.
								 The file name is the farthest element from the root in the directory hierarchy (last element of the sequence of name elements).
							</p>
						</li><li class="listitem">
							<p>
								</p><pre class="programlisting">
Path p = path.getName(0)
								</pre><p>
								returns
								</p><pre class="programlisting">
home
								</pre><p>
							</p>
							<p>
								The <code class="code">getName(int index)</code> method returns a name element of this path as a <code class="code">Path</code> object.
							</p>
							<p>
								The <code class="code">index</code> parameter is the index of the name element to return. The element that is closest to the root in
								the directory hierarchy has index <code class="code">0</code>. The element that is farthest from the root has index <code class="code">count-1</code>.
							</p>
							<p>
								NOTE: if <code class="code">index</code> is negative, <code class="code">index</code> is greater than or equal to the number of elements, or this path has zero name elements,
								then <code class="code">IllegalArgumentException</code> is thrown.
							</p>
						</li><li class="listitem">
							<p>
								</p><pre class="programlisting">
int i = path.getNameCount();
								</pre><p>
								returns
								</p><pre class="programlisting">
3
								</pre><p>
							</p>
							<p>
								The <code class="code">getNameCount()</code> method returns the number of name elements in the path.
							</p>
						</li><li class="listitem">
							<p>
								</p><pre class="programlisting">
Path p = path.subpath(0,2);
								</pre><p>
								returns
								</p><pre class="programlisting">
home\zaikin
								</pre><p>
							</p>
							<p>
								The <code class="code">subpath(int beginIndex, int endIndex)</code> method returns a relative <code class="code">Path</code> that is a subsequence
								of the name elements of this path.
							</p>
							<p>
								The <code class="code">beginIndex</code> and <code class="code">endIndex</code> parameters specify the subsequence of name elements. The name that is
								closest to the root in the directory hierarchy has index <code class="code">0</code>. The name that is farthest from the root has index
								<code class="code">count-1</code>. The returned <code class="code">Path</code> object has the name elements that begin at <code class="code">beginIndex</code> and
								extend to the element at index <code class="code">endIndex-1</code>.
							</p>
						</li><li class="listitem">
							<p>
								</p><pre class="programlisting">
Path p = path.getRoot();
								</pre><p>
								returns
								</p><pre class="programlisting">
C:\
								</pre><p>
							</p>
							<p>
								The <code class="code">getRoot()</code> method returns the root component of this path as a <code class="code">Path</code> object, or <code class="code">null</code> if this
								path does not have a root component (e.g. for relative paths).
							</p>
							<p>
								For UNIX platform the root will be "<code class="code">/</code>". For Windows, something like "<code class="code">C:\</code>".
							</p>
						</li><li class="listitem">
							<p>
								</p><pre class="programlisting">
Path p = path.resolveSibling("bar");
								</pre><p>
								returns
								</p><pre class="programlisting">
C:\home\zaikin\bar
								</pre><p>
							</p>
							<p>
								The <code class="code">resolveSibling(Path other)</code> and <code class="code">resolveSibling(String other)</code> methods resolve the given path against
								this path's parent path. This is useful where a file name needs to be replaced with another file name. For example, suppose that
								the name separator is "/" and a path represents "<code class="code">dir1/dir2/foo</code>", then invoking this method with the <code class="code">Path</code>
								"<code class="code">bar</code>" will result in the <code class="code">Path</code> "<code class="code">dir1/dir2/bar</code>". If this path does not have a parent path, or
								<code class="code">other</code> is absolute, then this method returns <code class="code">other</code>. If <code class="code">other</code> is an empty path then this
								method returns this path's parent, or where this path doesn't have a parent, the empty path.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					<span class="bold"><strong>Removing redundancies from a <code class="code">Path</code></strong></span>
				</p>
				<p>
					Given the following code:
					</p><pre class="programlisting">
Path path = Paths.get("C:\\home\\zaikin\\..\\..\\foo");
Path p = path.normalize();
System.out.println(path);
System.out.println(path.getNameCount());
System.out.println(p);
System.out.println(p.getNameCount());
					</pre><p>
					it prints (NOTE: implementations of <code class="code">Path</code> interface are immutable by design)
					</p><pre class="programlisting">
C:\home\zaikin\..\..\foo
5
C:\foo
1
					</pre><p>
				</p>
				<p>
					The <code class="code">normalize()</code> method returns a path that is this path with redundant name elements eliminated.
				</p>
				<p>
					The precise definition of this method is implementation dependent but in general it derives from this path, a path
					that does not contain redundant name elements. In many file systems, the "." and ".." are special names used to indicate
					the current directory and parent directory. In such file systems all occurrences of "." are considered redundant.
					If a ".." is preceded by a non-".." name then both names are considered redundant (the process to identify such names
					is repeated until is it no longer applicable).
				</p>
				<p>
					NOTE: This method does not access the file system; the path may not locate a file that exists. Eliminating ".." and a
					preceding name from a path may result in the path that locates a different file than the original path. This can arise
					when the preceding name is a symbolic link.
				</p>
				<p>
					<span class="bold"><strong>Creating a path between two paths</strong></span>
				</p>
				<p>
					A common requirement when you are writing file I/O code is the capability to construct a path from one location in the file system to
					another location. You can meet this using the <code class="code">relativize()</code> method. This method constructs a path originating from the original
					path and ending at the location specified by the passed-in path. The new path is relative to the original path. Relativization is the inverse of
					resolution.
				</p>
				<p>
					For example, consider two relative paths:
					</p><pre class="programlisting">
Path p1 = Paths.get("home");
Path p2 = Paths.get("home/zaikin/foo");
					</pre><p>
					the folowing code:
					</p><pre class="programlisting">
Path p1_p2 = p1.relativize(p2);
System.out.println(p1_p2);

Path p2_p1 = p2.relativize(p1);
System.out.println(p2_p1);
					</pre><p>
					will produce the following output:
					</p><pre class="programlisting">
zaikin\foo
..\..
					</pre><p>
				</p>
				<p>
					In this example, the two paths share the same node, <code class="code">home</code>. To navigate from <code class="code">home</code> to <code class="code">foo</code>, you first navigate one level
					down to <code class="code">zaikin</code> and then one more level down to <code class="code">foo</code>. Navigating from <code class="code">foo</code> to <code class="code">home</code> requires moving up two
					levels.
				</p>
				<p>
					A relative path CANNOT be constructed if only one of the paths includes a root element. If both paths include a root element, the capability to construct a
					relative path is system dependent.
				</p>
				<p>
					<span class="bold"><strong>Joining two <code class="code">Path</code>s</strong></span>
				</p>
				<p>
					You can combine paths by using the <code class="code">Path.resolve(Path other)</code> and <code class="code">Path.resolve(String other)</code> methods. You pass in a partial path, which is
					a path that does not include a root element, and that partial path is appended to the original path.
				</p>
				<p>
					If the <code class="code">other</code> parameter is an absolute path then this method trivially returns <code class="code">other</code>. If <code class="code">other</code> is an empty path then this method
					trivially returns this path. Otherwise this method considers this path to be a directory and resolves the given path against this path. In the simplest case, the
					given path does not have a root component, in which case this method joins the given path to this path and returns a resulting path that ends with the given
					path. Where the given path has a root component then resolution is highly implementation dependent and therefore unspecified.
				</p>
				<p>
					For example, consider the following code snippet:
					</p><pre class="programlisting">
Path p3 = Paths.get("C:\\home\\zaikin\\foo");
System.out.format("%s%n", p3.resolve("bar"));
					</pre><p>
					the result is:
					</p><pre class="programlisting">
C:\home\zaikin\foo\bar
					</pre><p>
				</p>
				<p>
					Passing an absolute path to the <code class="code">resolve</code> method returns the passed-in path:
					</p><pre class="programlisting">
Path p4 = Paths.get("bar");
System.out.format("%s%n", p4.resolve("C:\\home\\zaikin\\foo"));
					</pre><p>
					the result is:
					</p><pre class="programlisting">
C:\home\zaikin\foo
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Factory methods</strong></span>
				</p>
				<p>
					Java 11.0 added two new overloaded <code class="code">static</code> methods to <code class="code">java.nio.file.Path</code> interface to conveniently 
					create an instance of the interface:
					</p><pre class="programlisting">
public static Path of(String first, String... more)

public static Path of(URI uri) 
					</pre><p>
				</p>
				<p>
					Assuming we have a hierarchy:
					</p><pre class="programlisting">
C:\home
&#9492;&#9472;&#9472;&#9472;zaikin
    &#9492;&#9472;&#9472;&#9472;foo
            test.txt
					</pre><p>
				</p>
				<p>
					Then we can create <code class="code">Path</code> instances as follows:
					</p><pre class="programlisting">
Path path = Path.of("C:", "home", "zaikin", "foo", "test.txt");
System.out.println(path);
boolean exists = Files.exists(path);
System.out.println(exists);
					</pre><p>
					</p><pre class="programlisting">
C:\home\zaikin\foo\test.txt
true
					</pre><p>  
				</p>
				<p>
					</p><pre class="programlisting">
 URI uri = URI.create("file:///C:/home/zaikin/bar/test.txt"); // does NOT exist !
 System.out.println(uri);
 Path path = Path.of(uri);
 System.out.println(path);
 System.out.println(Files.exists(path));
					</pre><p>
					</p><pre class="programlisting">
file:///C:/home/zaikin/bar/test.txt
C:\home\zaikin\bar\test.txt
false
					</pre><p>
					</p><div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
						<p>
							Most of the <code class="code">Path</code> interface methods (including <code class="code">of(...)</code>) do not throw exception when 
							the file does not exist.						
						</p>
					</td></tr></table></div><p>
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c5s2"></a>5.2.&nbsp;
					 Use <code class="code">Files</code> class to check, delete, copy or move a file or directory
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#NIO_TUTORIAL" title="File I/O (Featuring NIO.2)">[NIO_TUTORIAL]</a> File I/O (Featuring NIO.2)
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					The <code class="code">java.nio.file.Files</code> class consists of <code class="code">static</code> methods that use <code class="code">Path</code> objects to
					work with files and directories.
				</p>
				<p>
					With file I/O, unexpected conditions are a fact of life: a file exists (or doesn't exist) when expected, the program does not have access to the file system,
					the default file system implementation does not support a particular function, and so on. All methods that access the file system can throw an <code class="code">java.io.IOException</code>.
					It is best practice to catch these exceptions by embedding these methods into a "try-with-resources" statement, introduced in the Java SE 7.0 release.
				</p>
				<p>
					In addition to <code class="code">IOException</code>, many specific exceptions extend <code class="code">FileSystemException</code>. This class has some useful methods that return the file
					involved (<code class="code">getFile</code>), the detailed message string (<code class="code">getMessage</code>), the reason why the file system operation failed (<code class="code">getReason</code>), and
					the "other" file involved, if any (<code class="code">getOtherFile</code>).
				</p>
				<p>
					Several <code class="code">Files</code> methods accept an arbitrary number of arguments when flags are specified. For example, in the following method signature, the ellipses notation
					after the <code class="code">CopyOption</code> argument indicates that the method accepts a variable number of arguments, or varargs, as they are typically called:
					</p><pre class="programlisting">
Files.move(Path, Path, CopyOption...);
					</pre><p>
				</p>
				<p>
					When a method accepts a varargs argument, you can pass it a comma-separated list of values or an array (<code class="code">CopyOption[]</code>) of values:
					</p><pre class="programlisting">
import static java.nio.file.StandardCopyOption.*;
...
Path source = ...;
Path target = ...;
Files.move(source, target, REPLACE_EXISTING, ATOMIC_MOVE);
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Copy a file</strong></span>
				</p>
				<p>
					To copy one file to another you would use the <code class="code">Files.copy</code> method:
					</p><pre class="programlisting">
Files.copy(Path source, Path target, CopyOption... options);
					</pre><p>
					 The <code class="code">options</code> argument are enums that specify how the file should be copied. There are actually two different <code class="code">Enum</code> classes,
					 <code class="code">LinkOption</code> and <code class="code">StandardCopyOption</code>, but both implement the <code class="code">CopyOption</code> interface.
				</p>
				<p>
					Here is the list of available options for <code class="code">Files.copy</code>:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">LinkOption.NOFOLLOW_LINKS</code>
							</p>
							<p>
								Indicates that symbolic links should NOT be followed. If the file to be copied is a symbolic link, the link is copied (and not the target of the link).
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">StandardCopyOption.COPY_ATTRIBUTES</code>
							</p>
							<p>
								Copies the file attributes associated with the file to the target file. The exact file attributes supported are file system and platform dependent, but
								last-modified-time is supported across platforms and is copied to the target file.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">StandardCopyOption.REPLACE_EXISTING</code>
							</p>
							<p>
								Performs the copy even when the target file already exists. If the target is a symbolic link, the link itself is copied (and not the target of the link).
								If the target is a non-empty directory, the copy fails with the <code class="code">FileAlreadyExistsException</code> exception.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					There is also a <code class="code">StandardCopyOption.ATOMIC_MOVE</code> enum, but if this option is specified, an <code class="code">UsupportedOperationException</code> is thrown. If no options
					are specified, the default is to throw an error if the target file exists or is a symbolic link.
				</p>
				<p>
					<span class="bold"><strong>Move a file</strong></span>
				</p>
				<p>
					You can move a file by using the following method:
					</p><pre class="programlisting">
Files.move(Path source, Path target, CopyOption... options);
					</pre><p>
				</p>
				<p>
					The available <code class="code">StandardCopyOptions</code> enums available are:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">StandardCopyOption.REPLACE_EXISTING</code>
							</p>
							<p>
								Performs the move even when the target file already exists. If the target is a symbolic link, the symbolic link is replaced but what it points to is not affected.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">StandardCopyOption.ATOMIC_MOVE</code>
							</p>
							<p>
								Performs the move as an atomic file operation. If the file system does not support an atomic move, an exception is thrown. With an <code class="code">ATOMIC_MOVE</code> you can
								move a file into a directory and be guaranteed that any process watching the directory accesses a complete file.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					If <code class="code">Files.move(...)</code> is called with <code class="code">StandardCopyOption.COPY_ATTRIBUTES</code> an <code class="code">UnsupportedOperationException</code> is thrown.
				</p>
				<p>
					<span class="bold"><strong>Reading, Writing, and Creating Files</strong></span>
				</p>
				<p>
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							<p>
								<span class="bold"><strong>Commonly used methods for small files</strong></span>
							</p>
							<p>
								If you have a small file and you would like to read its entire contents in one pass, you can use the <code class="code">readAllBytes(Path)</code> or <code class="code">readAllLines(Path, Charset)</code>
								method. These methods take care of most of the work for you, such as opening and closing the stream, but are not intended for handling large files. The following code shows
								how to use the <code class="code">readAllBytes</code> method:
								</p><pre class="programlisting">
Path file = ...;
byte[] fileArray;
fileArray = Files.readAllBytes(file);
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong>Buffered I/O methods for text files</strong></span>
							</p>
							<p>
								The <code class="code">java.nio.file</code> package supports channel I/O, which moves data in buffers, bypassing some of the layers that can bottleneck stream I/O.
							</p>
							<p>
								The <code class="code">newBufferedReader(Path, Charset)</code> method opens a file for reading, returning a <code class="code">BufferedReader</code> that can be used to read text from
								a file in an efficient manner.
							</p>
							<p>
								The following code snippet shows how to use the <code class="code">newBufferedReader</code> method to read from a file. The file is encoded in "<code class="code">US-ASCII</code>"
								</p><pre class="programlisting">
Charset charset = Charset.forName("US-ASCII");
try (BufferedReader reader = Files.newBufferedReader(file, charset)) {
    String line = null;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (NoSuchFileException  x ) {
    System.err.format("No such file: %s", x.getFile());
} catch (IOException  x) {
    System.err.println(x);
}
								</pre><p>
							</p>
							<p>
								You can use the <code class="code">newBufferedWriter(Path, Charset, OpenOption...)</code> method to write to a file using a <code class="code">BufferedWriter</code>:
								</p><pre class="programlisting">
/**
 * Opens or creates a file for writing, returning a BufferedWriter that may be used to write text to the
 * file in an efficient manner. The options parameter specifies how the the file is created or opened.
 * If no options are present then this method works as if the CREATE, TRUNCATE_EXISTING, and WRITE options
 * are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or
 * initially truncating an existing regular-file to a size of 0 if it exists.
 *
 * The Writer methods to write text throw IOException if the text cannot be encoded using the specified charset.
 */
public static BufferedWriter newBufferedWriter(Path path,
                                               Charset cs,
                                               OpenOption... options) throws IOException
								</pre><p>
							</p>
							<p>
								The following code snippet shows how to create a file encoded in "US-ASCII" using this method:
								</p><pre class="programlisting">
Charset charset = Charset.forName("US-ASCII");
String s = "ABC";
try (BufferedWriter writer = Files.newBufferedWriter(file, charset)) {
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong>Methods for unbuffered streams and interoperable with <code class="code">java.io</code> APIs</strong></span>
							</p>
							<p>
								To open a file for reading, you can use the <code class="code">newInputStream(Path, OpenOption...)</code> method. This method returns an unbuffered input stream for reading
								bytes from the file.
								</p><pre class="programlisting">
try (InputStream in = Files.newInputStream(file);
    BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {
    String line = null;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (NoSuchFileException  x) {
    System.err.println("No such file exists: " + x.getFile());
} catch (IOException  x) {
    System.err.println(x);
}
								</pre><p>
							</p>
						</li></ol></div><p>
				</p>
				<p>
					Several of the <code class="code">Files</code> methods take an optional <code class="code">OpenOptions</code> parameter. This parameter is optional and the API tells you what the default behavior
					is for the method when none is specified. The following <code class="code">StandardOpenOptions</code> enum constants are supported:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">APPEND</code> - If the file is opened for <code class="code">WRITE</code> access then bytes will be written to the end of the file rather than the beginning.
								If the file is opened for write access by other programs, then it is file system specific if writing to the end of the file is atomic.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">CREATE</code> - Create a new file if it does not exist. This option is ignored if the <code class="code">CREATE_NEW</code> option is also set. The check for the
								existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">CREATE_NEW</code> - Create a new file, failing if the file already exists. The check for the existence of the file and the creation of the file if it
								does not exist is atomic with respect to other file system operations.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">DELETE_ON_CLOSE</code> - Delete on close. When this option is present then the implementation makes a best effort attempt to delete the file when
								closed by the appropriate close method. If the close method is not invoked then a best effort attempt is made to delete the file when the Java virtual
								machine terminates (either normally, as defined by the Java Language Specification, or where possible, abnormally). This option is primarily intended for
								use with work files that are used solely by a single instance of the Java virtual machine. This option is not recommended for use when opening files that
								are open concurrently by other entities. Many of the details as to when and how the file is deleted are implementation specific and therefore not specified.
								In particular, an implementation may be unable to guarantee that it deletes the expected file when replaced by an attacker while the file is open. Consequently,
								security sensitive applications should take care when using this option.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">DSYNC</code> - Requires that every update to the file's content be written synchronously to the underlying storage device.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">READ</code> - Open for read access.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">SPARSE</code> - Sparse file. When used with the <code class="code">CREATE_NEW</code> option then this option provides a hint that the new file will be sparse. The
								option is ignored when the file system does not support the creation of sparse files.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">SYNC</code> - Requires that every update to the file's content or metadata be written synchronously to the underlying storage device.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">TRUNCATE_EXISTING</code> - If the file already exists and it is opened for <code class="code">WRITE</code> access, then its length is truncated to 0. This option is
								ignored if the file is opened only for <code class="code">READ</code> access.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">WRITE</code> - Open for write access.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					<span class="bold"><strong>Glob argument</strong></span>
				</p>
				<p>
					The <code class="code">newDirectoryStream</code> method in the <code class="code">Files</code> class accepts a glob argument:
					</p><pre class="programlisting">

/**
 * Opens a directory, returning a DirectoryStream to iterate over the entries in the directory.
 * The elements returned by the directory stream's iterator are of type Path, each one representing
 * an entry in the directory. The Path objects are obtained as if by resolving the name of the
 * directory entry against dir. The entries returned by the iterator are filtered by matching the
 * String representation of their file names against the given globbing pattern.
 */
public static DirectoryStream&lt;Path&gt; newDirectoryStream(Path dir, String glob) throws IOException;

					</pre><p>
				</p>
				<p>
					You can use <code class="code">glob</code> syntax to specify pattern-matching behavior. A <code class="code">glob</code> pattern is specified as a string and is matched against other strings, such
					as directory or file names. For example:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">*.java</code> - Matches a path that represents a file name ending in <code class="code">.java</code>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">*.*</code> - Matches file names containing a dot
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">*.{java,class}</code> - Matches file names ending with <code class="code">.java</code> or <code class="code">.class</code>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">foo.?</code> - 	Matches file names starting with <code class="code">foo.</code> and a single character extension
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">/home/*/*</code> - Matches <code class="code">/home/mikalai/data</code> on UNIX platforms
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">/home/**</code> - Matches <code class="code">/home/mikalai</code> and <code class="code">/home/mikalai/data</code> on UNIX platforms
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">C:\\*</code> - Matches <code class="code">C:\foo</code> and <code class="code">C:\bar</code> on the Windows platform (note that the backslash is escaped; as a
								string literal in the Java Language the pattern would be "<code class="code">C:\\\\*</code>")
							</p>
						</li></ul></div><p>
				</p>
				<p>
					<span class="bold"><strong>Creating temporary files</strong></span>
				</p>
				<p>
					You can create a temporary file using one of the following <code class="code">Files.createTempFile</code> methods:
					</p><pre class="programlisting">

/**
 * Creates a new empty file in the specified directory, using the given prefix and suffix strings to generate
 * its name. The resulting Path is associated with the same FileSystem as the given directory.
 *
 * The details as to how the name of the file is constructed is implementation dependent and therefore not specified.
 * Where possible the prefix and suffix are used to construct candidate names in the same manner as the
 * File.createTempFile(String,String,File) method.
 *
 * As with the File.createTempFile methods, this method is only part of a temporary-file facility. Where used as a work
 * files, the resulting file may be opened using the DELETE_ON_CLOSE option so that the file is deleted when the appropriate
 * close method is invoked. Alternatively, a shutdown-hook, or the File.deleteOnExit() mechanism may be used to delete the
 * file automatically.
 *
 * The attrs parameter is optional file-attributes to set atomically when creating the file. Each attribute is identified by
 * its name. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.
 * When no file attributes are specified, then the resulting file may have more restrictive access permissions to files
 * created by the File.createTempFile(String,String,File) method.
 */
 public static Path createTempFile(Path dir,
                  String prefix,
                  String suffix,
                  FileAttribute&lt;?&gt;... attrs)
                           throws IOException;

/**
 * Creates an empty file in the default temporary-file directory, using the given prefix and suffix to generate its name.
 * The resulting Path is associated with the default FileSystem.
 *
 * This method works in exactly the manner specified by the createTempFile(Path,String,String,FileAttribute[]) method for
 * the case that the dir parameter is the temporary-file directory.
 */
 public static Path createTempFile(String prefix,
                  String suffix,
                  FileAttribute&lt;?&gt;... attrs)
                           throws IOException;

					</pre><p>
				</p>
				<p>
					The first method allows the code to specify a directory for the temporary file and the second method creates a new file in the default
					temporary-file directory. Both methods allow you to specify a suffix for the filename and the first method allows you to also specify a
					prefix. The following code snippet gives an example of the second method:
					</p><pre class="programlisting">
try {
    Path tempFile = Files.createTempFile(null, ".myapp");
    System.out.format("The temporary file: %s%n", tempFile);
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
					</pre><p>
					The result of running this file would be something like the following:
					</p><pre class="programlisting">
The temporary file: C:\Users\IBM_AD~1\AppData\Local\Temp\3900024882240192379.myapp
					</pre><p>
				</p>
				<p>
					Another example:
					</p><pre class="programlisting">
try {
    Path tempFile = Files.createTempFile("mz", ".myapp");
    System.out.format("The temporary file: %s%n", tempFile);
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
					</pre><p>
					produces:
					</p><pre class="programlisting">
The temporary file: C:\Users\IBM_AD~1\AppData\Local\Temp\mz5583470123941111323.myapp
					</pre><p>
				</p>
				<p>
					A temporary file is just a simple file until YOU make sure that it is truly temporary, which means that an automatic mechanism must delete
					temporary files periodically or at a specified time. There are three approaches to automatic cleanup of temporary files:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								automatic file cleanup via <code class="code">File.deleteOnExit()</code>
							</p>
						</li><li class="listitem">
							<p>
								automatic file cleanup via shutdown-hook: <code class="code">Runtime.getRuntime().addShutdownHook(new Thread() { ... });</code>
							</p>
						</li><li class="listitem">
							<p>
								automatic file cleanup via <code class="code">StandardOpenOption.DELETE_ON_CLOSE</code>
							</p>
						</li></ul></div><p>
				</p>
				<p>
					Java 11 added following new methods to <code class="code">java.nio.file.Files</code> class to directly read <code class="code">String</code> from a file and to directly 
					write <code class="code">String</code> to a file:
					</p><pre class="programlisting">
 /**
  * Reads all content from a file into a string, decoding from bytes to characters
  * using the StandardCharsets.UTF_8 charset.
  *
  * The method ensures that the file is closed when all content have been read
  * or an I/O error, or other runtime exception, is thrown.
  */
public static String readString(Path path) throws IOException


 /**
  * Reads all characters from a file into a string, decoding from bytes to characters
  * using the specified charset.
  *
  * The method ensures that the file is closed when all content have been read
  * or an I/O error, or other runtime exception, is thrown.
  *
  *  This method reads all content including the line separators in the middle
  * and/or at the end. The resulting string will contain line separators as they
  * appear in the file.
  *
  *
  * This method is intended for simple cases where it is appropriate and convenient
  * to read the content of a file into a String. It is not intended for reading
  * very large files.
  */
public static String readString(Path path, Charset cs) throws IOException
					</pre><p>
					</p><pre class="programlisting">
 /**
  * Write a CharSequence to a file.
  * Characters are encoded into bytes using the StandardCharsets.UTF_8 charset.
  *
  */					
public static Path writeString(Path path, CharSequence csq, OpenOption... options) throws IOException
    
    
 /**
  * Write a CharSequence to a file.
  *
  * Characters are encoded into bytes using the specified charset.
  *
  * All characters are written as they are, including the line separators in
  * the char sequence. No extra characters are added.
  *
  * The options parameter specifies how the file is created
  * or opened. If no options are present then this method works as if the
  * StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, 
  * and StandardOpenOption.WRITE options are present. In other words, it
  * opens the file for writing, creating the file if it doesn't exist, or
  * initially truncating an existing regular file to a size of 0.
  */                          
public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options) throws IOException					
					</pre><p>
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c5s3"></a>5.3.&nbsp;
					 Use Stream API with <code class="code">Files</code>
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#JAVA_NIO_FILES_JAVADOC" title="Java NIO.2 Files class JavaDoc">[JAVA_NIO_FILES_JAVADOC]</a> <code class="code">Files</code> class JavaDoc								
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					The utility class <code class="code">java.nio.file.Files</code> was first introduced in Java 7.0 as part of Java NIO. The JDK 8.0
					API adds a couple of additional methods which enables us to use functional streams with files.
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">Files.find(...)</code>
							</p>
							<p>
								</p><pre class="programlisting">

public static Stream&lt;Path&gt; find(Path start,
                                int maxDepth,
                                BiPredicate&lt;Path,BasicFileAttributes&gt; matcher,
                                FileVisitOption... options)
                         throws IOException

								</pre><p>
								The <code class="code">find(...)</code> returns a <code class="code">Stream</code> that is lazily populated with <code class="code">Path</code> by searching for files in a file tree
								rooted at a given starting file.
							</p>
							<p>
								The <code class="code">find(...)</code> method walks the file tree in exactly the manner specified by the <code class="code">walk(...)</code> method. For
								each file encountered, the given <code class="code">BiPredicate</code> is invoked with its <code class="code">Path</code> and
								<code class="code">BasicFileAttributes</code>. The <code class="code">Path</code> object is obtained as if by resolving the relative path against
								start and is only included in the returned <code class="code">Stream</code> if the <code class="code">BiPredicate</code> returns
								<code class="code">true</code>. Compare to calling filter on the <code class="code">Stream</code> returned by <code class="code">walk(...)</code> method, this
								method may be more efficient by avoiding redundant retrieval of the <code class="code">BasicFileAttributes</code>.
							</p>
							<p>
								The returned stream encapsulates one or more <code class="code">DirectoryStreams</code>. If timely disposal of file system resources
								is required, the "try-with-resources" construct should be used to ensure that the stream's <code class="code">close()</code> method is invoked
								after the stream operations are completed. Operating on a closed stream will result in an <code class="code">IllegalStateException</code>.
							</p>
							<p>
								If an <code class="code">IOException</code> is thrown when accessing the directory after returned from this method, it is wrapped in an
								<code class="code">UncheckedIOException</code> which will be thrown from the method that caused the access to take place.
							</p>
							<p>
								The next example demonstrates how to find files in a directory or it's sub-directories:
								</p><pre class="programlisting">
C:\temp
    LibPathFinder.java
								</pre><p>
								</p><pre class="programlisting">

public static void main(String[] args) throws IOException {
    Path start = Paths.get("C:\\temp");
    int maxDepth = 5;
    try (Stream&lt;Path&gt; stream = Files.find(start, maxDepth, (path, attr) -&gt; String.valueOf(path).endsWith(".java"))) {
        String joined = stream
                .sorted()
                .map(String::valueOf)
                .collect(Collectors.joining("; "));
        System.out.println("Found: " + joined);
    }
}

								</pre><p>
							</p>
							<p>	
								The method <code class="code">find(...)</code> accepts three arguments: 
								</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
										<p>
											The directory path <code class="code">start</code> is the initial starting point
										</p>									
									</li><li class="listitem">
										<p>
											The <code class="code">maxDepth</code> defines the maximum folder depth to be searched
										</p>									
									</li><li class="listitem">
										<p>
											A matching predicate defines the search logic
										</p>									
									</li></ol></div><p>
								In the above example we search for all Java files (filename ends with <code class="code">.java</code>) under <code class="code">C:\temp</code> directory (limited depth is 
								5 sub-directories).
							</p>
							<p>
								Sample output:
								</p><pre class="programlisting">
Found: C:\temp\LibPathFinder.java
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">Files.lines(...)</code>
							</p>
							<p>
								</p><pre class="programlisting">

public static Stream&lt;String&gt; lines(Path path)  throws IOException

								</pre><p>
								The <code class="code">lines()</code> method reads all lines from a file as a <code class="code">Stream</code>. Bytes from the file are decoded
								into characters using the UTF-8 charset.
							</p>
							<p>
								The next example demonstrates how to print a file to console:
								</p><pre class="programlisting">

public static void main(String[] args) throws IOException {
    Path f = Paths.get("C:\\temp\\LibPathFinder.java");
    try (Stream&lt;String&gt; stream = Files.lines(f)) {
        stream.forEach(System.out::println);
    }
}

								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">Files.readAllLines(...)</code>
							</p>
							<p>
								</p><pre class="programlisting">

public static List&lt;String&gt; readAllLines(Path path) throws IOException

								</pre><p>
								The <code class="code">readAllLines(...)</code> method reads all lines from a file into a <code class="code">List</code>
								of <code class="code">String</code>s. Bytes from the file are decoded into characters using the UTF-8 charset.
							</p>
							<p>
								The next example demonstrates how to print a file to console:
								</p><pre class="programlisting">

public static void main(String[] args) throws IOException {
    Path f = Paths.get("C:\\temp\\LibPathFinder.java");
    List&lt;String&gt; list = Files.readAllLines(f);
    list.stream().forEach(System.out::println);
}

								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">Files.walk(...)</code>
							</p>
							<p>
								</p><pre class="programlisting">

public static Stream&lt;Path&gt; walk(Path start,
                                int maxDepth,
                                FileVisitOption... options)
                         throws IOException

								</pre><p>
							</p>
							<p>
								The <code class="code">walk(...)</code> returns a <code class="code">Stream</code> that is lazily populated with <code class="code">Path</code> by walking the
								file tree rooted at a given starting file. The file tree is traversed depth-first, the elements in the stream are
								<code class="code">Path</code> objects that are obtained as if by resolving the relative path against start.
							</p>
							<p>
								The stream walks the file tree as elements are consumed. The <code class="code">Stream</code> returned is guaranteed to have at least
								one element, the starting file itself. For each file visited, the stream attempts to read its <code class="code">BasicFileAttributes</code>.
								If the file is a directory and can be opened successfully, entries in the directory, and their descendants will follow
								the directory in the stream as they are encountered. When all entries have been visited, then the directory is closed.
								The file tree walk then continues at the next sibling of the directory.
							</p>
							<p>
								The <code class="code">maxDepth</code> parameter is the maximum number of levels of directories to visit. A value of <code class="code">0</code> means
								that only the starting file is visited, unless denied by the security manager. A value of
								<code class="code">MAX_VALUE</code> may be used to indicate that all levels should be visited.
							</p>
							<p>
								The next example demonstrates how to list all files and sub-directories in a directory:
								</p><pre class="programlisting">
C:\temp
&#9474;   A.class
&#9474;   A.java
&#9474;
&#9492;&#9472;&#9472;&#9472;dir1
        B.class
        B.java
								</pre><p>
								</p><pre class="programlisting">

public static void main(String[] args) throws IOException {
    Path start = Paths.get("C:\\temp");
    int maxDepth = 5;
    try (Stream&lt;Path&gt; stream = Files.walk(start, maxDepth)) {
        stream.forEach(System.out::println);
    }
}

								</pre><p>
								Sample output:
								</p><pre class="programlisting">
C:\temp
C:\temp\A.class
C:\temp\A.java
C:\temp\dir1
C:\temp\dir1\B.class
C:\temp\dir1\B.java						
								</pre><p>
							</p>
						</li></ul></div><p>
				</p>
			</div>
		</div>
		<div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap6"></a>Chapter&nbsp;6.&nbsp;Migration to a Modular Application</h2></div></div></div>
			
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c6s1"></a>6.1.&nbsp;
					 Migrate the application developed using a Java version prior to SE 9 to SE 11 including top-down and bottom-up migration, splitting a Java SE 8 application into modules for migration
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#JDEPS_DOC" title="JDeps documentation">[JDEPS_DOC]</a> <code class="code">jdeps</code> tool documentation								
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					Assume we have a utility library packaged as separate <code class="code">info-logger.jar</code> JAR (Java 8.0, non-modular):
					</p><pre class="programlisting">
C:\1Z0-817\INFO-LOGGER
&#9492;&#9472;&#9472;&#9472;by
    &#9492;&#9472;&#9472;&#9472;iba
        &#9492;&#9472;&#9472;&#9472;logging                
                InfoLogger.java
					</pre><p>
					</p><pre class="programlisting">
package by.iba.logging;

import java.util.logging.Logger;

public class InfoLogger {
    
    private static final Logger LOG = Logger.getLogger(InfoLogger.class.getName());
    
    public static void log(String msg) {
        LOG.info(msg);
    }

    public static Logger getLog() {
        return LOG;
    }
}					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\info-logger&gt;javac by\iba\logging\InfoLogger.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\info-logger&gt;jar cvf info-logger.jar .
added manifest
adding: by/(in = 0) (out= 0)(stored 0%)
adding: by/iba/(in = 0) (out= 0)(stored 0%)
adding: by/iba/logging/(in = 0) (out= 0)(stored 0%)
adding: by/iba/logging/InfoLogger.class(in = 667) (out= 370)(deflated 44%)
adding: by/iba/logging/InfoLogger.java(in = 328) (out= 181)(deflated 44%)
					</pre><p>
				</p>
				<p>
					And application (Java 8.0, non-modular) JAR:
					</p><pre class="programlisting">
C:\1Z0-817\APP
&#9492;&#9472;&#9472;&#9472;by
    &#9492;&#9472;&#9472;&#9472;iba
        &#9492;&#9472;&#9472;&#9472;app
                App.java
					</pre><p>
					</p><pre class="programlisting">
package by.iba.app;

import by.iba.logging.InfoLogger;
import java.util.logging.Logger;

public class App {

    public static void main(String... args) {
        InfoLogger.log("Application started ...");
        Logger logger = InfoLogger.getLog();
        logger.info("Application finished.");
    }    
}
					</pre><p>
					Application depends on <code class="code">info-logger.jar</code> utility JAR:
					</p><pre class="programlisting">
C:\1Z0-817\app&gt;javac -cp ../info-logger/info-logger.jar by\iba\app\App.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\app&gt;jar --verbose --create --file app.jar .
added manifest
adding: by/(in = 0) (out= 0)(stored 0%)
adding: by/iba/(in = 0) (out= 0)(stored 0%)
adding: by/iba/app/(in = 0) (out= 0)(stored 0%)
adding: by/iba/app/App.class(in = 513) (out= 348)(deflated 32%)
adding: by/iba/app/App.java(in = 320) (out= 176)(deflated 45%)					
					</pre><p>					
				</p>
				<p>
					We should get similar hierarchy:
					</p><pre class="programlisting">
C:\1Z0-817
&#9500;&#9472;&#9472;&#9472;app
&#9474;   &#9474;   app.jar
&#9474;   &#9474;
&#9474;   &#9492;&#9472;&#9472;&#9472;by
&#9474;       &#9492;&#9472;&#9472;&#9472;iba
&#9474;           &#9492;&#9472;&#9472;&#9472;app
&#9474;                   App.class
&#9474;                   App.java
&#9474;
&#9492;&#9472;&#9472;&#9472;info-logger
    &#9474;   info-logger.jar
    &#9474;
    &#9492;&#9472;&#9472;&#9472;by
        &#9492;&#9472;&#9472;&#9472;iba
            &#9492;&#9472;&#9472;&#9472;logging
                    InfoLogger.class
                    InfoLogger.java
					</pre><p>
				</p>
				<p>
					Now you can run the application in Java 8.0 style:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -classpath ./info-logger/info-logger.jar;./app/app.jar by.iba.app.App
Apr 20, 2019 11:56:21 PM by.iba.logging.InfoLogger log
INFO: Application started ...
Apr 20, 2019 11:56:21 PM by.iba.app.App main
INFO: Application finished.
					</pre><p>
				</p>
				<p>
					The structure of application looks as follows:
					</p><div class="figure"><a name="d5e2503"></a><p class="title"><b>Figure&nbsp;6.1.&nbsp;Java application before migration</b></p><div class="figure-contents">
  						
  						<div class="mediaobject"><img src="images/c6s100.gif" alt="Java application before migration"></div>
					</div></div><p><br class="figure-break">
				</p>
				<p>
					<span class="bold"><strong>Migrating from the top down</strong></span>
				</p>
				<p>
					We put all JARs (application and utility) to module path rather than class path and make application JAR modular.
				</p>
				<p>
					Check dependencies for application to create proper module descriptor:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jdeps --module-path info-logger/info-logger.jar -s app/app.jar
app.jar -&gt; info.logger
app.jar -&gt; java.base
app.jar -&gt; java.logging
info.logger -&gt; java.base
info.logger -&gt; java.logging
					</pre><p>
					Application depends on 3 modules: <code class="code">info.logger</code> (automatic module name for <code class="code">info-logger.jar</code>), <code class="code">java.base</code> (implicitly required by 
					any module), and <code class="code">java.logging</code>.
				</p>
				<p>
					Assume we have no source for <code class="code">info-logger.jar</code> and use it as automatic module:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Real module, but without module descriptor.
							</p>
						</li><li class="listitem">
							<p>
								We do not change someone else's JAR file
							</p>
						</li><li class="listitem">
							<p>
								Module name derived from JAR file name
							</p>
						</li><li class="listitem">
							<p>
								Exports all its packages
							</p>
						</li><li class="listitem">
							<p>
								Requires all other modules
							</p>
						</li></ul></div><p>
				</p>
				<p>
					Based on this we create a module definition for <code class="code">app</code> application module:
					</p><pre class="programlisting">
module app {
    requires info.logger;
    requires java.logging;
}
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\APP
&#9474;   module-info.java
&#9474;
&#9492;&#9472;&#9472;&#9472;by
    &#9492;&#9472;&#9472;&#9472;iba
        &#9492;&#9472;&#9472;&#9472;app
                App.java
					</pre><p>
					Recompile the application code:
					</p><pre class="programlisting">
javac -p ../info-logger/info-logger.jar module-info.java by\iba\app\App.java
					</pre><p>
					NOTE: <code class="code">-p</code> is synonym for <code class="code">--module-path</code>
				</p>
				<p>
					Recreate the application modular JAR file:
					</p><pre class="programlisting">
C:\1Z0-817\app&gt;jar --verbose --create --file app.jar .
added manifest
added module-info: module-info.class
adding: by/(in = 0) (out= 0)(stored 0%)
adding: by/iba/(in = 0) (out= 0)(stored 0%)
adding: by/iba/app/(in = 0) (out= 0)(stored 0%)
adding: by/iba/app/App.class(in = 513) (out= 348)(deflated 32%)
adding: by/iba/app/App.java(in = 320) (out= 176)(deflated 45%)
adding: module-info.java(in = 70) (out= 53)(deflated 24%)
					</pre><p>
				</p>
				<p>
					Run the application:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java --module-path ./info-logger/info-logger.jar;./app/app.jar -m app/by.iba.app.App
Apr 21, 2019 12:33:03 AM by.iba.logging.InfoLogger log
INFO: Application started ...
Apr 21, 2019 12:33:03 AM by.iba.app.App main
INFO: Application finished.
					</pre><p>
					NOTE: <code class="code">-m</code> is synonym for <code class="code">--module</code>
				</p>
				<p>
					</p><div class="figure"><a name="d5e2544"></a><p class="title"><b>Figure&nbsp;6.2.&nbsp;Java application after top-down migration</b></p><div class="figure-contents">
  						
  						<div class="mediaobject"><img src="images/c6s101.gif" alt="Java application after top-down migration"></div>
					</div></div><p><br class="figure-break">
				</p>
				<p>
					<span class="bold"><strong>Migrating from the bottom up</strong></span>					
				</p>
				<p>
					We make all library JARs modular and put on the module path, keep application JAR non-modular and put on the class path (it will become part of the unnamed module).
				</p>
				<p>
					Revert <code class="code">app.jar</code> back to non-modular (it will be part of unnamed module):
					</p><pre class="programlisting">
C:\1Z0-817\app&gt;jar -tvf app.jar
     0 Sun Apr 21 10:46:24 AST 2019 META-INF/
    94 Sun Apr 21 10:46:24 AST 2019 META-INF/MANIFEST.MF
     0 Fri Apr 19 22:29:28 AST 2019 by/
     0 Fri Apr 19 22:29:34 AST 2019 by/iba/
     0 Sat Apr 20 23:40:42 AST 2019 by/iba/app/
   513 Sun Apr 21 00:28:22 AST 2019 by/iba/app/App.class
   320 Sat Apr 20 23:40:32 AST 2019 by/iba/app/App.java
					</pre><p>
				</p>
				<p>
					The unnamed module:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Reads all other modules
							</p>
						</li><li class="listitem">
							<p>
								Exports all its packages
							</p>
						</li><li class="listitem">
							<p>
								Cannot have any dependencies declared on it
							</p>
						</li><li class="listitem">
							<p>
								Cannot be accessed by a named module (the one with <code class="code">module-info.class</code>)
							</p>
						</li></ul></div><p>
				</p>
				<p>
					Check dependencies for library utility JAR to create a module definition (<code class="code">module-info.java</code>):
					</p><pre class="programlisting">
C:\1Z0-817&gt;jdeps -s info-logger/info-logger.jar
info-logger.jar -&gt; java.base
info-logger.jar -&gt; java.logging
					</pre><p>
					Since <code class="code">java.base</code> always implicitly required by any module, we may think that we require only <code class="code">java.logging</code> module
					and come up with this definition:
					</p><pre class="programlisting">
// WRONG
module info.logger {  
    requires java.logging;
}
					</pre><p>
					But this module definition is wrong, because the library must export packages to be used by application (or by unnamed) 
					module.	We need to use <code class="code">jdeps</code> to generate accurate <code class="code">module-info.java</code> for us:
					</p><pre class="programlisting">
C:\1Z0-817\info-logger&gt;jdeps --generate-module-info . info-logger.jar
writing to .\info.logger\module-info.java
					</pre><p>
					The generated <code class="code">module-info.java</code> is writen into <code class="code">info.logger\module-info.java</code>, move it 1 level higher.
					The correct definition will look as follows (NOTE: <code class="code">requires transitive</code> also was recognized and added by <code class="code">jdeps</code>):
					</p><pre class="programlisting">
// CORRECT
module info.logger {
    requires transitive java.logging;
    exports by.iba.logging;
}
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						NOTE: module name may not contain dash character, it get replaced with period character automatically by <code class="code">jdeps</code> utility.
					</p>
				</td></tr></table></div>
				<p>					
					Re-compile the utility modular JAR sources:
					</p><pre class="programlisting">
C:\1Z0-817\info-logger&gt;javac module-info.java by\iba\logging\InfoLogger.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\INFO-LOGGER
&#9474;   module-info.class
&#9474;   module-info.java
&#9474;
&#9492;&#9472;&#9472;&#9472;by
    &#9492;&#9472;&#9472;&#9472;iba
        &#9492;&#9472;&#9472;&#9472;logging
                InfoLogger.class
                InfoLogger.java
					</pre><p>
					Re-create the modular JAR:
					</p><pre class="programlisting">
C:\1Z0-817\info-logger&gt;jar --verbose --create --file info-logger.jar .
added manifest
added module-info: module-info.class
adding: by/(in = 0) (out= 0)(stored 0%)
adding: by/iba/(in = 0) (out= 0)(stored 0%)
adding: by/iba/logging/(in = 0) (out= 0)(stored 0%)
adding: by/iba/logging/InfoLogger.class(in = 667) (out= 370)(deflated 44%)
adding: by/iba/logging/InfoLogger.java(in = 328) (out= 181)(deflated 44%)
adding: module-info.java(in = 97) (out= 78)(deflated 19%)
					</pre><p>					
				</p>
				<p>
					Now we can run the modularized application:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java --add-modules info.logger --module-path info-logger/info-logger.jar --class-path app/app.jar  by.iba.app.App
Apr 21, 2019 11:45:06 AM by.iba.logging.InfoLogger log
INFO: Application started ...
Apr 21, 2019 11:45:06 AM by.iba.app.App main
INFO: Application finished.
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						When the compiler compiles code in the unnamed module, or the Java launcher is invoked and the main class of the application 
						is loaded from the class path into the unnamed module of the application class loader, then the 
						<span class="bold"><strong>default set of root modules for the unnamed module is computed as follows</strong></span>:
						</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
								<p>
									The <code class="code">java.se</code> module is a root, if it exists. If it does not exist then every 
									<code class="code">java.*</code> module on the upgrade module path or among the system modules that exports at least one 
									package, without qualification, is a root.
								</p>
							</li><li class="listitem">
								<p>
									Every <code class="code">non-java.*</code> module on the upgrade module path or among the system modules that exports at least 
									one package, without qualification, is also a root.
								</p>
							</li></ul></div><p>
					</p>
					<p>
						Otherwise, the default set of root modules depends upon the phase:
						</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
								<p>
									At compile time it is usually the set of modules being compiled;
								</p>
							</li><li class="listitem">
								<p>
									At link time it is empty;
								</p>
							</li><li class="listitem">
								<p>
									At run time it is the application's main module, as specified via the  <code class="code">--module</code> (or <code class="code">-m</code> for short) launcher option.
								</p>
							</li></ul></div><p>
						It is occasionally necessary to add modules to the default root set in order to ensure that specific platform, library, or 
						service-provider modules will be present in the module graph. In any phase the option <code class="code">--add-modules &lt;module&gt;(,&lt;module*&gt;)*</code> 
						where <code class="code">&lt;module&gt;</code> is a module name, adds the named modules to the default set of root modules.
					</p>
				</td></tr></table></div>
				<p>
					So, we had to use <code class="code">--add-modules info.logger</code> option to tell the Java runtime to include the module by name to the default root set. There are also
					predefined constants: <code class="code">ALL-MODULE-PATH</code>, <code class="code">ALL-DEFAULT</code>, and <code class="code">ALL-SYSTEM</code>.
				</p>
				<p>
					The <code class="code">--module-path</code> option tells the Java runtime the location of our modules.
				</p>
				<p>
					</p><div class="figure"><a name="d5e2620"></a><p class="title"><b>Figure&nbsp;6.3.&nbsp;Java application after bottom-up migration</b></p><div class="figure-contents">
  						
  						<div class="mediaobject"><img src="images/c6s102.gif" alt="Java application after bottom-up migration"></div>
					</div></div><p><br class="figure-break">
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c6s2"></a>6.2.&nbsp;
					Use <code class="code">jdeps</code> to determine dependencies and identify way to address the cyclic dependencies
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#JDEPS_DOC" title="JDeps documentation">[JDEPS_DOC]</a> <code class="code">jdeps</code> tool documentation
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					</p><pre class="programlisting">
jdeps [options] path ...
					</pre><p>
				</p>
				<p>
					The <code class="code">jdeps</code> command shows the package-level or class-level dependencies of Java class files. The input 
					class can be a path name to a <code class="code">.class</code> file, a directory, a JAR file, or it can be a fully qualified 
					class name to analyze all class files. The options determine the output. By default, the <code class="code">jdeps</code> command 
					writes the dependencies to the system output. The command can generate the dependencies in DOT language (the 
					<code class="code">-dotoutput</code> option). 
				</p>
				<p>
					Possible options:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">-dotoutput dir_name</code> (or <code class="code">--dot-output dir_name</code>)
							</p>
							<p>
								Specifies the destination directory for DOT file output. If this option is specified, then the <code class="code">jdeps</code> 
								command generates one <code class="code">.dot</code> file for each analyzed archive named <code class="code">archive-file-name.dot</code> that 
								lists the dependencies, and also a summary file named <code class="code">summary.dot</code> that lists the dependencies among 
								the archive files.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">-s</code> (or <code class="code">-summary</code>)
							</p>
							<p>
								Prints a dependency summary only.
							</p>						
						</li><li class="listitem">
							<p>
								<code class="code">-jdkinternals</code> (or <code class="code">--jdk-internals</code>)
							</p>
							<p>
								Finds class-level dependencies in the JDK internal APIs. By default, this option analyzes all classes 
								specified in the <code class="code">--class-path</code> option and input files unless you specified the <code class="code">-include</code> 
								option. You can&#8217;t use this option with the <code class="code">-p</code>, <code class="code">-e</code>, and <code class="code">-s</code> options.
							</p>
							<p>
								Warning: The JDK internal APIs are inaccessible.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">-cp path</code> (or <code class="code">-classpath path</code>, or <code class="code">--class-path path</code>)
							</p>
							<p>
								Specifies where to find class files.
							</p>						
						</li><li class="listitem">
							<p>
								<code class="code">--module-path module_path</code>
							</p>						
							<p>
								Specifies the module path.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">&#8211;m module_name</code> (or <code class="code">--module module_name</code>)
							</p>
							<p>
								Specifies the root module for analysis.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">--generate-module-info dir</code>
							</p>
							<p>
								Generates <code class="code">module-info.java</code> under the specified directory. The specified JAR files 
								will be analyzed. This option cannot be used with <code class="code">--dot-output</code> or 
								<code class="code">--class-path</code> options. Use the <code class="code">--generate-open-module</code> option 
								for open modules.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">--generate-open-module dir</code>
							</p>
							<p>
								Generates <code class="code">module-info.java</code> for the specified JAR files under the specified directory as 
								open modules. This option cannot be used with the <code class="code">--dot-output</code> or 
								<code class="code">--class-path</code> options.
							</p>
						</li></ul></div><p> 
				</p>
				<p>
					Assume we have several JARs as follows:
					</p><pre class="programlisting">
C:\1Z0-817
&#9474;
&#9500;&#9472;&#9472;&#9472;app
&#9474;   &#9492;&#9472;&#9472;&#9472;by
&#9474;       &#9492;&#9472;&#9472;&#9472;iba
&#9474;           &#9492;&#9472;&#9472;&#9472;app
&#9474;                   App.java
&#9474;
&#9492;&#9472;&#9472;&#9472;info.logger
    &#9492;&#9472;&#9472;&#9472;by
        &#9492;&#9472;&#9472;&#9472;iba
            &#9492;&#9472;&#9472;&#9472;logging
                    InfoLogger.java
					</pre><p>
					</p><pre class="programlisting">
package by.iba.app;

import by.iba.logging.InfoLogger;
import java.util.logging.Logger;

public class App {

    public static void main(String... args) {
        InfoLogger.log("Application started ...");
        Logger logger = InfoLogger.getLog();
        logger.info("Application finished.");
    }    
}
					</pre><p>
					</p><pre class="programlisting">
package by.iba.logging;

import java.util.logging.Logger;

public class InfoLogger {
    
    private static final Logger LOG = Logger.getLogger(InfoLogger.class.getName());
    
    public static void log(String msg) {
        LOG.info(msg);
    }

    public static Logger getLog() {
        return LOG;
    }
}
					</pre><p>
					</p><pre class="programlisting">
javac info.logger\by\iba\logging\InfoLogger.java
jar --create --file info-logger.jar -C info.logger .

javac -cp info-logger.jar app\by\iba\app\App.java
jar --create --file app.jar -C app .
					</pre><p>
				</p>
				<p>
					Now we can check <span class="bold"><strong>class path dependencies</strong></span>:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jdeps -cp info-logger.jar -s app.jar

app.jar -&gt; info-logger.jar
app.jar -&gt; java.base
app.jar -&gt; java.logging
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817&gt;jdeps -s info-logger.jar

info-logger.jar -&gt; java.base
info-logger.jar -&gt; java.logging
					</pre><p>
				</p>
				<p>
					We can automatically generate module definitions for the 2 JARs:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jdeps --generate-module-info . *.jar

writing to .\app\module-info.java
writing to .\info.logger\module-info.java
					</pre><p>			
				</p>
				<p>
					The content of generated <code class="code">module-info.java</code> files as follows:
					</p><pre class="programlisting">
module app {
    requires info.logger;
    requires java.logging;
    exports by.iba.app;
}
					</pre><p>
					</p><pre class="programlisting">
module info.logger {
    requires transitive java.logging;
    exports by.iba.logging;
}
					</pre><p>					 
				</p>
				<p>
					Re-create JARs as modular ones:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac info.logger\module-info.java info.logger\by\iba\logging\InfoLogger.java
C:\1Z0-817&gt;jar --create --verbose --file info-logger.jar -C info.logger .

C:\1Z0-817&gt;javac -p info-logger.jar app\module-info.java app\by\iba\app\App.java
C:\1Z0-817&gt;jar --create --verbose --file app.jar -C app .
					</pre><p>
				</p>
				<p>
					Now we can check <span class="bold"><strong>module dependencies</strong></span>:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jdeps --module-path app.jar;info-logger.jar -summary --module app
app -&gt; info.logger
app -&gt; java.base
app -&gt; java.logging
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817&gt;jdeps --module-path app.jar;info-logger.jar -summary --module info.logger
info.logger -&gt; java.base
info.logger -&gt; java.logging
					</pre><p>					
				</p>
				<p>
					Also, you can visualize the dependencies for all JARs:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jdeps --module-path app.jar;info-logger.jar --dot-output . *.jar
					</pre><p>
					The results are several <code class="code">.dot</code> files in the current directory, we 
					check the <code class="code">summary.dot</code>:
					</p><pre class="programlisting">
digraph "summary" {
  "app"                                              -&gt; "info.logger";
  "app"                                              -&gt; "java.base (java.base)";
  "app"                                              -&gt; "java.logging (java.logging)";
  "info.logger"                                      -&gt; "java.base (java.base)";
  "info.logger"                                      -&gt; "java.logging (java.logging)";
}
					</pre><p>
					You can visualize module dependency graph (e.g. at <code class="code">http://www.webgraphviz.com/</code>):
				</p>
				<p>
					</p><div class="figure"><a name="d5e2726"></a><p class="title"><b>Figure&nbsp;6.4.&nbsp;Java application module dependency graph</b></p><div class="figure-contents">
  						
  						<div class="mediaobject"><img src="images/c6s200.gif" alt="Java application module dependency graph"></div>
					</div></div><p><br class="figure-break">
				</p>
				<p>
					<span class="bold"><strong>Cyclic dependencies</strong></span>
				</p>
				<p>
					Cyclic dependencies between modules can be recognized by java compiler:
					</p><pre class="programlisting">
C:\1Z0-817
&#9474;
&#9500;&#9472;&#9472;&#9472;modA
&#9474;       module-info.java
&#9474;
&#9492;&#9472;&#9472;&#9472;modB
        module-info.java
					</pre><p>
					</p><pre class="programlisting">
module modA {
    requires modB;
}
					</pre><p>
					</p><pre class="programlisting">
module modB {
    requires modA;
}
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac --module-source-path . modA\module-info.java -d modA
.\modB\module-info.java:2: error: cyclic dependence involving modA
    requires modA;
             ^
error: cannot access module-info
  cannot resolve modules
modA\module-info.java:1: error: module not found: modB
module modA {
^
3 errors
					</pre><p>
				</p>
				<p>
					Imagine we have the following application:
					</p><pre class="programlisting">
C:\1Z0-817
&#9500;&#9472;&#9472;&#9472;modA
&#9474;   &#9474;   module-info.java
&#9474;   &#9474;
&#9474;   &#9492;&#9472;&#9472;&#9472;pkgA
&#9474;           ClassA.java
&#9474;
&#9492;&#9472;&#9472;&#9472;modB
    &#9474;   module-info.java
    &#9474;
    &#9492;&#9472;&#9472;&#9472;pkgB
            ClassB.java
					</pre><p>
					</p><pre class="programlisting">
module modA {
    requires modB;
    exports pkgA;
}
					</pre><p>
					</p><pre class="programlisting">
package pkgA;

import pkgB.ClassB;

public class ClassA {
    public void methodA1() {    
        new ClassB().methodB2();        
    }
    
    public void methodA2() {
        
    }
}					
					</pre><p>
					</p><pre class="programlisting">
module modB {
    requires modA;
    exports pkgB;
}
					</pre><p>
					</p><pre class="programlisting">
package pkgB;

import pkgA.ClassA;

public class ClassB {
    public void methodB1() {
        new ClassA().methodA2();
    }
    
    public void methodB2() {
    }    
}
					</pre><p>
				</p>
				<p>
					</p><div class="figure"><a name="d5e2745"></a><p class="title"><b>Figure&nbsp;6.5.&nbsp;Java application cyclic dependency graph</b></p><div class="figure-contents">
  						
  						<div class="mediaobject"><img src="images/c6s201.gif" alt="Java application cyclic dependency graph"></div>
					</div></div><p><br class="figure-break">
				</p>
				<p>
					The solutions can be:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Merge <code class="code">pkgA.ClassA</code> and <code class="code">pkgB.ClassB</code> into a single module
							</p>
						</li><li class="listitem">
							<p>
								Break cycle by using interfaces. 
							</p>
						</li></ul></div><p>
				</p>
				<p>
					Let's try the second solution:
				</p>
				<p>
					Add third <code class="code">modC</code> module and refactor all interfaces from class methods which create dependencies:
					</p><pre class="programlisting">
C:\1Z0-817\modC
&#9474;   module-info.java
&#9474;
&#9492;&#9472;&#9472;&#9472;pkgC
        InterfaceA.java
        InterfaceB.java
					</pre><p>
					</p><pre class="programlisting">
module modC {
    exports pkgC;
}
					</pre><p>
					</p><pre class="programlisting">
package pkgC;

public interface InterfaceA {
    public void methodA1();
    public void methodA2();
}

					</pre><p>
					</p><pre class="programlisting">
package pkgC;

public interface InterfaceB {
    public void methodB1();
    public void methodB2();    
}
					</pre><p>
				</p>
				<p>
					Now, refactor <code class="code">modA</code> and <code class="code">modB</code>, to depend not on each other, 
					but both depend on <code class="code">modC</code>.
					</p><pre class="programlisting">
module modA {
    requires modC;
    exports pkgA;
}
					</pre><p>
					</p><pre class="programlisting">
package pkgA;

import pkgC.InterfaceA;
import pkgC.InterfaceB;

public class ClassA implements InterfaceA {
    
    InterfaceB bIntf; 
    
    public ClassA(InterfaceB bIntf) {
        this.bIntf = bIntf;
    }
    
    @Override
    public void methodA1() {    
        bIntf.methodB2();
    }
    
    @Override
    public void methodA2() {        
    }
}
					</pre><p>
					</p><pre class="programlisting">
module modB {
    requires modC;
    exports pkgB;
}
					</pre><p>
					</p><pre class="programlisting">
package pkgB;

import pkgC.InterfaceA;
import pkgC.InterfaceB;

public class ClassB implements InterfaceB {
    
    InterfaceA aIntf;
    
    public ClassB(InterfaceA aIntf) {
        this.aIntf = aIntf;
    }
    
    @Override
    public void methodB1() {
        aIntf.methodA2();
    }
    
    @Override
    public void methodB2() {
    }
}
					</pre><p> 
				</p>
				<p>
					Now you can compile all three modules:
					</p><pre class="programlisting">
javac --module-source-path . modC\module-info.java modC\pkgC\InterfaceA.java modC\pkgC\InterfaceB.java -d .
javac --module-source-path . modA\module-info.java modA\pkgA\ClassA.java -d .
javac --module-source-path . modB\module-info.java modB\pkgB\ClassB.java -d .
					</pre><p>
				</p>
				<p>
					</p><div class="figure"><a name="d5e2776"></a><p class="title"><b>Figure&nbsp;6.6.&nbsp;Java application without cyclic dependency</b></p><div class="figure-contents">
  						
  						<div class="mediaobject"><img src="images/c6s202.gif" alt="Java application without cyclic dependency"></div>
					</div></div><p><br class="figure-break">
				</p>
				<p>
					Create modular JARs:
					</p><pre class="programlisting">
jar cvf modA.jar -C modA .
jar cvf modB.jar -C modB .
jar cvf modC.jar -C modC .
					</pre><p>
				</p>
				<p>
					Inspect dependency graph visually:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jdeps --module-path modA.jar;modB.jar;modC.jar --dot-output . *.jar
					</pre><p>
				</p>
				<p>
					</p><div class="figure"><a name="d5e2786"></a><p class="title"><b>Figure&nbsp;6.7.&nbsp;Java application without cyclic dependency</b></p><div class="figure-contents">
  						
  						<div class="mediaobject"><img src="images/c6s203.gif" alt="Java application without cyclic dependency"></div>
					</div></div><p><br class="figure-break">
				</p>
			</div>
		</div>
		<div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap7"></a>Chapter&nbsp;7.&nbsp;Local-Variable Type Inference</h2></div></div></div>
			
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c7s1"></a>7.1.&nbsp;
					  Use local-variable type inference
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#LVTI_STYLE" title="Style Guidelines for Local Variable Type Inference in Java">[LVTI_STYLE]</a> Style Guidelines for Local Variable Type Inference in Java
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Type inference</strong></span> refers to the automatic detection of 
					the datatype of a variable, done <span class="bold"><strong>at compile time</strong></span>.
				</p>
				<p>
					Local variable type inference is a feature in Java 10.0 that allows the developer to skip the 
					type declaration associated with local variables (those defined inside method definitions, initialization blocks, 
					for-loops, and other blocks like if-else), and the type is inferred by the JDK. It will, then, be the job 
					of the compiler to figure out the datatype of the variable.
				</p>
				<p>
					In Java 11.0 the local variable type inferrence was extended for lambda parameters (see details in the next section).
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Despite the introduction of <code class="code">var</code>, Java is still a statically typed language, and there 
						should be enough information to infer the type of local variable. If not, the compiler will throw 
						an error.
					</p>
					<p>
						The <code class="code">var</code> IS NOT a keyword. Instead, it is a <span class="bold"><strong>reserved type name</strong></span>. This means 
						that existing code that uses <code class="code">var</code> as a variable, method, or package name WILL NOT be affected.
					</p>
					<p>						 
						Existing code that uses <code class="code">var</code> as a class or interface name WILL be affected.
					</p>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Legal type inferrence usage</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								In a static/instance initialization block:
								</p><pre class="programlisting">
class A { 
    static  { 
        var s = "Hello, Java!";         
    }
    
    {
        var s = "Hello, World!";
    }
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								As a local variable in a method:
								</p><pre class="programlisting">
public static void main(String[] args) {
    var s = "Hello, Java!";
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								As iteration variable in enhanced for-loop:
								</p><pre class="programlisting">

List&lt;String&gt; l = List.of("Hello", ", ", "Java!");
for (var s : l) {
    System.out.print(s);
}    

								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								As looping index in for-loop:
								</p><pre class="programlisting">
for (var i = 0; i &lt; 10; i++) {
    System.out.print(i);
}    
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								As a value from another method:							
								</p><pre class="programlisting">
public static void main(String[] args) {
    var x = getId();
}
static int getId() {
  return 1;
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								As a return value in a method:
								</p><pre class="programlisting">
public static void main(String[] args) {
    int x = getId();
}
static int getId() {
    var id = 1;
    return id;
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								As resource variable in the try-with-resource block:
								</p><pre class="programlisting">
public void printFile() throws IOException {
    try (var input = new FileInputStream("file.txt")) {
        ...
    }
}
								</pre><p>
							</p>
						</li></ul></div><p>	
				</p>
				<p>
					<span class="bold"><strong>Illegal type inferrence usage</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Not permitted as class field:
								</p><pre class="programlisting">
public class A {
    static var i = 0;
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								Not permitted as instance variable:
								</p><pre class="programlisting">
public class A {
    var i = 0;
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								Not allowed as local variable without initialization:								
								</p><pre class="programlisting">
public static void main(String[] args) {
    var x;
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								Not allowed as parameter for a method:							
								</p><pre class="programlisting">
public static void main(var[] args) {
    ...
}

public void println(var x) {
    System.out.print(x)
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								Not allowed as method return type in method signature:							
								</p><pre class="programlisting">
public var getId() {
    return 1;
}								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								Not allowed with explicit initialization to <code class="code">null</code>:							
								</p><pre class="programlisting">
public static void main(String[] args) {
    var x = null;
}								</pre><p>
							</p>
							<div class="warning" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Warning]" src="images.admon/warning.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
								<p>
									Can be initialized to <code class="code">null</code> with <span class="bold"><strong>explicit cast</strong></span>:
									</p><pre class="programlisting">
public static void main(String[] args) {
    var x = (Integer) null;  // compiles OK
}
									</pre><p>
								</p>
							</td></tr></table></div>
						</li><li class="listitem">
							<p>
								Not allowed to reassign to a different [incompatible] type:							
								</p><pre class="programlisting">
public static void main(String[] args) {
    var x = 0;  // inferred to be of type int
    x = "Java"; // ERROR - String cannot be converted/assigned to int
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								Not allowed in compound declaration, i.e. when we declare multiple local 
								variables, even with initialization:							
								</p><pre class="programlisting">
public static void main(String[] args) {
    var x, y = 0;
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								Not allowed as lambda expression type (still needs an explicit target type):							
								</p><pre class="programlisting">
public static void main(String[] args) {
    var p = (String[] s) -&gt; s.length &gt; 0;
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								Not allowed with array initializer (an array initializer still needs an 
								explicit target type):
								</p><pre class="programlisting">
public static void main(String[] args) {
    var arr = {1, 2, 3};
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								Not allowed with method reference (still needs an explicit target type):
								</p><pre class="programlisting">
public static void main(String[] args) {
    var unaryOp = String::toLowerCase;
}
								</pre><p>
							</p>
						</li></ul></div><p>
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c7s2"></a>7.2.&nbsp;
					Create and use lambda expressions with local-variable type inferred parameters
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#JEP_323" title="JEP 323: Local-Variable Syntax for Lambda Parameters">[JEP_323]</a> JEP 323: Local-Variable Syntax for Lambda Parameters
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					From Java 11 you can use the <code class="code">var</code> reserved type name as lambda expression parameter type:
					</p><pre class="programlisting">
					
UnaryOperator&lt;String&gt; lc = (var s) -&gt; s.toLowerCase();

					</pre><p>
					The type of the parameter declared with the <code class="code">var</code>  above will be inferred 
					to the type <code class="code">String</code>, because the type declaration of the variable has its 
					generic type set to UnaryOperator&lt;String&gt;, which means that the parameter type and 
					return type of the <code class="code">UnaryOperator</code> is <code class="code">String</code>.
				</p>
				<p>
					<span class="bold"><strong>Legal lambda expression type inferrence usage</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Enables you to add annotations to lambda parameters:
								</p><pre class="programlisting">
					
UnaryOperator&lt;String&gt; lc = (@NonNull var s) -&gt; s.toLowerCase();

								</pre><p>
							</p>
						</li></ul></div><p>
				</p>
				<p>
					<span class="bold"><strong>Illegal lambda expression type inferrence usage</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Not allowed to use <code class="code">var</code> for some parameter and skip for other:
								</p><pre class="programlisting">
					
BiFunction&lt;String, String, String&gt; lc = (var a, b) -&gt; a + b;

								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								Not allowed to mix <code class="code">var</code>  with explicit type:
								</p><pre class="programlisting">
					
BiFunction&lt;String, String, String&gt; lc = (var a, String b) -&gt; a + b;

								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								Not allowed to skip parentheses in single parameter lambda while using <code class="code">var</code>:
								</p><pre class="programlisting">
					
UnaryOperator&lt;String&gt; unaryOp = var s -&gt; s.toLowerCase();

								</pre><p>
							</p>
						</li></ul></div><p>
				</p>
			</div>
		</div>
		<div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap8"></a>Chapter&nbsp;8.&nbsp;Lambda Expressions</h2></div></div></div>
			
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c8s1"></a>8.1.&nbsp;
					 Create and use lambda expressions
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 3, Section 4. Lambda Expressions
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Replacing Anonymous Inner Classes with Lambda Expressions</strong></span>
				</p>
				<p>
					Portions of your code contain anonymous inner classes, which are sometimes difficult to follow. You would like to
					replace anonymous inner classes with code that is easier to read and maintain.
				</p>
				<p>
					Replace the anonymous inner classes with lambda expressions. By doing so, development time will be much faster as
					there will be fewer lines of boilerplate code required. A typical Java Swing application utilizes anonymous inner
					classes to add functionality to application constructs. For instance, anonymous classes are a great way to add
					an action to a button. The problem is that inner classes can be difficult to follow, and they contain lots of
					boilerplate code.
				</p>
				<p>
					The following lines of code demonstrate a typical anonymous inner class implementation for a button action
					implementation. Let's look at these lines of code before taking a look at how you can achieve the same solution using
					a lambda expression.
					</p><pre class="programlisting">
JButton button = ...
JLabel comp = ...

button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        comp.setText("Button has been clicked");
    }
});
					</pre><p>
					In this example, we are creating a new object that provides an implementation of the
					<code class="code">ActionListener</code> interface. This interface has a single method, <code class="code">actionPerformed</code>, which is
					called by the <code class="code">button</code> instance when a user actually clicks the on-screen button. The
					anonymous inner class provides the implementation of this method.
				</p>
				<p>
					Anonymous inner classes were designed to make it easier for Java programmers to pass
					around code as data. Unfortunately, they do not make it easy enough. There are still four
					lines of boilerplate code required in order to call the single line of important logic.
				</p>
				<p>
					Boilerplate is not the only issue, though: this code is fairly hard to read because it obscures
					the programmer's intent. We do not want to pass in an object; what we really want to do
					is pass in some behavior. In Java 8, we would write this code example as a lambda
					expression, as shown in example below:
					</p><pre class="programlisting">
JButton button = ...
JLabel comp = ...

button.addActionListener(e -&gt; comp.setText("Button has been clicked"));
					</pre><p>
				</p>
				<p>
					Instead of passing in an object that implements an interface, we are passing in a block of
					code - a function without a name.
				</p>
				<p>
					The '<code class="code">e</code>' is the name of a parameter (it can be any valid Java identifier), like the parameter
					in the anonymous inner class example.
				</p>
				<p>
					The '<code class="code">-&gt;</code>' separates the parameter from the body of the lambda expression, which is just
					some code that is run when a user clicks the button.
				</p>
				<p>
					Another difference between this example and the anonymous inner class is how we declare the variable
					<code class="code">e</code>. Previously, we needed to explicitly provide its type - <code class="code">ActionEvent e</code>.
					In this example, we have not provided the type at all, yet this example still compiles. What is
					happening under the hood is that Java compiler is <span class="bold"><strong>inferring the
					type of the variable <code class="code">e</code> from its context</strong></span> - here, from the signature
					of <code class="code">addActionListener</code>. It means that you do not need to explicitly write
					out the type when it is obvious.
				</p>
				<div class="warning" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Warning]" src="images.admon/warning.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						In some situations where the Java compiler cannot infer types, you MUST
						explicitly specify values for type variables with type witnesses.
					</p>
				</td></tr></table></div>
				<p>
					Example below demonstrates explicit type declaration (optional for this particular example) of
					lambda method parameter:
					</p><pre class="programlisting">
JButton button = ...
JLabel comp = ...

button.addActionListener((ActionEvent e) -&gt; comp.setText("Button has been clicked"));
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Syntax of Lambda Expressions</strong></span>
				</p>
				<p>
					A lambda expression consists of the following:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								A comma-separated list of formal parameters enclosed in parentheses.
							</p>
							<p>
								Note: You can omit the data type of the parameters in a lambda expression. In addition, you
								can omit the parentheses if there is only one parameter. For example, the following lambda expressions are
								valid:
								</p><pre class="programlisting">
s -&gt; s.getAge() &gt;= 18
								</pre><p>
								</p><pre class="programlisting">
(Student s) -&gt; s.getAge() &gt;= 18
								</pre><p>
								</p><pre class="programlisting">
(s) -&gt; s.getAge() &gt;= 18
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								The arrow token <code class="code">-&gt;</code>
							</p>
						</li><li class="listitem">
							<p>
								A body, which consists of a <span class="bold"><strong>single expression</strong></span> or a
								<span class="bold"><strong>statement block</strong></span>. This example uses the	following expression:
								</p><pre class="programlisting">
... -&gt; s.getAge() &gt;= 18
								</pre><p>
								If you specify a single expression, then the Java runtime evaluates the expression and
								then returns its value. Alternatively, you can use a <code class="code">return</code> statement:
								</p><pre class="programlisting">
... -&gt; { return s.getAge() &gt;= 18; }
								</pre><p>
							</p>
							<p>
								A <code class="code">return</code> statement is NOT an expression; in a lambda expression, you MUST enclose
								statements in braces (<code class="code">{...}</code>). However, you do not have to enclose a <code class="code">void</code>
								method invocation in braces. For example, the following is a valid lambda expression:
								</p><pre class="programlisting">
email -&gt; System.out.println(email)
								</pre><p>
							</p>
						</li></ul></div><p>
				</p>
				<p>
					<span class="bold"><strong><code class="code">java.util.function</code> package summary</strong></span>
				</p>
				<p>
					There are a lot of re-usable functional requirements that can be captured by functional interfaces and lambdas.
					The designers of Java 8.0 have captured the common use cases and created a library of functions for them. A
					new package called <code class="code">java.util.function</code> was created to host these common functions.
				</p>
				<div class="warning" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Warning]" src="images.admon/warning.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Listings of the interfaces provided in this section are not complete. The listings only show
						the most important parts of the source code - signatures of the functional methods.
					</p>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>java.util.function.Predicate</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Parameter type: <code class="code">T</code>
							</p>
						</li><li class="listitem">
							<p>
								Return type: <code class="code">boolean</code>
							</p>
						</li><li class="listitem">
							<p>
								Description: Represents a predicate (boolean-valued function) of one argument.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Predicate&lt;T extends Object&gt; {

    public boolean test(T t);

}

					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>java.util.function.Consumer</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Parameter type: <code class="code">T</code>
							</p>
						</li><li class="listitem">
							<p>
								Return type: <code class="code">void</code>
							</p>
						</li><li class="listitem">
							<p>
								Description: Represents an operation that accepts a single input argument and returns no result.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Consumer&lt;T extends Object&gt; {

    public void accept(T t);

}

					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>java.util.function.Function</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Parameter type: <code class="code">T</code>
							</p>
						</li><li class="listitem">
							<p>
								Return type: <code class="code">R</code>
							</p>
						</li><li class="listitem">
							<p>
								Description: Represents a function that accepts one argument and produces a result.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Function&lt;T extends Object, R extends Object&gt; {

    public R apply(T t);

}

					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>java.util.function.Supplier</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Parameter type: None
							</p>
						</li><li class="listitem">
							<p>
								Return type: <code class="code">T</code>
							</p>
						</li><li class="listitem">
							<p>
								Description: Represents a supplier of results. There is no requirement that a new or
								distinct result be returned each time the supplier is invoked.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Supplier&lt;T extends Object&gt; {

    public T get();
}

					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>java.util.function.ToDoubleFunction</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Parameter type: <code class="code">T</code>
							</p>
						</li><li class="listitem">
							<p>
								Return type: <code class="code">double</code>
							</p>
						</li><li class="listitem">
							<p>
								Description: Represents a function that produces a double-valued result. This is
								the double-producing primitive specialization for <code class="code">Function</code>.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface ToDoubleFunction&lt;T extends Object&gt; {

    public double applyAsDouble(T t);
}

					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>java.util.function.DoubleFunction</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Parameter type: <code class="code">double</code>
							</p>
						</li><li class="listitem">
							<p>
								Return type: <code class="code">R</code>
							</p>
						</li><li class="listitem">
							<p>
								Description: Represents a function that accepts a double-valued argument and produces a
								result. This is the double-consuming primitive specialization for <code class="code">Function</code>.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface DoubleFunction&lt;R extends Object&gt; {

    public R apply(double d);
}

					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>java.util.function.BiPredicate</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Parameter types: <code class="code">T</code>, <code class="code">U</code>
							</p>
						</li><li class="listitem">
							<p>
								Return type: <code class="code">boolean</code>
							</p>
						</li><li class="listitem">
							<p>
								Description: Represents a predicate (boolean-valued function) of two arguments. This
								is the two-arity specialization of <code class="code">Predicate</code>.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface BiPredicate&lt;T extends Object, U extends Object&gt; {

    public boolean test(T t, U u);

}

					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>java.util.function.UnaryOperator</strong></span>
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								Parameter types: <code class="code">T</code>
							</p>
						</li><li class="listitem">
							<p>
								Return type: <code class="code">T</code>
							</p>
						</li><li class="listitem">
							<p>
								Description: Represents an operation on a single operand that produces a result
								of the same type as its operand. This is a specialization of
								<code class="code">Function</code> for the case where the operand and result are of the same type.
							</p>
							<p>
								NOTE: Since it extends <code class="code">Function</code>, it inherits Single Abstract Method -
								<code class="code">Function.apply(Object);</code>, or more accurate <code class="code">T apply(T t);</code>
							</p>
						</li></ul></div><p>
				</p>
				<p>
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface UnaryOperator&lt;T extends Object&gt; extends Function&lt;T, T&gt; {

}

					</pre><p>
				</p>
								
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c8s2"></a>8.2.&nbsp;
					Use lambda expressions and method references
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 3, Section 5. Method and Constructor References
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					Method references can be seen as shorthand for <span class="bold"><strong>lambdas calling only a specific method</strong></span>. 
					The basic idea is that if a lambda represents "call this method directly". It is best to refer to the method by name rather 
					than by a description of how to call it. A method reference lets you create a lambda expression from an existing method
					implementation. By referring to a method name explicitly, your code can gain better readability.
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Lambdas created from constructors are often referred to as constructor references, which are considered for exam to be
						a subset of method references.
					</p>
				</td></tr></table></div>
				<p>
					When you need a method reference, the target reference is placed before the delimiter <code class="code">::</code> and the
					name of the method is provided after it. For example, <code class="code">String::toUpperCase</code> is a method reference to
					the method <code class="code">toUpperCase</code> defined in the <code class="code">String</code> class. The method reference is shorthand
					for the lambda expression <code class="code">(String s) -&gt; s.toUpperCase();</code>.
				</p>
				<div class="warning" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Warning]" src="images.admon/warning.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Remember that no parentheses (round brackets) are needed in method references because you are not actually calling the method.
					</p>
				</td></tr></table></div>
				<p>
					There are four types of method reference:
				</p>
				<p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<span class="bold"><strong>Reference to a static method</strong></span>
							</p>
							<p>
								A non-constructor method reference consists of a qualifier, followed by the <code class="code">::</code> delimiter, followed by an identifier.
								The qualifier is a type for static methods.
							</p>
							<p>
								Syntax:
								</p><pre class="programlisting">
Class::staticMethodName
								</pre><p>
							</p>
							<p>
								Refactoring example:
								</p><pre class="programlisting">

IntFunction&lt;String&gt; f1 = (i) -&gt; String.valueOf(i);
System.out.println(f1.apply(100));

								</pre><p>
								As you can see in the following code, we made reference to <code class="code">valueOf</code> static method in <code class="code">String</code> class:
								</p><pre class="programlisting">

IntFunction&lt;String&gt; f1 = String::valueOf;
System.out.println(f1.apply(100));

								</pre><p>
							</p>
							<p>
								In this case, the method reference is equivalent to a lambda expression that supplies the parameters of the method.
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong>Reference to a constructor</strong></span>
							</p>
							<p>
								A constructor reference consists of a qualifier, followed by the <code class="code">::</code> delimiter, followed by the keyword
								<code class="code">new</code>. The qualifier type must support the creation of instances; for example, it cannot be the name of an
								abstract class or interface.
							</p>
							<p>
								Syntax:
								</p><pre class="programlisting">
ClassName::new
								</pre><p>
							</p>
							<p>
								Refactoring example:
								</p><pre class="programlisting">

Function&lt;char[], String&gt; f1 = (arr) -&gt; new String(arr);
System.out.println(f1.apply(new char[] {'H', 'i'}));

								</pre><p>
								Constructor reference expression <code class="code">String::new</code> equates to lambda expression <code class="code">(char[] arr) -&gt; new String(arr)</code>. A
								lambda for instantiating <code class="code">String</code> is assigned to <code class="code">Function</code>. The subsequent
								<code class="code">Function.apply(...)</code> expression executes this lambda, returning the <code class="code">String</code> instance.
								</p><pre class="programlisting">

Function&lt;char[], String&gt; f1 = String::new;
System.out.println(f1.apply(new char[] {'H', 'i'}));

								</pre><p>
							</p>
							<p>
								In a constructor reference expression, you do not specify the exact constructor. Instead, you simply write <code class="code">::new</code>. When
								a class declares multiple constructors, the compiler will check the type of the functional interface with all of the constructors
								and choose the best match.
								</p><pre class="programlisting">

// Java compiler infers the right constructor to call based
// on the context in which the constructor reference appears

Function&lt;char[], String&gt;       f1 = String::new;
Function&lt;StringBuffer, String&gt; f2 = String::new;

System.out.println(f1.apply(new char[] {'H', 'i'}));
System.out.println(f2.apply(new StringBuffer().append("Hello")));

								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong>Reference to an instance method of an arbitrary object of a particular type</strong></span>
							</p>
							<p>
								Syntax:
								</p><pre class="programlisting">
Class::instanceMethodName
								</pre><p>
							</p>
							<p>
								Reference to an instance method of an arbitrary object of a particular type refers to a non-static method that is not bound
								to a receiver. For example, <code class="code">String::trim</code> is a non-static method reference that identifies the non-
								static <code class="code">trim()</code> method of the <code class="code">String class</code>. Because a non-static method requires a target
								object, which in this example is a <code class="code">String</code> object, <code class="code">trim()</code> will be invoked on this object.
							</p>
							<div class="warning" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Warning]" src="images.admon/warning.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
								<p>
									This can be a little confusing. So we are calling a non-static method but using a class name. Actually
									<span class="bold"><strong>the instance of the class is passed when the method is called</strong></span>.
								</p>
							</td></tr></table></div>
							<p>
								<code class="code">String::trim</code> is equivalent to lambda <code class="code">(String str) -&gt; { return str.trim(); }</code>.
							</p>
							<p>
								In this type of method references, the first parameter becomes the target of the method. For example,
								<code class="code">String::compareToIgnoreCase</code> is the same as <code class="code">(x, y) -&gt; x.compareToIgnoreCase(y)</code>.
							</p>
							<p>
								Refactoring example:
								</p><pre class="programlisting">

BiFunction&lt;String, String, Boolean&gt; f1 = (s1, s2) -&gt; s1.equalsIgnoreCase(s2);
System.out.println(f1.apply("Hello", "HELLO"));

								</pre><p>
								</p><pre class="programlisting">

BiFunction&lt;String, String, Boolean&gt; f1 = String::equalsIgnoreCase;
System.out.println(f1.apply("Hello", "HELLO"));

								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong>Reference to an instance method of a particular object</strong></span>
							</p>
							<p>
								Syntax:
								</p><pre class="programlisting">
object::instanceMethodName
								</pre><p>
							</p>
							<p>
								Reference to an instance method of a particular object refers to a non-static method that is bound to a receiver.
							</p>
							<p>
								For example, <code class="code">System.out::printf</code> is a non-static method reference that identifies the <code class="code">printf(String format, Object args...)</code>
								method of the <code class="code">java.io.PrintStream</code> class. This method is bound to the <code class="code">System.out</code> (standard output stream) object
								(the receiver) and will be invoked on this object. <code class="code">System.out::printf</code> is equivalent to this lambda:
								</p><pre class="programlisting">
(String fmt, Object... args) -&gt; System.out.printf(fmt, args);
								</pre><p>
							</p>
							<div class="warning" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Warning]" src="images.admon/warning.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
								<p>
									This kind of method references refers to a situation when you are calling a method in a lambda to an <span class="bold"><strong>external
									object that already exists</strong></span>. For example, the lambda expression <code class="code">() -&gt; object.toString()</code> can be rewritten as
									<code class="code">object::toString</code>.
								</p>
							</td></tr></table></div>
							<p>
								Refactoring example:
								</p><pre class="programlisting">

Integer i = new Integer(1);

Supplier&lt;String&gt; f1 = () -&gt; i.toString();
System.out.println(f1.get());

								</pre><p>
								</p><pre class="programlisting">

Integer i = new Integer(1);

Supplier&lt;String&gt; f1 = i::toString;
System.out.println(f1.get());

								</pre><p>
							</p>
						</li></ul></div><p>
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c8s3"></a>8.3.&nbsp;
					Use built-in functional interfaces including <code class="code">Predicate</code>, <code class="code">Consumer</code>, <code class="code">Function</code>, and <code class="code">Supplier</code>
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#JAVA_UTIL_FUNCTION" title="Java SE 11 Java Doc - Package java.util.function">[JAVA_UTIL_FUNCTION]</a> Java SE 11 Java Doc - Package java.util.function
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Develop code that uses the <code class="code">Function</code> interface</strong></span>
				</p>
				<p>
					A <code class="code">java.util.function.Function</code> is a Java 8 functional interface whose sole purpose is to return any result
					by working on a single input argument. It accepts an argument of type <code class="code">T</code> and returns a result of type
					<code class="code">R</code>, by applying specified logic on the input via the <code class="code">apply</code> method. The
					interface definition shown here:
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Function&lt;T extends Object, R extends Object&gt; {

    public R apply(T t);

    ...

}

					</pre><p>
				</p>
				<p>
					A <code class="code">Function</code> interface is used in cases when you want to encapsulate some code into a method which accepts some value as
					an input parameter and then returns another value after performing required operations on the input. The input parameter type and
					the return type of the method can either be same or different:
					</p><pre class="programlisting">

Function&lt;String, Boolean&gt; f = s -&gt; new Boolean(s);

System.out.println(f.apply("TRUE"));
System.out.println(f.apply("true"));
System.out.println(f.apply("Java8"));
System.out.println(f.apply(null));

					</pre><p>
					Output:
					</p><pre class="programlisting">
true
true
false
false
					</pre><p>
				</p>				
				<p>
					<span class="bold"><strong>Develop code that uses the <code class="code">Consumer</code> interface</strong></span>
				</p>
				<p>
					The <code class="code">java.util.function.Consumer&lt;T&gt;</code> interface defines an <code class="code">abstract</code> method
					named <code class="code">accept</code> that takes an object of generic type <code class="code">T</code> and returns no result
					(<code class="code">void</code>):
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Consumer&lt;T extends Object&gt; {

    public void accept(T t);

    ...
}

					</pre><p>
				</p>
				<p>
					You might use this interface when you need to access an object of type <code class="code">T</code> and
					perform some operations on it. For example, you can use it to create a method <code class="code">processList</code>,
					which takes a list of objects and applies an operation on each
					element of that list. In the following listing you use this <code class="code">processList</code> method combined with a
					lambda to print all the elements of the list:
					</p><pre class="programlisting">

public class ConsumerDemo&lt;T extends Object&gt; {

    public void processList(List&lt;T&gt; list, Consumer&lt;T&gt; cons) {
        for(T s : list) {
            cons.accept(s);
        }
    }

    public static void main(String[] args) {
        List&lt;String&gt; l = Arrays.asList(new String[] {"Java", "8", "is", "great", "!"});
        Consumer&lt;String&gt; c = s -&gt; System.out.print(String.format("%s ", s));
        new ConsumerDemo&lt;String&gt;().processList(l, c);
    }
}

					</pre><p>
					output is:
					</p><pre class="programlisting">
Java 8 is great !
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Develop code that uses the <code class="code">Supplier</code> interface</strong></span>
				</p>
				<p>
					The <code class="code">java.util.function.Supplier&lt;T&gt;</code> is a functional interface in Java 8, with one <code class="code">abstract</code>
					method named <code class="code">T get()</code> that returns an instance of <code class="code">T</code>. In other words, this is a factory that
					keeps on giving without expecting anything as input.
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Supplier&lt;T extends Object&gt; {

    public T get();

}
					</pre><p>
				</p>
				<p>
					In the most basic form a <code class="code">Supplier</code> will return an instance. For example, we could implement
					<code class="code">Supplier&lt;Book&gt;</code> to return an instance of <code class="code">Book</code>, like so:
					</p><pre class="programlisting">

public class Book {
    String title;
    String author;

    public Book(String t, String a) {
        title = t;
        author = a;
    }

    public String toString() {
        return title + " by " + author;
    }
}

...
...
Supplier&lt;Book&gt; s1 = () -&gt; new Book("Upgrade to Java 8 Guide", "Mikalai Zaikin");
Supplier&lt;Book&gt; s2 = () -&gt; { return new Book("Upgrade to Java 11 Guide", "Mikalai Zaikin"); };

System.out.println(s1.get());
System.out.println(s2.get());

					</pre><p>
					output:
					</p><pre class="programlisting">
Upgrade to Java 8 Guide by Mikalai Zaikin
Upgrade to Java 11 Guide by Mikalai Zaikin
					</pre><p>
					Alternatively, we could use a constructor reference (<code class="code">T::new</code>) instead of the traditional
					(<code class="code">new T()</code>) syntax to instantiate an instance. A constructor reference is much like a
					method reference, except it is a reference to a constructor instead of a method.
					We can use a constructor reference anywhere a lambda expression does
					nothing more than instantiate an instance. The only limitation with <code class="code">Supplier</code>
					that constructor must take no arguments. For example:
					</p><pre class="programlisting">

public class Book {
    String title;
    String author;

    public Book() {
        title = "Default title";
        author = "Default author";
    }

    public String toString() {
        return title + " by " + author;
    }
}
...
...
Supplier&lt;Book&gt; s1 = Book::new;
System.out.println(s1.get());

					</pre><p>
					output:
					</p><pre class="programlisting">
Default title by Default author
					</pre><p>
				</p>
				<p>
					 <span class="bold"><strong>Develop code that uses the <code class="code">UnaryOperator</code> interface</strong></span>
				</p>
				<p>
					The <code class="code">java.util.function.UnaryOperator</code> is a Java 8 functional interface that extends
					<code class="code">java.util.function.Function</code>:
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface UnaryOperator&lt;T extends Object&gt; extends Function&lt;T, T&gt; {

    ...

}

					</pre><p>
					The <code class="code">UnaryOperator</code> is used to work on a single
					operand and it returns the same type as an operand. <code class="code">UnaryOperator</code> can be used as
					lambda expression to pass as an argument. While defining <code class="code">UnaryOperator</code>, we need to define
					<code class="code">T apply(T t)</code> method inherited from <code class="code">java.util.function.Function</code>.
					</p><pre class="programlisting">

UnaryOperator&lt;String&gt; uo = s -&gt; s + " is great !";
System.out.print(uo.apply("Java 11"));

					</pre><p>
					output:
					</p><pre class="programlisting">
Java 11 is great !
					</pre><p>
				</p>
				<p>
					 <span class="bold"><strong>Develop code that uses the <code class="code">Predicate</code> interface</strong></span>
				</p>
				<p>
					The <code class="code">java.util.function.Predicate&lt;T&gt;</code> interface defines an abstract method named
					<code class="code">test(T t)</code> that accepts an object of generic type <code class="code">T</code> and returns a
					<code class="code">boolean</code> primitive.
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Predicate&lt;T extends Object&gt; {

    public boolean test(T t);

    ...

}

					</pre><p>
				</p>
				<p>
					You might want to use this interface when you need to represent a <code class="code">boolean</code> expression that uses an object
					of type <code class="code">T</code>. For example, you can define a lambda that accepts <code class="code">String</code> objects,
					as shown in the following listing:
					</p><pre class="programlisting">

Predicate&lt;String&gt; longString = s -&gt; s.length() &gt; 5;

// Will print true
System.out.print(longString.test("Hi there !"));

					</pre><p>
				</p>
				<p>
					Predicates may also be passed into functions:
					</p><pre class="programlisting">

Predicate&lt;String&gt; longString = s -&gt; s.length() &gt; 5;
validateString("Hello again !", longString);
...
...
void validateString(String s, Predicate&lt;String&gt; p) {
    if (p.test(s)) {
        System.out.print("Test passed !");
    }
}

					</pre><p>
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c8s4"></a>8.4.&nbsp;
					Use primitive and binary variations of base interfaces of <code class="code">java.util.function</code> package
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#JAVA_UTIL_FUNCTION" title="Java SE 11 Java Doc - Package java.util.function">[JAVA_UTIL_FUNCTION]</a> Java SE 11 Java Doc - Package java.util.function
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					Every Java type is either a reference type (for example, <code class="code">String</code>, <code class="code">Integer</code>, <code class="code">Object</code>,
					<code class="code">List</code>) or a primitive type (for example, <code class="code">int</code>, <code class="code">double</code>, <code class="code">byte</code>, <code class="code">char</code>).
					But generic parameters (for example, the <code class="code">T</code> in <code class="code">Consumer&lt;T&gt;</code>) can be bound only to reference types.
					This is due to how generics are internally implemented.
				</p>
				<p>
					As a result, in Java there is a mechanism to convert a primitive type into a corresponding reference type. This mechanism is called
					boxing. The opposite approach (that is, converting a reference type into a corresponding primitive type) is called unboxing. Java
					also has an autoboxing mechanism to facilitate the task for programmers: boxing and unboxing operations are done automatically. For
					example, this is why the following code is valid (a <code class="code">double</code> gets boxed to a <code class="code">Double</code>):
					</p><pre class="programlisting">

List&lt;Double&gt; list = new ArrayList&lt;&gt;();
list.add(12.34);
list.add(56.78);

					</pre><p>
				</p>
				<p>
					But this comes with a performance cost. Boxed values are essentially a wrapper around primitive types and are stored on the heap.
					Therefore, boxed values use more memory and require additional memory lookups to fetch the wrapped primitive value. Java 8 brings
					a specialized version of the functional interfaces in order to avoid autoboxing operations when the inputs or outputs are primitives.
					For example, in the following code, using an <code class="code">IntPredicate</code> avoids a boxing operation of the value <code class="code">1974</code>:
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface IntPredicate {

    public boolean test(int i);

    ...
}


					</pre><p>
					</p><pre class="programlisting">

IntPredicate ip = i -&gt; i == 1974;
ip.test(1974);

					</pre><p>
					whereas using a <code class="code">Predicate&lt;Integer&gt;</code> would box the argument <code class="code">1974</code> to an <code class="code">Integer</code> object:
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Predicate&lt;T extends Object&gt; {

    public boolean test(T t);

    ...
}


					</pre><p>
					</p><pre class="programlisting">

Predicate&lt;Integer&gt; p = i -&gt; i == 1974;
p.test(1974);

					</pre><p>
				</p>
				<p>
					In general, the names of functional interfaces that have a specialization for the <span class="bold"><strong>input type parameter</strong></span> are preceded by
					the appropriate primitive type, for example, <code class="code">DoublePredicate</code>, <code class="code">IntConsumer</code>,
					<code class="code">LongBinaryOperator</code>, <code class="code">IntFunction</code>, and so on.
				</p>
				<p>
					The <code class="code">Function</code> interface has also variants for the <span class="bold"><strong>output type parameter</strong></span>:
					<code class="code">ToIntFunction&lt;T&gt;</code>, <code class="code">ToDoubleFunction&lt;T&gt;</code>, and so on.
				</p>
				<p>
					</p><div class="table"><a name="d5e3341"></a><p class="title"><b>Table&nbsp;8.1.&nbsp;
							Common functional interfaces in Java 8
						</b></p><div class="table-contents">
						
						
						<table class="table" summary="&#xA;Common functional interfaces in Java 8&#xA;" cellspacing="0" cellpadding="5" border="1" width="80%"><colgroup><col width="20%" align="left" class="col1"><col width="20%" align="left" class="col2"><col width="60%" align="left" class="col3"></colgroup><thead><tr><th align="left">Functional interface</th><th align="left">Function descriptor</th><th align="left">Primitive specializations</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top">
							    		<p>
							    			<code class="code">Predicate&lt;T&gt;</code>
								    	</p>
						   			</td><td align="left" valign="top">
								    	<p>
								    		<code class="code">T -&gt; boolean</code>
								    	</p>
								    </td><td align="left" valign="top">
								    	<p>
								    		<code class="code">IntPredicate</code> - Predicate of one <code class="code">int</code>-valued argument.
								    	</p>
								    	<p>
								    		<code class="code">LongPredicate</code> - Predicate of one <code class="code">long</code>-valued argument.
								    	</p>
								    	<p>
								    		<code class="code">DoublePredicate</code> - Predicate of one <code class="code">double</code>-valued argument.
								    	</p>
								    </td></tr><tr><td align="left" valign="top">
							    		<p>
							    			<code class="code">Consumer&lt;T&gt;</code>
								    	</p>
						   			</td><td align="left" valign="top">
								    	<p>
								    		<code class="code">T -&gt; void</code>
								    	</p>
								    </td><td align="left" valign="top">
								    	<p>
								    		<code class="code">IntConsumer</code> - Function operation that accepts a single <code class="code">int</code>-valued argument and returns no result.
								    	</p>
								    	<p>
								    		<code class="code">LongConsumer</code> - Function operation that accepts a single <code class="code">long</code>-valued argument and returns no result.
								    	</p>
								    	<p>
								    		<code class="code">DoubleConsumer</code> - Function operation that accepts a single <code class="code">double</code>-valued argument and returns no result.
								    	</p>
								    </td></tr><tr><td align="left" valign="top">
							    		<p>
							    			<code class="code">Function&lt;T, R&gt;</code>
								    	</p>
						   			</td><td align="left" valign="top">
								    	<p>
								    		<code class="code">T -&gt; R</code>
								    	</p>
								    </td><td align="left" valign="top">
								    	<p>
								    		<code class="code">IntFunction&lt;R&gt;</code> - Function that accepts an <code class="code">int</code>-valued argument and produces a result.
								    	</p>
								    	<p>
								    		<code class="code">IntToDoubleFunction</code> - Function that accepts an <code class="code">int</code>-valued argument and produces a
								    		<code class="code">double</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">IntToLongFunction</code> - Function that accepts an <code class="code">int</code>-valued argument and produces a
								    		<code class="code">long</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">LongFunction&lt;R&gt;</code> - Function that accepts a <code class="code">long</code>-valued argument and produces a result.
								    	</p>
								    	<p>
								    		<code class="code">LongToDoubleFunction</code> - Function that accepts a <code class="code">long</code>-valued argument and produces a
								    		<code class="code">double</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">LongToIntFunction</code> - Function that accepts a <code class="code">long</code>-valued argument and produces an
								    		<code class="code">int</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">DoubleFunction&lt;R&gt;</code> - Function that accepts a <code class="code">double</code>-valued argument and produces a result.
								    	</p>
								    	<p>
								    		<code class="code">ToIntFunction&lt;T&gt;</code> - Function that produces an <code class="code">int</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">ToDoubleFunction&lt;T&gt;</code> - Function that produces a <code class="code">double</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">ToLongFunction&lt;T&gt;</code> - Function that produces a <code class="code">long</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">DoubleToIntFunction;</code> - Function that accepts a <code class="code">double</code>-valued argument and produces an <code class="code">int</code>-valued
								    		result.
								    	</p>
								    	<p>
								    		<code class="code">DoubleToLongFunction</code> - Function that accepts a <code class="code">double</code>-valued argument and produces a
								    		<code class="code">long</code>-valued result.
								    	</p>
								    </td></tr><tr><td align="left" valign="top">
							    		<p>
							    			<code class="code">Supplier&lt;T&gt;</code>
								    	</p>
						   			</td><td align="left" valign="top">
								    	<p>
								    		<code class="code">() -&gt; T</code>
								    	</p>
								    </td><td align="left" valign="top">
								    	<p>
								    		<code class="code">BooleanSupplier</code> - Supplier of <code class="code">boolean</code>-valued results.
								    	</p>
								    	<p>
								    		<code class="code">IntSupplier</code> - Supplier of <code class="code">int</code>-valued results.
								    	</p>
								    	<p>
								    		<code class="code">LongSupplier</code> - Supplier of <code class="code">long</code>-valued results.
								    	</p>
								    	<p>
								    		<code class="code">DoubleSupplier</code> - Supplier of <code class="code">double</code>-valued results.
								    	</p>
								    </td></tr><tr><td align="left" valign="top">
							    		<p>
							    			<code class="code">UnaryOperator&lt;T&gt;</code>
								    	</p>
						   			</td><td align="left" valign="top">
								    	<p>
								    		<code class="code">T -&gt; T</code>
								    	</p>
								    </td><td align="left" valign="top">
								    	<p>
								    		<code class="code">IntUnaryOperator</code> - Function operation on a single <code class="code">int</code>-valued operand that produces
								    		an <code class="code">int</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">LongUnaryOperator</code> - Function operation on a single <code class="code">long</code>-valued operand that produces
								    		a <code class="code">long</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">DoubleUnaryOperator</code> - Function operation on a single <code class="code">double</code>-valued operand that
								    		produces a <code class="code">double</code>-valued result.
								    	</p>
								    </td></tr><tr><td align="left" valign="top">
							    		<p>
							    			<code class="code">BinaryOperator&lt;T&gt;</code>
								    	</p>
						   			</td><td align="left" valign="top">
								    	<p>
								    		<code class="code">(T, T) -&gt; T</code>
								    	</p>
								    </td><td align="left" valign="top">
								    	<p>
								    		<code class="code">IntBinaryOperator</code> - Function operation upon two <code class="code">int</code>-valued operands and producing an
								    		<code class="code">int</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">LongBinaryOperator</code> - Function operation upon two <code class="code">long</code>-valued operands and producing a
								    		<code class="code">long</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">DoubleBinaryOperator</code> - Function operation upon two <code class="code">double</code>-valued operands and producing
											a <code class="code">double</code>-valued result.
								    	</p>
								    </td></tr><tr><td align="left" valign="top">
							    		<p>
							    			<code class="code">BiPredicate&lt;L, R&gt;</code>
								    	</p>
						   			</td><td align="left" valign="top">
								    	<p>
								    		<code class="code">(L, R) -&gt; boolean</code>
								    	</p>
								    </td><td align="left" valign="top">
								    	<p>
											none
								    	</p>
								    </td></tr><tr><td align="left" valign="top">
							    		<p>
							    			<code class="code">BiConsumer&lt;T, U&gt;</code>
								    	</p>
						   			</td><td align="left" valign="top">
								    	<p>
								    		<code class="code">(T, U) -&gt; void</code>
								    	</p>
								    </td><td align="left" valign="top">
								    	<p>
								    		<code class="code">ObjIntConsumer&lt;T&gt;</code> - Function operation that accepts an <code class="code">Object</code>-valued and an <code class="code">int</code>-valued
								    		argument and returns no result.
								    	</p>
								    	<p>
								    		<code class="code">ObjLongConsumer&lt;T&gt;</code> - Function operation that accepts an <code class="code">Object</code>-valued and a <code class="code">long</code>-valued
								    		argument and returns no result.
								    	</p>
								    	<p>
								    		<code class="code">ObjDoubleConsumer&lt;T&gt;</code> - Function operation that accepts an <code class="code">Object</code>-valued and a <code class="code">double</code>-valued
								    		argument and returns no result.
								    	</p>
								    </td></tr><tr><td align="left" valign="top">
							    		<p>
							    			<code class="code">BiFunction&lt;T, U, R&gt;</code>
								    	</p>
						   			</td><td align="left" valign="top">
								    	<p>
								    		<code class="code">(T, U) -&gt; R</code>
								    	</p>
								    </td><td align="left" valign="top">
								    	<p>
								    		<code class="code">ToIntBiFunction&lt;T, U&gt;</code> - Function that accepts two arguments and produces an <code class="code">int</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">ToLongBiFunction&lt;T, U&gt;</code> - Function that accepts two arguments and produces a <code class="code">long</code>-valued result.
								    	</p>
								    	<p>
								    		<code class="code">ToDoubleBiFunction&lt;T, U&gt;</code> - Function that accepts two arguments and produces a <code class="code">double</code>-valued result.
								    	</p>
								    </td></tr></tbody></table>
					</div></div><p><br class="table-break">
				</p>
			</div>
		</div>
		<div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap9"></a>Chapter&nbsp;9.&nbsp;Parallel Streams</h2></div></div></div>
			
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c9s1"></a>9.1.&nbsp;
					 Develop the code that use parallel streams
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 8. Section 14. Parallel Streams.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Parallel Streams</strong></span>
				</p>
				<p>
					Streams can be sequential or parallel. Operations on a sequential stream are processed in serial using one thread.
					Operations on a parallel stream are processed in parallel using multiple threads. You do not need to take additional
					steps to process streams because they are sequential or parallel. All you need to do is call the appropriate method that
					produces sequential or parallel stream. Everything else is taken care of by the Streams API
				</p>
				<p>
					Most of the methods in the Streams API produce sequential streams by default. To produce a parallel stream
					from a collection such as a <code class="code">List</code> or a <code class="code">Set</code>, you need to call the
					<code class="code">parallelStream()</code> method of the <code class="code">Collection</code> interface.
				</p>
				<p>
					Use the <code class="code">parallel()</code> method on a stream to convert a sequential stream into a parallel stream. Conversely, use the
					<code class="code">sequential()</code> method on a stream to convert a parallel stream into a sequential stream.
				</p>
				<p>
					The following snippet of code shows serial processing of the stream pipeline because the stream is sequential:
					</p><pre class="programlisting">

List&lt;Integer&gt; listOfIntegers = List.of(1, 2, 3, 4, 5, 6, 7, 8);

System.out.println("Sequential Stream: ");
listOfIntegers
    .stream()
    .forEach(e -&gt; System.out.print(e + " "));

					</pre><p>
					output is:
					</p><pre class="programlisting">
Sequential Stream:
1 2 3 4 5 6 7 8
					</pre><p>
				</p>
				<p>
					The following snippet of code shows parallel processing of the stream pipeline because the stream is parallel:
					</p><pre class="programlisting">

List&lt;Integer&gt; listOfIntegers = List.of(1, 2, 3, 4, 5, 6, 7, 8);

System.out.println("Parallel Stream: ");
listOfIntegers
    .stream()
    .parallel()
    .forEach(e -&gt; System.out.print(e + " "));

					</pre><p>
					output is (every time new order):
					</p><pre class="programlisting">
Parallel Stream:
6 5 7 4 2 1 8 3
					</pre><p>
					You could also use this code:
					</p><pre class="programlisting">
...
listOfIntegers
    .parallelStream()
    .forEach(e -&gt; System.out.print(e + " "));
...
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Besides being <span class="emphasis"><em>parallel</em></span> or <span class="emphasis"><em>sequential</em></span>, a stream also can be 
						<span class="emphasis"><em>ordered</em></span> or <span class="emphasis"><em>unordered</em></span>.
					</p>
				</td></tr></table></div>
				<p>
					Streams may or may not have a defined <span class="bold"><strong>encounter order</strong></span>. Whether or not a stream has an encounter order 
					depends on the source and the intermediate operations. Certain stream sources (such as <code class="code">List</code> or arrays) are 
					intrinsically ordered, whereas others (such as HashSet) are not. Some intermediate operations, such as <code class="code">sorted()</code>, 
					may impose an encounter order on an otherwise unordered stream, and others may render an ordered stream unordered, 
					such as <code class="code">BaseStream.unordered()</code>. Further, some terminal operations may ignore encounter order, such as 
					<code class="code">forEach()</code>.
				</p>
				<p>
					If a stream is ordered, most operations are constrained to operate on the elements in their encounter order; if 
					the source of a stream is a <code class="code">List</code> containing <code class="code">[1, 2, 3]</code>, then the result of executing 
					<code class="code">map(x -&gt; x*2)</code> must be <code class="code">[2, 4, 6]</code>. However, if the source has no defined encounter order, 
					then any permutation of the values <code class="code">[2, 4, 6]</code> would be a valid result.
				</p>
				<p>
					For sequential streams, the presence or absence of an encounter order does not affect performance, only determinism. 
					If a stream is ordered, repeated execution of identical stream pipelines on an identical source will produce an 
					identical result; if it is not ordered, repeated execution might produce different results.
				</p>
				<p>
					For parallel streams, relaxing the ordering constraint can sometimes enable more efficient execution. Certain 
					aggregate operations, such as filtering duplicates (<code class="code">distinct()</code>) or grouped reductions 
					(<code class="code">Collectors.groupingBy()</code>) can be implemented more efficiently if ordering of elements is not 
					relevant. Similarly, operations that are intrinsically tied to encounter order, such as <code class="code">limit()</code>, 
					may require buffering to ensure proper ordering, undermining the benefit of parallelism. In cases where the stream 
					has an encounter order, but the user does not particularly care about that encounter order, explicitly 
					de-ordering the stream with <code class="code">unordered()</code> may improve parallel performance for some stateful or 
					terminal operations. However, most stream pipelines, such as the "sum of weight of blocks" example above, 
					still parallelize efficiently even under ordering constraints.
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c9s2"></a>9.2.&nbsp;
					Implement decomposition and reduction with streams
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 8. Section 12. Reduction Operations.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Reduction</strong></span>
				</p>
				<p>
					The <code class="code">reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code> method of the <code class="code">Stream</code> interface
					performs a reduction operation on the stream to reduce the stream to a single value. It takes an initial value and
					an accumulator that is a <code class="code">BinaryOperator&lt;T&gt;</code> as arguments. The first time, the accumulator receives
					the initial value and the first element of the stream as arguments, and returns a value. The second time, the
					accumulator receives the value returned from its previous call and the second element from the stream. This process
					continues until all elements of the stream have been passed to the accumulator.
				</p>
				<p>
					The returned value from the last call of the accumulator is returned from the <code class="code">reduce(...)</code> method. The
					following snippet of code performs the summation of all integers in the stream:
					</p><pre class="programlisting">

List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8);
Integer sum = numbers.stream().reduce(0, (n1, n2) -&gt; n1 + n2); // must be 36
System.out.print("Sum of all integers in the stream : " + sum);

					</pre><p>
					The <code class="code">Integer</code> class contains a static <code class="code">sum(...)</code> method to perform sum of two integers. You can
					rewrite the code using a method reference, like so:
					</p><pre class="programlisting">
Integer sum = numbers.stream().reduce(0, Integer::sum);
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Reduction operations</strong></span>
				</p>
				<p>
					A <span class="bold"><strong>reduction operation</strong></span> (also called a <span class="bold"><strong>fold</strong></span>) takes 
					a sequence of input elements and combines them into a single summary result by repeated application of a combining 
					operation, such as finding the sum or maximum of a set of numbers, or accumulating elements into a list. The 
					streams classes have multiple forms of general reduction operations, called <code class="code">reduce()</code> and <code class="code">collect()</code>, 
					as well as multiple specialized reduction forms such as <code class="code">sum()</code>, <code class="code">max()</code>, or <code class="code">count()</code>.
				</p>
				<p>
					Of course, such operations can be readily implemented as simple sequential loops, as in:
					</p><pre class="programlisting">
int sum = 0;
for (int x : numbers) {
    sum += x;
}
					</pre><p>
					However, there are good reasons to prefer a reduce operation over a mutative accumulation such as the above. Not only 
					is a reduction "more abstract" -- it operates on the stream as a whole rather than individual elements -- but a 
					properly constructed reduce operation is inherently parallelizable, so long as the function(s) used to process 
					the elements are associative and stateless. For example, given a stream of numbers for which we want to find 
					the sum, we can write:
					</p><pre class="programlisting">
int sum = numbers.stream().reduce(0, (x, y) -&gt; x + y);
					</pre><p>
					or:
					</p><pre class="programlisting">
int sum = numbers.stream().reduce(0, Integer::sum);
					</pre><p>
					These reduction operations can run safely in parallel with almost no modification:
					</p><pre class="programlisting">
int sum = numbers.parallelStream().reduce(0, Integer::sum);
					</pre><p>
				</p>
				<p>
					Reduction parallellizes well because the implementation can operate on subsets of the data in parallel, and then combine 
					the intermediate results to get the final correct answer. (Even if the language had a "parallel for-each" construct, 
					the mutative accumulation approach would still required the developer to provide thread-safe updates to the shared 
					accumulating variable sum, and the required synchronization would then likely eliminate any performance gain from parallelism.) 
					Using <code class="code">reduce()</code> instead removes all of the burden of parallelizing the reduction operation, and the library 
					can provide an efficient parallel implementation with no additional synchronization required.
				</p>
				<p>
					In its more general form, a reduce operation on elements of type &lt;T&gt; yielding a result of type &lt;U&gt; requires 
					three parameters:
					</p><pre class="programlisting">

 &lt;U&gt; U reduce(U identity,
     BiFunction&lt;U, ? super T, U&gt; accumulator,
     BinaryOperator&lt;U&gt; combiner);
					
					</pre><p>
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								The <span class="emphasis"><em>identity</em></span> element is both an initial seed value for the reduction and a default result if 
								there are no input elements.
							</p>
						</li><li class="listitem">
							<p>
								The <span class="emphasis"><em>accumulator</em></span> function takes a partial result and the next element, 
								and produces a new partial result.
							</p>
						</li><li class="listitem">
							<p>
								The <span class="emphasis"><em>combiner</em></span> function combines two partial results to produce 
								a new partial result. (The combiner is necessary in parallel reductions, where the input is partitioned, a partial 
								accumulation computed for each partition, and then the partial results are combined to produce a final result.)
							</p>
						</li></ul></div><p>					
				</p>
				<p>
					The code to sum all the integers in a stream can be rewritten as follows:
					</p><pre class="programlisting">

List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8);
Integer sum = numbers.stream().reduce(0, 
    (res, i) -&gt; res + i,                  // adds one element's value to partial result
    (part1, part2) -&gt; part1 + part2);     // combine two partial results
System.out.print("Sum of all integers in the stream : " + sum);

					</pre><p>					 
				</p>
			</div>
		</div>		
		<div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap10"></a>Chapter&nbsp;10.&nbsp;Language Enhancements</h2></div></div></div>
			
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c10s1"></a>10.1.&nbsp;
					 Use try-with-resources construct
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#TRY_WITH_RESOURCE_TECHNOTE" title="The try-with-resources Statement">[TRY_WITH_RESOURCE_TECHNOTE]</a> The try-with-resources Statement
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					The <span class="bold"><strong>try-with-resources statement</strong></span> is a <code class="code">try</code> statement that
					<span class="bold"><strong>declares</strong></span> one or more resources.
				</p>
				<p>
					A resource is as an object that must be closed after the program is finished with it. The try-with-resources
					statement ensures that each resource is closed at the end of the statement. Any object that implements <code class="code">java.lang.AutoCloseable</code>
					can be used as a resource:
					</p><pre class="programlisting">
package java.lang;

public interface AutoCloseable {
    void close() throws Exception;
}
					</pre><p>
					The <code class="code">java.io.Closeable</code> interface extends the <code class="code">java.lang.AutoCloseable</code> interface. The <code class="code">close()</code> 
					method of the <code class="code">Closeable</code> interface throws exceptions of type <code class="code">IOException</code> while the <code class="code">close()</code> 
					method of the <code class="code">AutoCloseable</code> interface throws exceptions of type <code class="code">Exception</code>. Consequently, subclasses 
					of the <code class="code">AutoCloseable</code> interface can override this behavior of the <code class="code">close()</code> method to throw 
					specialized exceptions, such as <code class="code">IOException</code>, or no exception at all.
					</p><pre class="programlisting">
package java.io;

import java.io.IOException;

public interface Closeable extends AutoCloseable {
    public void close() throws IOException;
}
					</pre><p>
				</p>
				<p>
					The following example reads the first line from a file. It uses an instance of <code class="code">BufferedReader</code> to read data from the file.
					<code class="code">BufferedReader</code> is a resource that must be closed after the program is finished with it:
					</p><pre class="programlisting">
static String readFirstLineFromFile(String path) throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader(path))) {
        return br.readLine();
    }
}
					</pre><p>
				</p>
				<p>
					In this example, the resource declared in the try-with-resources statement is a <code class="code">BufferedReader</code>. The declaration statement appears
					within parentheses immediately after the <code class="code">try</code> keyword. The class <code class="code">BufferedReader</code>, in Java 7.0 and later, implements
					the interface <code class="code">java.lang.AutoCloseable</code>. Because the <code class="code">BufferedReader</code> instance is declared in a try-with-resource
					statement, it will be closed regardless of whether the <code class="code">try</code> statement completes normally or abruptly (as a result of the
					method <code class="code">BufferedReader.readLine</code> throwing an <code class="code">IOException</code>).
				</p>
				<p>
					Prior to Java 7.0, you can use a <code class="code">finally</code> block to ensure that a resource is closed regardless of whether  
					the <code class="code">try</code> statement completes normally or abruptly. The following example uses a <code class="code">finally</code> block instead 
					of a try-with-resources statement:
					</p><pre class="programlisting">
static String readFirstLineFromFileWithFinallyBlock(String path) throws IOException {
    BufferedReader br = new BufferedReader(new FileReader(path));
    try {
        return br.readLine();
    } finally {
        if (br != null) br.close();
    }
}
					</pre><p>
					However, in this example, if the methods <code class="code">readLine</code> and <code class="code">close</code> both throw exceptions, then the method
					<code class="code">readFirstLineFromFileWithFinallyBlock</code> throws the exception thrown from the <code class="code">finally</code> block; the
					exception thrown from the <code class="code">try</code> block is suppressed. In contrast, in the example <code class="code">readFirstLineFromFile</code>,
					if exceptions are thrown from both the <code class="code">try</code> block and the try-with-resources statement, then the method
					<code class="code">readFirstLineFromFile</code> throws the exception thrown from the <code class="code">try</code> block; the exception thrown from the
					try-with-resources block is suppressed. In Java SE 7 and later, you can retrieve suppressed exceptions; see the next section
					for more information.
				</p>
				<p>
					You may declare <span class="bold"><strong>one or more</strong></span> resources in a try-with-resources statement. The following example makes a
					copy of a file, using the try-with-resources statement. There are two resources defined in the <code class="code">try</code> statement,
					<span class="bold"><strong>separated by a semicolon</strong></span>, which are automatically closed when the statement completes:
					</p><pre class="programlisting">
public static void copyFile(String src, String dest) throws IOException  {
    try (BufferedReader in = new BufferedReader(new FileReader(src));
         BufferedWriter out = new BufferedWriter(new FileWriter(dest))) {
        String line;
        while((line = in.readLine()) != null) {
            out.write(line);
            out.write('\n');
        }
    } // No need to close resources in a "finally"
}
					</pre><p>
				</p>
				<p>
					NOTE: the <code class="code">close()</code> methods of resources are called in the <span class="bold"><strong>OPPOSITE</strong></span>
					order of their creation.
				</p>
				<p>
					NOTE: in try-with-resource statement the <code class="code">catch</code> and the <code class="code">finally</code> blocks are
					OPTIONAL.
				</p>
				<p>
					In JDBC 4.1 the <code class="code">java.lang.AutoCloseable</code> interface is extended by the following interfaces:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">java.sql.Connection</code>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">java.sql.ResultSet</code>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">java.sql.Statement</code>
							</p>
						</li></ul></div><p>
				</p>
				<p>
					The following example uses a try-with-resources statement to automatically close a <code class="code">java.sql.Statement</code> object:
					</p><pre class="programlisting">
public static void viewTable(Connection con) throws SQLException {
    String query = "SELECT ... FROM ...";
    try (Statement stmt = con.createStatement()) {
        ResultSet rs = stmt.executeQuery(query);
        while (rs.next()) {
            // ...
        }
    } catch (SQLException e) {
        // ...
    }
}
					</pre><p>
					The resource <code class="code">java.sql.Statement</code> used in this example is part of the JDBC 4.1 and later API.
				</p>
				<p>
					NOTE: A try-with-resources statement CAN have <code class="code">catch</code> and <code class="code">finally</code> blocks just like an ordinary <code class="code">try</code>
					statement. In a try-with-resources statement, any <code class="code">catch</code> or <code class="code">finally</code> block is run
					<span class="bold"><strong>AFTER the resources declared have been closed</strong></span>.
				</p>
				<p>
					<span class="bold"><strong>Making an Auto-Closeable Class</strong></span>
				</p>
				<p>
					As you know, a try-with-resources statement cannot manage every class. A new interface called <code class="code">java.lang.AutoCloseable</code> was introduced
					in Java 7.0. All it does is provide a void method named <code class="code">close()</code> that may throw a checked exception (<code class="code">java.lang.Exception</code>).
					Any class willing to participate in try-with-resources statements should implement this interface. It is strongly recommended that implementing
					classes and sub-interfaces declare a more precise exception type than <code class="code">java.lang.Exception</code>, or, even better, declare no exception type
					at all if invoking <code class="code">close()</code> should not fail.
				</p>
				<p>
					Such <code class="code">close()</code> methods have been retro-fitted into many classes of the standard Java SE run-time environment , including the
					<code class="code">java.io</code>, <code class="code">java.nio</code>, <code class="code">javax.crypto</code>, <code class="code">java.security</code>, <code class="code">java.util.zip</code>, <code class="code">java.util.jar</code>,
					<code class="code">javax.net</code>, and <code class="code">java.sql</code> packages. The major advantage of this approach is that existing code continues working just as
					before, while new code can easily take advantage of the try-with-resources statement.
				</p>
				<p>
					Consider the following example:
					</p><pre class="programlisting">
public class AutoCloseableResource <span class="bold"><strong>implements AutoCloseable</strong></span> {

    @Override
    <span class="bold"><strong>public void close()</strong></span> {
        System.out.println("in close()");
        throw new RuntimeException("Exception in close()");
    }

    public void work() throws Exception {
        System.out.println("in work()");
        throw new Exception("Exception in work()");
    }
}
					</pre><p>
					</p><pre class="programlisting">
public class AutoCloseableTest {

    public static void main(String[] args) {
        try (AutoCloseableResource resource = new AutoCloseableResource()) {
            resource.work();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
					</pre><p>
					The <code class="code">AutoCloseableResource</code> class implements <code class="code">java.lang.AutoCloseable</code> and can thus be used as part of a try-with-resources
					statement, as illustrated in the <code class="code">AutoCloseableTest.main(...)</code> method. Intentionally, we added some console output, and we throw
					exceptions both in the <code class="code">work()</code> and close() methods of the class. Running the program yields the following output:
					</p><pre class="programlisting">
in work()
in close()
java.lang.Exception: Exception in work()
	at AutoCloseableResource.work(AutoCloseableResource.java:21)
	at AutoCloseableTest.main(AutoCloseableTest.java:15)
	Suppressed: java.lang.RuntimeException: Exception in close()
		at AutoCloseableResource.close(AutoCloseableResource.java:16)
		at AutoCloseableTest.main(AutoCloseableTest.java:16)
					</pre><p>
				</p>
				<p>
					The output clearly proves that <code class="code">close()</code> was indeed called BEFORE entering the <code class="code">catch</code> block that should handle the
					exception. Yet, the Java developer discovering Java 7.0 might be surprised to see the exception stack trace line prefixed by
					"<code class="code">Suppressed: ...</code>". It matches the exception thrown by the <code class="code">close()</code> method, but you could never encounter
					such a form of stack trace prior to Java 7.0.
				</p>
				<p>
					<span class="bold"><strong>Suppressed Exceptions</strong></span>
				</p>
				<p>
					If both the (explicit) <code class="code">try</code> block and the (implicit) resource handling code throw an exception, then the <code class="code">try</code> block
					exception is the one which will be thrown. The resource handling exception will be made available via the <code class="code">Throwable.getSupressed()</code>
					method of the thrown exception. The <code class="code">Throwable[] Throwable.getSupressed()</code> is a new method added to the <code class="code">Throwable</code>
					class since Java SE 7 specifically for this purpose. If there were no suppressed exceptions then this will return an empty array.
				</p>
				<p>
					The Java 7.0 extensions to <code class="code">java.lang.Throwable</code> are as follows:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">public final void addSuppressed(Throwable exception)</code> - appends a suppressed exception to another one, so
								as to avoid exception masking.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">public final Throwable[] getSuppressed()</code> - gets the suppressed exceptions that were added to an exception.
							</p>
						</li></ul></div><p>
					These extensions were introduced especially for supporting the try-with-resources statement and fixing exception-masking problems.
				</p>
				<p>
					An exception can be thrown from the block of code associated with the try-with-resources statement. In the example <code class="code">copyFile</code> above,
					an exception can be thrown from the <code class="code">try</code> block, and up to two exceptions can be thrown from the try-with-resources
					statement when it tries to close the <code class="code">BufferedReader</code> and <code class="code">BufferedWriter</code> objects. If an exception is thrown from
					the <code class="code">try</code> block and one or more exceptions are thrown from the try-with-resources statement, then those exceptions thrown
					from the try-with-resources statement are SUPPRESSED, and the exception thrown by the <code class="code">try</code> block is the one that is thrown by
					the <code class="code">copyFile</code> method. You can retrieve these suppressed exceptions by calling the <code class="code">Throwable.getSuppressed</code> method
					from the exception thrown by the <code class="code">try</code> block.
				</p>
				<p>
					<span class="bold"><strong>Improved try-with-resources statement</strong></span>
				</p>
				<p>
					In Java 7.0 or Java 8.0 the <code class="code">AutoCloseable</code> resources must be declared and initialized inside the try block of 
					try-with-resources statement:
					</p><pre class="programlisting">
File file = new File("hello.txt");
try (BufferedReader br = new BufferedReader(new FileReader(file));) {
    String s = br.readLine();
    System.out.println(s);
} 
					</pre><p>
					In Java 9.0 you are not required to declare new local variable and initialize it inside the try block. 
					If you have a resource which is already declared and opened outside a try-with-resources statement, then 
					you only can write the variable name pointing to resource inside try block and will be eligible for 
					automatic resource management:
					</p><pre class="programlisting">
File file = new File("hello.txt");
BufferedReader br = new BufferedReader(new FileReader(file)); // must be final or effectively final
try (br) {
    String s = br.readLine();
    System.out.println(s);
}
					</pre><p>
					</p><div class="warning" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Warning]" src="images.admon/warning.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
						<p>
							 The restriction is that the local variable which you refer inside try block 
							 must be <span class="emphasis"><em>effectively final</em></span> or 
							 explicitly declared with <code class="code">final</code> keyword.
						</p>
						<p>
							 <span class="emphasis"><em>Effectively final</em></span> variable is a variable whose value is never 
							 changed after it is initialized.
						</p>
					</td></tr></table></div><p>
				</p>
				<p>
					In Java 10 you can use <code class="code">var</code> reserved type name for resource variable declaration:
					</p><pre class="programlisting">
File file = new File("hello.txt");
try (var br = new BufferedReader(new FileReader(file));) {
    String s = br.readLine();
    System.out.println(s);
}					
					</pre><p>
					or:
					</p><pre class="programlisting">
File file = new File("hello.txt");
var br = new BufferedReader(new FileReader(file));
try (br) {
    String s = br.readLine();
    System.out.println(s);
}
					</pre><p>					
				</p>
			</div>
			<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c10s2"></a>10.2.&nbsp;
					Develop code that handles multiple Exception types in a single catch block
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="#EXCEPTIONS_TECHNOTE" title="Catching Multiple Exception Types and Rethrowing Exceptions with Improved Type Checking">[EXCEPTIONS_TECHNOTE]</a> Handling More Than One Type of Exception
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					Starting from Java 7.0, a single <code class="code">catch</code> block can handle more than one type of exception. This feature can reduce 
					code duplication and lessen the temptation to catch an overly broad exception.
				</p>
				<p>
					Consider the following example, which contains duplicate code in each of the <code class="code">catch</code> blocks:
					</p><pre class="programlisting">
try {
    // ...
} catch (IOException ex) {
    logger.log(ex);
    throw ex;
} catch (SQLException ex) {
    logger.log(ex);
    throw ex;
}
					</pre><p>
				</p>
				<p>
					In releases prior to Java 7.0, it is difficult to create a common method to eliminate the duplicated code because the variable
					<code class="code">ex</code> has different types.
				</p>
				<p>
					The following example, which is valid in Java 7.0, eliminates the duplicated code:
					</p><pre class="programlisting">
try {
    // ...
} catch (IOException | SQLException ex) {
    logger.log(ex);
    throw ex;
}
					</pre><p>
				</p>
				<p>
					The <code class="code">catch</code> clause specifies the types of exceptions that the block can handle, and each exception type is separated
					with a vertical bar (<code class="code">|</code>).
				</p>
				<p>
					NOTE: An exception can not be a subtype or supertype of one of the <code class="code">catch</code> clause's exception parameters, 
					otherwise code will not compile:
					</p><pre class="programlisting">
try (DataOutputStream out = new DataOutputStream(new FileOutputStream("data"))) {
    out.writeUTF("Hello");
} catch (<span class="bold"><strong>FileNotFoundException | IOException  e</strong></span>) { // COMPILATION FAILS !!!
    // ...
}
					</pre><p>
					</p><pre class="programlisting">
public class <span class="bold"><strong>FileNotFoundException extends IOException</strong></span> {
    // ...
}
					</pre><p>
				</p>
				<p>
					NOTE: If a <code class="code">catch</code> block handles more than one exception type, then the <code class="code">catch</code> parameter 
					is <span class="bold"><strong>implicitly</strong></span>	<code class="code">final</code>. In this example, the <code class="code">catch</code> 
					parameter <code class="code">ex</code> is <code class="code">final</code> and therefore you cannot assign any values to it within
					the <code class="code">catch</code> block:
					</p><pre class="programlisting">
try (DataOutputStream out = new DataOutputStream(new FileOutputStream("data"))) {
    out.writeUTF("Hello");
} catch (RuntimeException | IOException  e) {
    <span class="bold"><strong>e = new Exception();</strong></span> // COMPILATION FAILS !!! (The e is final)
}
					</pre><p>
				</p>
				<p>
					Bytecode generated by compiling a <code class="code">catch</code> block that handles multiple exception types will be smaller (and thus superior) 
					than compiling many <code class="code">catch</code> blocks that handle only one exception type each. A <code class="code">catch</code> block that handles 
					multiple exception types creates no	duplication in the bytecode generated by the compiler; the bytecode has no replication of 
					exception handlers.
				</p>
			</div>
		</div>
		<div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a name="d5e3849"></a>Bibliography</h2></div></div></div>		
			
			<div class="biblioentry"><a name="JEP_200"></a><p>[JEP_200] 
				<span class="title"><i>JEP 200: The Modular JDK</i>. </span>
				<span class="releaseinfo">[http://openjdk.java.net/jeps/200]. </span>
			</p></div>
			<div class="biblioentry"><a name="CORE_JAVA9_IMPATIENT"></a><p>[CORE_JAVA9_IMPATIENT] 
				<span class="title"><i>Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition</i>. </span>
				<span class="releaseinfo">[https://www.amazon.com/Core-Java-SE-9-Impatient/dp/0134694724]. </span>
			</p></div>			
			<div class="biblioentry"><a name="SERVICE_LOADER_JAVA_DOC"></a><p>[SERVICE_LOADER_JAVA_DOC] 
				<span class="title"><i>ServiceLoader JavaDoc</i>. </span>
				<span class="releaseinfo">[https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html]. </span>
			</p></div>
			<div class="biblioentry"><a name="JAVA_UTIL_FUNCTION"></a><p>[JAVA_UTIL_FUNCTION] 
				<span class="title"><i>Java SE 11 Java Doc - Package java.util.function</i>. </span>
				<span class="releaseinfo">[https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/package-summary.html]. </span>
			</p></div>
			<div class="biblioentry"><a name="JLS_11"></a><p>[JLS_11] 
				<span class="title"><i>The Java&reg; Language Specification. Java SE 11 Edition</i>. </span>
				<span class="releaseinfo">[https://docs.oracle.com/javase/specs/jls/se11/html/]. </span>
			</p></div>
			<div class="biblioentry"><a name="JAVA_NIO_FILE_SUMMARY"></a><p>[JAVA_NIO_FILE_SUMMARY] 
				<span class="title"><i>Java NIO.2 File package summary</i>. </span>
				<span class="releaseinfo">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/package-summary.html. </span>
			</p></div>
			<div class="biblioentry"><a name="PATH_OPERATIONS"></a><p>[PATH_OPERATIONS] 
				<span class="title"><i>Path operations</i>. </span>
				<span class="releaseinfo">http://docs.oracle.com/javase/tutorial/essential/io/pathOps.html. </span>
			</p></div>
			<div class="biblioentry"><a name="NIO_TUTORIAL"></a><p>[NIO_TUTORIAL] 
				<span class="title"><i>File I/O (Featuring NIO.2)</i>. </span>
				<span class="releaseinfo">https://docs.oracle.com/javase/tutorial/essential/io/fileio.html. </span>
			</p></div>
			<div class="biblioentry"><a name="JAVA_NIO_FILES_JAVADOC"></a><p>[JAVA_NIO_FILES_JAVADOC] 
				<span class="title"><i>Java NIO.2 Files class JavaDoc</i>. </span>
				<span class="releaseinfo">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html. </span>
			</p></div>
			<div class="biblioentry"><a name="JDEPS_DOC"></a><p>[JDEPS_DOC] 
				<span class="title"><i>JDeps documentation</i>. </span>
				<span class="releaseinfo">https://docs.oracle.com/en/java/javase/11/tools/jdeps.html. </span>
			</p></div>
			<div class="biblioentry"><a name="LVTI_STYLE"></a><p>[LVTI_STYLE] 
				<span class="title"><i>Style Guidelines for Local Variable Type Inference in Java</i>. </span>
				<span class="releaseinfo">http://openjdk.java.net/projects/amber/LVTIstyle.html. </span>
			</p></div>
			<div class="biblioentry"><a name="JEP_323"></a><p>[JEP_323] 
				<span class="title"><i>JEP 323: Local-Variable Syntax for Lambda Parameters</i>. </span>
				<span class="releaseinfo">http://openjdk.java.net/jeps/323. </span>
			</p></div>
			<div class="biblioentry"><a name="TRY_WITH_RESOURCE_TECHNOTE"></a><p>[TRY_WITH_RESOURCE_TECHNOTE] 
				<span class="title"><i>The try-with-resources Statement</i>. </span>
				<span class="releaseinfo">http://download.oracle.com/javase/7/docs/technotes/guides/language/try-with-resources.html. </span>
			</p></div>
			<div class="biblioentry"><a name="EXCEPTIONS_TECHNOTE"></a><p>[EXCEPTIONS_TECHNOTE] 
				<span class="title"><i>Catching Multiple Exception Types and Rethrowing Exceptions with Improved Type Checking</i>. </span>
				<span class="releaseinfo">http://download.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.html. </span>
			</p></div>
		</div>
	</div>
	<div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="partII"></a>Part&nbsp;II.&nbsp;Appendixes</h1></div></div></div>
		
		<div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="app1"></a>Appendix&nbsp;1.&nbsp;Additional materials</h2></div></div></div>
			
			<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="a1s1"></a>1.1.&nbsp;How to build JDK module graph</h2></div></div></div>
				
				<p>
					Create <code class="code">module-info.java</code> in some directory.
					</p><pre class="programlisting">

module viz {
    requires java.se;
}

					</pre><p>
				</p>
				<p>
					Create class <code class="code">app.App.java</code>  (in the <code class="code">app</code> sub-directory)
					</p><pre class="programlisting">

package app;

import java.lang.module.ModuleDescriptor.Requires;
import java.util.HashSet;
import java.util.Set;

/**
 * This is the main application to generate graph code.
 * 
 * @author Mikalai Zaikin (mzaikin@gmail.com)
 */
public class App {

    public static void main(String[] args) {
        App app = new App();
        
        var edges = app.getEdges();
        var modules = app.getModules();
        
        // System.out.println(modules);
        
        StringBuffer sb = new StringBuffer("digraph Java11 {\n");
        sb.append("    ratio = fill;\n");
        sb.append("    node [style=filled];\n");        
        edges.forEach((e) -&gt; {
            sb.append(String.format("    \"%s\" -&gt; \"%s\";%n", new Object[]{e.getFrom(), e.getTo()}));
        });
        modules.forEach((m) -&gt; {
            sb.append("\""+m+"\" [color=\"" + (m.startsWith("jdk") ? "darkseagreen" : "cyan") + "\"];\n");
        });
        sb.append("}");
        System.out.println(sb);
        
    }
    
    private HashSet&lt;Edge&gt; getEdges() {
        var edges = new HashSet&lt;Edge&gt;();
        Set&lt;Module&gt; modules = ModuleLayer.boot().modules();
        modules.forEach((module) -&gt; {
            String moduleName = module.getName();
            if (!("viz".equals(moduleName))) {
                Set&lt;Requires&gt; requires = module.getDescriptor().requires();
                requires.forEach((require) -&gt; {
                    edges.add(new Edge(moduleName, require.name()));
                });
            }
        });
        return edges;
    }
    
    private HashSet&lt;String&gt; getModules() {
        var mods = new HashSet&lt;String&gt;();
        Set&lt;Module&gt; modules = ModuleLayer.boot().modules();
        for (Module module : modules) {
            String moduleName = module.getName();
            if ("viz".equals(moduleName)) continue;
            mods.add(moduleName);
        }
        return mods;
    }
}

					</pre><p>
				</p>
				<p>
					Create class <code class="code">app.Edge.java</code> (in the <code class="code">app</code> sub-directory)
					</p><pre class="programlisting">

package app;

import java.util.Objects;

/**
 * This is the class to encapsulate edge of the graph.
 * 
 * @author Mikalai Zaikin (mzaikin@gmail.com)
 */
public class Edge {

    private String from;
    private String to;

    public Edge(String from, String to) {
        this.from = from;
        this.to = to;
    }

    public String getFrom() {
        return from;
    }

    public void setFrom(String from) {
        this.from = from;
    }

    public String getTo() {
        return to;
    }

    public void setTo(String to) {
        this.to = to;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Edge edge = (Edge) o;
        return Objects.equals(from, edge.from)
                &amp;&amp; Objects.equals(to, edge.to);
    }

    @Override
    public int hashCode() {
        return Objects.hash(from, to);
    }

    @Override
    public String toString() {
        return from + "-&gt;" + to;
    }
}

					</pre><p>					
				</p>
				<p>
					Run the code from the directory where <code class="code">module-info.class</code> is located:
					</p><pre class="programlisting">

C:\USERS\IBM_ADMIN\DOCUMENTS\NETBEANSPROJECTS\VIZ\BUILD\MODULES
&#9492;&#9472;&#9472;&#9472;viz
    &#9474;   module-info.class
    &#9474;
    &#9492;&#9472;&#9472;&#9472;app
            App.class
            Edge.class

					</pre><p>
					</p><pre class="programlisting">
"C:\Program Files\Java\jdk-11.0.2\bin\java.exe" --module-path . -m viz/app.App
					</pre><p> 
				</p>
				<p>
					There should be similar output:
					</p><pre class="programlisting">

digraph Java11 {
    ratio = fill;
    node [style=filled];
    "java.management.rmi" -&gt; "java.base";
    "java.sql" -&gt; "java.xml";
    "java.se" -&gt; "java.management.rmi";
    "java.xml.crypto" -&gt; "java.base";
    "java.se" -&gt; "java.scripting";
    "java.sql" -&gt; "java.base";
    "jdk.scripting.nashorn" -&gt; "java.base";
    "jdk.security.jgss" -&gt; "java.security.sasl";
    "java.smartcardio" -&gt; "java.base";
    "jdk.naming.dns" -&gt; "java.naming";
    "java.xml.crypto" -&gt; "java.xml";
    "java.prefs" -&gt; "java.base";
    "java.se" -&gt; "java.rmi";
    "java.sql.rowset" -&gt; "java.base";
    "java.compiler" -&gt; "java.base";
    "jdk.localedata" -&gt; "java.base";
    "jdk.security.auth" -&gt; "java.security.jgss";
    "jdk.naming.rmi" -&gt; "java.rmi";
    "java.desktop" -&gt; "java.prefs";
    "java.prefs" -&gt; "java.xml";
    "java.rmi" -&gt; "java.logging";
    "jdk.security.jgss" -&gt; "java.logging";
    "jdk.jdeps" -&gt; "jdk.compiler";
    "java.se" -&gt; "java.instrument";
    "jdk.accessibility" -&gt; "java.desktop";
    "jdk.jfr" -&gt; "java.base";
    "jdk.accessibility" -&gt; "java.base";
    "java.logging" -&gt; "java.base";
    "jdk.jdeps" -&gt; "java.base";
    "jdk.naming.rmi" -&gt; "java.naming";
    "jdk.jlink" -&gt; "jdk.jdeps";
    "java.se" -&gt; "java.base";
    "jdk.unsupported.desktop" -&gt; "java.desktop";
    "jdk.crypto.cryptoki" -&gt; "jdk.crypto.ec";
    "jdk.security.auth" -&gt; "java.base";
    "java.sql.rowset" -&gt; "java.sql";
    "jdk.compiler" -&gt; "java.base";
    "jdk.jdeps" -&gt; "java.compiler";
    "jdk.internal.opt" -&gt; "java.base";
    "jdk.naming.dns" -&gt; "java.base";
    "java.rmi" -&gt; "java.base";
    "jdk.management.jfr" -&gt; "java.base";
    "jdk.security.jgss" -&gt; "java.security.jgss";
    "java.sql" -&gt; "java.transaction.xa";
    "java.scripting" -&gt; "java.base";
    "java.management" -&gt; "java.base";
    "jdk.dynalink" -&gt; "java.logging";
    "jdk.management.jfr" -&gt; "java.management";
    "java.se" -&gt; "java.sql";
    "java.se" -&gt; "java.transaction.xa";
    "jdk.javadoc" -&gt; "jdk.compiler";
    "jdk.scripting.nashorn" -&gt; "java.scripting";
    "java.se" -&gt; "java.logging";
    "jdk.crypto.mscapi" -&gt; "java.base";
    "java.se" -&gt; "java.compiler";
    "jdk.jlink" -&gt; "jdk.internal.opt";
    "java.sql" -&gt; "java.logging";
    "java.security.jgss" -&gt; "java.naming";
    "jdk.scripting.nashorn" -&gt; "java.logging";
    "jdk.charsets" -&gt; "java.base";
    "java.desktop" -&gt; "java.datatransfer";
    "jdk.crypto.ec" -&gt; "java.base";
    "java.xml.crypto" -&gt; "java.logging";
    "java.sql.rowset" -&gt; "java.logging";
    "jdk.management.jfr" -&gt; "jdk.jfr";
    "jdk.naming.rmi" -&gt; "java.base";
    "jdk.management.jfr" -&gt; "jdk.management";
    "jdk.jartool" -&gt; "java.base";
    "java.naming" -&gt; "java.base";
    "java.transaction.xa" -&gt; "java.base";
    "java.se" -&gt; "java.xml";
    "jdk.javadoc" -&gt; "java.xml";
    "java.datatransfer" -&gt; "java.base";
    "java.se" -&gt; "java.desktop";
    "jdk.management" -&gt; "java.base";
    "jdk.compiler" -&gt; "java.compiler";
    "jdk.crypto.cryptoki" -&gt; "java.base";
    "java.security.sasl" -&gt; "java.base";
    "java.se" -&gt; "java.security.sasl";
    "java.se" -&gt; "java.prefs";
    "java.security.jgss" -&gt; "java.base";
    "jdk.security.auth" -&gt; "java.naming";
    "jdk.jlink" -&gt; "java.base";
    "jdk.zipfs" -&gt; "java.base";
    "java.net.http" -&gt; "java.base";
    "java.desktop" -&gt; "java.xml";
    "java.se" -&gt; "java.sql.rowset";
    "java.management.rmi" -&gt; "java.naming";
    "jdk.security.jgss" -&gt; "java.base";
    "java.desktop" -&gt; "java.base";
    "jdk.scripting.nashorn" -&gt; "jdk.dynalink";
    "jdk.unsupported.desktop" -&gt; "java.base";
    "jdk.management" -&gt; "java.management";
    "java.se" -&gt; "java.management";
    "java.instrument" -&gt; "java.base";
    "java.naming" -&gt; "java.security.sasl";
    "java.xml" -&gt; "java.base";
    "jdk.javadoc" -&gt; "java.base";
    "java.sql.rowset" -&gt; "java.naming";
    "java.se" -&gt; "java.xml.crypto";
    "jdk.javadoc" -&gt; "java.compiler";
    "java.se" -&gt; "java.datatransfer";
    "jdk.dynalink" -&gt; "java.base";
    "java.management.rmi" -&gt; "java.management";
    "java.security.sasl" -&gt; "java.logging";
    "java.se" -&gt; "java.security.jgss";
    "java.se" -&gt; "java.naming";
    "java.se" -&gt; "java.net.http";
    "java.management.rmi" -&gt; "java.rmi";
"jdk.management.jfr" [color="darkseagreen"];
"java.sql" [color="cyan"];
"java.rmi" [color="cyan"];
"jdk.charsets" [color="darkseagreen"];
"java.transaction.xa" [color="cyan"];
"java.xml.crypto" [color="cyan"];
"java.logging" [color="cyan"];
"java.xml" [color="cyan"];
"jdk.jfr" [color="darkseagreen"];
"java.datatransfer" [color="cyan"];
"jdk.crypto.cryptoki" [color="darkseagreen"];
"java.naming" [color="cyan"];
"java.desktop" [color="cyan"];
"java.se" [color="cyan"];
"java.prefs" [color="cyan"];
"java.net.http" [color="cyan"];
"jdk.compiler" [color="darkseagreen"];
"jdk.naming.rmi" [color="darkseagreen"];
"jdk.internal.opt" [color="darkseagreen"];
"java.security.sasl" [color="cyan"];
"jdk.zipfs" [color="darkseagreen"];
"java.base" [color="cyan"];
"jdk.crypto.ec" [color="darkseagreen"];
"jdk.javadoc" [color="darkseagreen"];
"jdk.crypto.mscapi" [color="darkseagreen"];
"java.management" [color="cyan"];
"java.sql.rowset" [color="cyan"];
"jdk.jlink" [color="darkseagreen"];
"java.smartcardio" [color="cyan"];
"jdk.scripting.nashorn" [color="darkseagreen"];
"java.instrument" [color="cyan"];
"java.security.jgss" [color="cyan"];
"jdk.management" [color="darkseagreen"];
"java.compiler" [color="cyan"];
"jdk.security.auth" [color="darkseagreen"];
"java.scripting" [color="cyan"];
"jdk.dynalink" [color="darkseagreen"];
"jdk.unsupported.desktop" [color="darkseagreen"];
"jdk.jdeps" [color="darkseagreen"];
"jdk.accessibility" [color="darkseagreen"];
"jdk.jartool" [color="darkseagreen"];
"java.management.rmi" [color="cyan"];
"jdk.naming.dns" [color="darkseagreen"];
"jdk.security.jgss" [color="darkseagreen"];
"jdk.localedata" [color="darkseagreen"];
}

					</pre><p>
				</p>
				<p>
					Use this graph text definition to generate image at 
					<a class="ulink" href="http://www.webgraphviz.com" target="_top">http://www.webgraphviz.com</a>
					or
					<a class="ulink" href="http://viz-js.com" target="_top">http://viz-js.com</a>.					
				</p>
				<p>
					The result will look as follows:
					</p><div class="figure"><a name="d5e3920"></a><p class="title"><b>Figure&nbsp;1.1.&nbsp;Java SE 11 Module Graph</b></p><div class="figure-contents">
  						
  						<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tr><td><img src="images/java11-graph.gif" width="100%" alt="Java SE 11 Module Graph"></td></tr></table></div>
					</div></div><p><br class="figure-break">
				</p>
			</div>
		</div>
	</div>	
</div></body></html>
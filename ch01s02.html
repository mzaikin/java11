<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>1.2.&nbsp; Declare modules and enable access between modules</title><link rel="stylesheet" type="text/css" href="ocpjd11-upgrade-guide.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Exam 1Z0-817: Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Study Guide"><link rel="up" href="ch01.html" title="Chapter&nbsp;1.&nbsp;Understanding Modules"><link rel="prev" href="ch01.html" title="Chapter&nbsp;1.&nbsp;Understanding Modules"><link rel="next" href="ch01s03.html" title="1.3.&nbsp; Describe how a modular project is compiled and run"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1.2.&nbsp;
					 Declare modules and enable access between modules
				</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;1.&nbsp;Understanding Modules</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch01s03.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c1s2"></a>1.2.&nbsp;
					 Declare modules and enable access between modules
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="bi01.html#CORE_JAVA9_IMPATIENT" title="Cay S. Horstmann - Core Java SE 9 for the Impatient 2nd Edition">[CORE_JAVA9_IMPATIENT]</a> Chapter 15.
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					A Java platform module consists of:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								A collection of packages							
							</p>
						</li><li class="listitem">
							<p>
								Optionally, resource files and other files such as native libraries							
							</p>
						</li><li class="listitem">
							<p>
								A list of the accessible packages in the module							
							</p>
						</li><li class="listitem">
							<p>
								A list of all modules on which this module depends						
							</p>
						</li></ul></div><p>
				</p>
				<p>
					There are four types of modules in the Java Platform Module System (JPMS):
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								System Modules
							</p>
							<p>
								These are the modules listed when we run the <code class="code">java --list-modules</code> command. They include the 
								Java SE (<code class="code">java.</code>) and JDK (<code class="code">jdk.</code>) modules.
							</p>
						</li><li class="listitem">
							<p>
								Application Modules
							</p>
							<p>
								These modules are what we usually want to build. They are named and defined in the <code class="code">module-info.java</code> file,
								which compiled into <code class="code">module-info.class</code> file and included in JAR file.
							</p>
						</li><li class="listitem">
							<p>
								Automatic Modules
							</p>
							<p>
								Module system  automatically creates an automatic module for plain JARs (with no module descriptor). 
							</p>
							<p>
								If the JAR defines the <code class="code">Automatic-Module-Name</code> header in its manifest (<code class="code">META-INF/MANIFEST.MF</code>), 
								it defines the module's name, otherwise the JAR file name is used to determine the name.
							</p>
							<p>
								Since the JAR contains no information which packages are considered public APIs and which are not, the module 
								system exports all packages and also opens them for deep reflection.
							</p>
							<p>
								Since a plain JAR expresses no <code class="code">requires</code> clauses, the module system lets automatic modules read all other modules.
							</p>
						</li><li class="listitem">
							<p>
								Unnamed Module
							</p>
							<p>
								When a class or JAR is loaded onto the classpath, but not the module path, it is automatically added to the unnamed module. 
								It is a catch-all module to maintain backward compatibility with previously-written Java code.
							</p>
							<p>
								All classes within the unnamed module can read all other module (named or unnamed) without any explicit declaration of any kind.
							</p>
							<p>
								The packages exported by unnamed module can only be read by another unnamed module. It is not possible that a named module 
								can read (requires) the unnamed module. Because to explicitly use '<code class="code">requires</code>' clause in a <code class="code">module-info.java</code> or 
								use a command line option to add the module, we need a module name.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					When creating an appication module, it is important that its name is unique. It is expected that module names will follow the "reverse domain
					name" convention, just like package names. For example "<code class="code">by.boot.java</code>"
				</p>
				<p>
					A module name can be the same as package name, however it can be different too, for example <code class="code">java.sql</code> module 
					contains <code class="code">java.sql</code> and <code class="code">javax.sql</code> packages:
					</p><pre class="programlisting">
C:\Program Files\Java\jdk-11.0.2&gt;java --describe-module java.sql
java.sql@11.0.2
exports java.sql
exports javax.sql
requires java.transaction.xa transitive
requires java.logging transitive
requires java.xml transitive
requires java.base mandated
uses java.sql.Driver
					</pre><p>
				</p>
				<p>
					To declare an application module, a module declaration needs to be specified. This is done in a special file called 
					<code class="code">module-info.java</code>. As you can see from the file extension, this is a <code class="code">.java</code> file that gets compiled 
					into a <code class="code">.class</code> file by the Java compiler.
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
}
					</pre><p>
					There could be additional directives between curly braces, but all of them are optional.  
				</p>
				<p>
					Next, create a new class for the module:
					</p><pre class="programlisting">
package by.boot.java.pkg.logger;
public class MyLogger {
    public static void main(String[] args) {
        System.out.println("MyLogger - main() method called");
    }
}
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						Module may not have classes with unnamed package (i.e. those which belong to "default" package)
					</p>
				</td></tr></table></div>
				<p>
					Special <code class="code">module-info.java</code> file must be at the root of Java class packages. Place sources as follows:
					</p><pre class="programlisting">
C:\1Z0-817
&#9492;&#9472;&#9472;&#9472;mod1
    &#9474;   module-info.java
    &#9474;
    &#9492;&#9472;&#9472;&#9472;by
        &#9492;&#9472;&#9472;&#9472;boot
            &#9492;&#9472;&#9472;&#9472;java
                &#9492;&#9472;&#9472;&#9472;pkg
                    &#9492;&#9472;&#9472;&#9472;logger
                            MyLogger.java
					</pre><p>
				</p>
				<p>
					Compile the sources (normally this will be done by IDE for you, but for learning purposes we do it from command line):
					</p><pre class="programlisting">
C:\1Z0-817\mod1&gt;javac module-info.java
C:\1Z0-817\mod1&gt;javac by/boot/java/pkg/logger/MyLogger.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817
&#9492;&#9472;&#9472;&#9472;mod1
    &#9474;   module-info.class
    &#9474;   module-info.java
    &#9474;
    &#9492;&#9472;&#9472;&#9472;by
        &#9492;&#9472;&#9472;&#9472;boot
            &#9492;&#9472;&#9472;&#9472;java
                &#9492;&#9472;&#9472;&#9472;pkg
                    &#9492;&#9472;&#9472;&#9472;logger
                            MyLogger.class
                            MyLogger.java
					</pre><p>
				</p>
				<p>
					To run a modular application, you specify the module path, which is similar to the class path, but 
					contains modules. You also specify the main class in the format <code class="code">modulename/classname</code>:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java --module-path ./mod1 --module by.boot.java.mod.logger/by.boot.java.pkg.logger.MyLogger
MyLogger - main() method called
					</pre><p>
					Instead of <code class="code">--module-path</code> and <code class="code">--module</code>, you can use the single-letter options
					<code class="code">-p</code> and <code class="code">-m</code>:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p ./mod1 -m by.boot.java.mod.logger/by.boot.java.pkg.logger.MyLogger
MyLogger - main() method called
					</pre><p>
				</p>
				<p>
					You can create a modular JAR file using <code class="code">jar</code> utility:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar --create --file log.jar --main-class by.boot.java.pkg.logger.MyLogger --module-version 1.0.0 -C mod1 .
					</pre><p>
					it creates a modular JAR with the following structure:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar -tvf log.jar
     0 Thu Mar 21 23:07:34 AST 2019 META-INF/
   112 Thu Mar 21 23:07:34 AST 2019 META-INF/MANIFEST.MF
   299 Thu Mar 21 23:07:34 AST 2019 module-info.class
     0 Wed Mar 20 23:30:22 AST 2019 by/
     0 Wed Mar 20 23:30:28 AST 2019 by/boot/
     0 Wed Mar 20 23:30:36 AST 2019 by/boot/java/
     0 Wed Mar 20 23:30:40 AST 2019 by/boot/java/pkg/
     0 Wed Mar 20 23:34:54 AST 2019 by/boot/java/pkg/logger/
   465 Wed Mar 20 23:34:54 AST 2019 by/boot/java/pkg/logger/MyLogger.class
   179 Wed Mar 20 23:31:06 AST 2019 by/boot/java/pkg/logger/MyLogger.java
    37 Wed Mar 20 23:24:24 AST 2019 module-info.java
   					</pre><p>
				</p>
				<p>
					Make a note of <code class="code">META-INF/MANIFEST.MF</code> content:
					</p><pre class="programlisting">
Manifest-Version: 1.0
Created-By: 11.0.2 (Oracle Corporation)
Main-Class: by.boot.java.pkg.logger.MyLogger
					</pre><p>
				</p>				
				<p>
					You can also use <code class="code">jar</code> utility to check structure of the module:
					</p><pre class="programlisting">
C:\1Z0-817&gt;jar -d -f log.jar
by.boot.java.mod.logger@1.0.0 jar:file:///C:/1Z0-817/log.jar/!module-info.class
requires java.base mandated
contains by.boot.java.pkg.logger
main-class by.boot.java.pkg.logger.MyLogger
					</pre><p>
				</p>
				<p>
					Finally, you can run the <code class="code">Main-Class</code> from the created modular JAR:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p ./log.jar -m by.boot.java.mod.logger
MyLogger - main() method called
					</pre><p>
					If the main class would not have beed defined, you can provide it explicitly:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p ./log.jar -m by.boot.java.mod.logger/by.boot.java.pkg.logger.MyLogger
MyLogger - main() method called
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong><code class="code">requires</code> directive</strong></span>
				</p>
				<p>
					By default our module implicitly requires only <code class="code">java.base</code> which contains basic modules:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java --describe-module java.base
java.base@11.0.2
exports java.io
exports java.lang
...
exports java.math
exports java.net
exports java.nio
exports java.security
exports java.text
exports java.time
exports java.util
exports java.util.concurrent
exports java.util.concurrent.atomic
exports java.util.concurrent.locks
exports java.util.function
exports java.util.jar
...
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						All standard Java SE modules have implicit and mandatory dependency on <code class="code">java.base</code>. You do not need 
						to define dependency on <code class="code">java.base</code> explicitly.  
					</p>
				</td></tr></table></div>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						It is not allowed to have circular dependencies between modules. If module <code class="code">A</code> requires module <code class="code">B</code>, then 
						module <code class="code">B</code> cannot also require module <code class="code">A</code>.  
					</p>
				</td></tr></table></div>				
				<p>
					Imagine you want to use <code class="code">java.util.logging</code> package which resides in the <code class="code">java.logging</code> module. In this 
					case you must explicitly request it. Update the class first:
					</p><pre class="programlisting">
package by.boot.java.pkg.logger;

import java.util.logging.Logger;

public class MyLogger {
    
    private static final Logger LOG = Logger.getLogger(MyLogger.class.getName());
    
    public static void main(String[] args) {
        System.out.println("MyLogger - main() method called");
    }
    
    public static void log() {
        LOG.info("MyLogger - log() method called");
    }
}
					</pre><p>
					recompile the class:
					</p><pre class="programlisting">
C:\1Z0-817\mod1&gt;javac by/boot/java/pkg/logger/MyLogger.java
					</pre><p>
					So far so good. But as soon as you run the class you get an exception:
					</p><pre class="programlisting">

C:\1Z0-817&gt;java -p ./mod1 -m by.boot.java.mod.logger/by.boot.java.pkg.logger.MyLogger

Exception in thread "main" java.lang.IllegalAccessError: class by.boot.java.pkg.logger.MyLogger (in module by.boot.java.mod.logger) 
cannot access class java.util.logging.Logger (in module java.logging) because module by.boot.java.mod.logger does not read module java.logging
        at by.boot.java.mod.logger/by.boot.java.pkg.logger.MyLogger.&lt;clinit&gt;(MyLogger.java:7)

					
					</pre><p>
					in order to fix the problem we must add <code class="code">requires</code> directive to <code class="code">module-info.java</code>, which allows us to
					declare dependencies:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires java.logging;
}
					</pre><p>
					Now  <code class="code">by.boot.java.mod.logger</code> module has both a runtime and a compile-time dependency on 
					<code class="code">java.logging</code> module. And all public types exported from a dependency are accessible 
					by our module when we use this directive.
				</p>
				<p>
					Recompile the module declaration <code class="code">module-info.java</code> file and re-run <code class="code">MyLogger</code> class:
					</p><pre class="programlisting">
C:\1Z0-817\mod1&gt;javac module-info.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\mod1&gt;java -p . -m by.boot.java.mod.logger/by.boot.java.pkg.logger.MyLogger
MyLogger - main() method called
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong><code class="code">requires static</code> directive</strong></span>
				</p>
				<p>
					You can use <code class="code">requires static</code> to specify that a module dependency is required in the compile time, but optional in the runtime, for example:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires static java.logging;
}
					</pre><p>
					Static dependencies are useful for frameworks and libraries. Suppose that you are building a library to work with different kinds of databases. The 
					library module can use static dependencies to require different kinds of JDBC drivers. At compile time, the library&#8217;s code can access types defined 
					in those drivers. At runtime, users of the library can add only the drivers they want to use. If the dependencies are not static, users of the library 
					have to add all supported drivers to pass the module resolution checks.
				</p>
				<p>
					<span class="bold"><strong><code class="code">exports</code> directive</strong></span>
				</p>
				<p>
					Assume we create new client module which uses our logger module. We already know that we must declare in <code class="code">module-info.java</code> which modules 
					are required:  
					</p><pre class="programlisting">
module by.boot.java.mod.client {
    requires by.boot.java.mod.logger;
}
					</pre><p>
					and a client class:
					</p><pre class="programlisting">
package by.boot.java.pkg.client;

import by.boot.java.pkg.logger.MyLogger;

public class MyClient {
    public static void main(String[] args) {
        MyLogger.log();
    }
}
					</pre><p>
				</p>
				<p>
					The project with two modules will look as follows:
					</p><pre class="programlisting">
C:\1Z0-817
&#9500;&#9472;&#9472;&#9472;mod1
&#9474;   &#9474;   module-info.class
&#9474;   &#9474;   module-info.java
&#9474;   &#9474;
&#9474;   &#9492;&#9472;&#9472;&#9472;by
&#9474;       &#9492;&#9472;&#9472;&#9472;boot
&#9474;           &#9492;&#9472;&#9472;&#9472;java
&#9474;               &#9492;&#9472;&#9472;&#9472;pkg
&#9474;                   &#9492;&#9472;&#9472;&#9472;logger
&#9474;                           MyLogger.class
&#9474;                           MyLogger.java
&#9474;
&#9492;&#9472;&#9472;&#9472;mod2
    &#9474;   module-info.java
    &#9474;
    &#9492;&#9472;&#9472;&#9472;by
        &#9492;&#9472;&#9472;&#9472;boot
            &#9492;&#9472;&#9472;&#9472;java
                &#9492;&#9472;&#9472;&#9472;pkg
                    &#9492;&#9472;&#9472;&#9472;client
                            MyClient.java
					</pre><p>
					Now compile the new code:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p ./mod1 mod2/module-info.java
					</pre><p>
					As soon as you try to compile <code class="code">MyClient.java</code> it fails:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p ./mod1 mod2/by/boot/java/pkg/client/MyClient.java
mod2\by\boot\java\pkg\client\MyClient.java:3: error: package by.boot.java.pkg.logger is not visible
import by.boot.java.pkg.logger.MyLogger;
                       ^
  (package by.boot.java.pkg.logger is declared in module by.boot.java.mod.logger, which is not in the module graph)
1 error					
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						By default, a module doesn&#8217;t expose any of its API to other modules. This strong encapsulation was 
						one of the key motivators for creating the module system in the first place.  
					</p>
				</td></tr></table></div>
				<p>
					As you can see, the <code class="code">by.boot.java.mod.logger</code> module classes are not visible in the <code class="code">by.boot.java.mod.client</code>
					module, even after we declared it as required. Our code is significantly more secure, but now we need to explicitly open 
					our API up to the world if we want it to be usable.
				</p>
				<p>
					We need to use the <code class="code">exports</code> directive to expose all <code class="code">public</code> members of the <code class="code">by.boot.java.pkg.logger</code> package:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires java.logging;
    exports by.boot.java.pkg.logger;
}
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						You define <span class="bold"><strong>module name</strong></span> with <code class="code">requires</code> directive.  
					</p>
					<p>
						You define <span class="bold"><strong>package name</strong></span> with <code class="code">exports</code> directive.  
					</p>
				</td></tr></table></div>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						When you export a package, you only export types in this package but not types in its subpackages.  
					</p>
				</td></tr></table></div>
				<p>
					The same Java package can only be exported by a single Java module at runtime. You cannot have two (or more) modules that 
					export the same package in use at the same time. The JVM will complain at startup if you do. A Java package may not split 
					members (classes, interfaces, enums) between multiple modules.
				</p>
				<p>	
					Re-compile logger module definition:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac mod1/module-info.java mod1/by/boot/java/pkg/logger/MyLogger.java
					</pre><p>
				</p>
				<div class="important" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images.admon/important.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<p>
						You may not export empty or non-existent package:
						</p><pre class="programlisting">
C:\1Z0-817&gt;javac mod1/module-info.java mod1/by/boot/java/pkg/logger/MyLogger.java
mod1\module-info.java:4: error: package is empty or does not exist: aaa
    exports aaa;
            ^
1 error
						</pre><p>  
					</p>
				</td></tr></table></div>	
				<p>
					Now you can compile and run client class:
					</p><pre class="programlisting">
C:\1Z0-817\mod2&gt;javac -p ../mod1; module-info.java by/boot/java/pkg/client/MyClient.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817\mod2&gt;java -p ../mod1;. -m by.boot.java.mod.client/by.boot.java.pkg.client.MyClient
Mar 22, 2019 11:59:29 PM by.boot.java.pkg.logger.MyLogger log
INFO: MyLogger - log() method called
					</pre><p>
					The project structure looks as follows:
					</p><pre class="programlisting">
C:\1Z0-817
&#9500;&#9472;&#9472;&#9472;mod1
&#9474;   &#9474;   module-info.class
&#9474;   &#9474;   module-info.java
&#9474;   &#9474;
&#9474;   &#9492;&#9472;&#9472;&#9472;by
&#9474;       &#9492;&#9472;&#9472;&#9472;boot
&#9474;           &#9492;&#9472;&#9472;&#9472;java
&#9474;               &#9492;&#9472;&#9472;&#9472;pkg
&#9474;                   &#9492;&#9472;&#9472;&#9472;logger
&#9474;                           MyLogger.class
&#9474;                           MyLogger.java
&#9474;
&#9492;&#9472;&#9472;&#9472;mod2
    &#9474;   module-info.class
    &#9474;   module-info.java
    &#9474;
    &#9492;&#9472;&#9472;&#9472;by
        &#9492;&#9472;&#9472;&#9472;boot
            &#9492;&#9472;&#9472;&#9472;java
                &#9492;&#9472;&#9472;&#9472;pkg
                    &#9492;&#9472;&#9472;&#9472;client
                            MyClient.class
                            MyClient.java
					</pre><p>
				</p>
				<p>
					If you fail to list all modules in the modules path option, you get a <code class="code">java.lang.module.FindException</code>:
					</p><pre class="programlisting">
C:\1Z0-817\mod2&gt;java -p . -m by.boot.java.mod.client/by.boot.java.pkg.client.MyClient
Error occurred during initialization of boot layer
java.lang.module.FindException: Module by.boot.java.mod.logger not found, required by by.boot.java.mod.client
					</pre><p>  					
				</p>
				<p>
					<span class="bold"><strong><code class="code">exports...to</code> directive</strong></span>
				</p>
				<p>
					When you are using <code class="code">exports</code> directive to export a package in the module declaration, this package is visible to all
					modules that use <code class="code">requires</code> directive to require it. Sometimes you may want to limit the visibility of certain packages
					to some modules only.
				</p>
				<p>
					 You can restrict which modules have access to your packages by using the <code class="code">exports ... to &lt;module name&gt;</code> syntax:
					 </p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires java.logging;
    exports by.boot.java.pkg.logger to by.boot.java.mod.client;
}
					 </pre><p>
				</p>
				<p>
					<span class="bold"><strong>Open modules</strong></span>
				</p>
				<p>
					In the module declaration, you can add the modifier <code class="code">open</code> before module to declare it as an open module. An
					open module grants compile time access to explicitly exported packages only, but it grants access to types in
					all its packages at runtime:
					</p><pre class="programlisting">
open module by.boot.java.mod.logger {
    requires java.logging;
}
					</pre><p>
					Re-compile the <code class="code">by.boot.java.mod.logger</code> module definition and re-run the client:
					</p><pre class="programlisting">
C:\1Z0-817\mod1&gt;javac module-info.java
					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p ./mod1;./mod2 -m by.boot.java.mod.client/by.boot.java.pkg.client.MyClient
Mar 23, 2019 11:06:33 PM by.boot.java.pkg.logger.MyLogger log
INFO: MyLogger - log() method called
					</pre><p>
					NOTE: since we have already compiled <code class="code">MyClient</code> class, we succeeded, because all packages accessible at runtime. However, 
					if we want to re-compile <code class="code">MyClient.java</code>, then <code class="code">exports</code> declaration will be a must 
					(e.g. <code class="code">exports by.boot.java.pkg.logger to by.boot.java.mod.client;</code>).  				
				</p>
				<p>
					Before Java 9 (and Java 11), it was possible to use reflection to examine every type and member in a package, even 
					the <code class="code">private</code> ones by using <code class="code">field.setAccessible(true)</code>. 
				</p>
				<p>
					The <code class="code">open</code> modifier also grants reflective access to all types in all packages. All types include <code class="code">private</code>
					types and their <code class="code">private</code> members. If you use the reflection API and suppress Java language access checks using the method 
					<code class="code">AccessibleObject.setAccessible(true)</code> &#8212; you can access <code class="code">private</code> types and members in open modules.
				</p>
				<p>
					Restore <code class="code">by.boot.java.mod.logger</code> module definition as follows:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires java.logging;
    exports by.boot.java.pkg.logger to by.boot.java.mod.client;
}
					</pre><p>
					and add new <code class="code">AccessLog</code> class in the <code class="code">by.boot.java.mod.client</code> module:
					</p><pre class="programlisting">
package by.boot.java.pkg.client;

import by.boot.java.pkg.logger.MyLogger;
import java.lang.reflect.Field;

public class AccessLog {
    public static void main(String[] args) throws Exception {
        MyLogger myClass = new MyLogger();
        Field field1 = myClass.getClass().getDeclaredField("LOG"); // private field LOG in MyLogger 
        field1.setAccessible(true);
        System.out.print(field1.get(myClass).getClass().getCanonicalName());
    }
}					
					</pre><p>
					Compile both changed sources:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p ./mod1;./mod2 ./mod1/module-info.java ./mod1/by/boot/java/pkg/logger/MyLogger.java

C:\1Z0-817&gt;javac -p ./mod1; ./mod2/module-info.java ./mod2/by/boot/java/pkg/client/AccessLog.java
					</pre><p>
					and run the <code class="code">AccessLog</code>, which attempts to read <code class="code">private</code> field via reflection:
					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p ./mod1;./mod2 -m by.boot.java.mod.client/by.boot.java.pkg.client.AccessLog

Exception in thread "main" java.lang.reflect.InaccessibleObjectException: Unable to make field private static final java.util.logging.Logger 
by.boot.java.pkg.logger.MyLogger.LOG accessible: module by.boot.java.mod.logger does not "opens by.boot.java.pkg.logger" 
to module by.boot.java.mod.client                                                                                                                                 
        at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:340)
        at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:280)
        at java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:176)
        at java.base/java.lang.reflect.Field.setAccessible(Field.java:170)
        at by.boot.java.mod.client/by.boot.java.pkg.client.AccessLog.main(AccessLog.java:10)
					</pre><p>
				</p>
				<p>
					In order to fix code, make the <code class="code">by.boot.java.mod.logger</code> module open, and in the same time you can
					remove <code class="code">exports</code> directive, since we do not need to compile <code class="code">AccessLog</code> class:
					</p><pre class="programlisting">
open module by.boot.java.mod.logger {
    requires java.logging;
}

					</pre><p>
					</p><pre class="programlisting">
C:\1Z0-817
&#9500;&#9472;&#9472;&#9472;mod1
&#9474;   &#9474;   module-info.class
&#9474;   &#9474;   module-info.java
&#9474;   &#9474;
&#9474;   &#9492;&#9472;&#9472;&#9472;by
&#9474;       &#9492;&#9472;&#9472;&#9472;boot
&#9474;           &#9492;&#9472;&#9472;&#9472;java
&#9474;               &#9492;&#9472;&#9472;&#9472;pkg
&#9474;                   &#9492;&#9472;&#9472;&#9472;logger
&#9474;                           MyLogger.class
&#9474;                           MyLogger.java
&#9474;
&#9492;&#9472;&#9472;&#9472;mod2
    &#9474;   module-info.class
    &#9474;   module-info.java
    &#9474;
    &#9492;&#9472;&#9472;&#9472;by
        &#9492;&#9472;&#9472;&#9472;boot
            &#9492;&#9472;&#9472;&#9472;java
                &#9492;&#9472;&#9472;&#9472;pkg
                    &#9492;&#9472;&#9472;&#9472;client
                            AccessLog.class
                            AccessLog.java
                            MyClient.class
                            MyClient.java
					</pre><p>
					Recompile <code class="code">by.boot.java.mod.logger</code> module definition:
					</p><pre class="programlisting">
C:\1Z0-817\mod1&gt;javac module-info.java					
					</pre><p>
 					And re-run <code class="code">AccessLog</code> class:
 					</p><pre class="programlisting">
C:\1Z0-817&gt;java -p ./mod1;./mod2 -m by.boot.java.mod.client/by.boot.java.pkg.client.AccessLog
java.util.logging.Logger
 					</pre><p>
 					As you can see, open module granted access to private field via reflection API.
				</p>
				<p>
					<span class="bold"><strong><code class="code">opens</code> directive</strong></span>
				</p>
				<p>
					The <code class="code">opens</code> directive specifies the name of a package to be opened by the current module. This makes 
					<code class="code">public</code> and <code class="code">protected</code> types in the package, and their <code class="code">public</code> and <code class="code">protected</code> 
					members, be accessible to code in other modules at run time only. 
				</p>
				<p>
					It also makes all types in the package, and all their members, be accessible via the reflection libraries of the Java SE Platform.
				</p>
				<p>
					You can use <code class="code">opens</code> directive to open individual packages to other modules. You can access open packages using the
					reflection API at runtime. Just like open modules, all types in an open package and all their members (including <code class="code">private</code>) can be
					reflected by the reflection API:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires java.logging;
    exports by.boot.java.pkg.logger to by.boot.java.mod.client;
    opens by.boot.java.pkg.logger;
}
					</pre><p>
					You can also qualify open packages using <code class="code">to &lt;module name&gt;</code>:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires java.logging;
    exports by.boot.java.pkg.logger to by.boot.java.mod.client;
    opens by.boot.java.pkg.logger to by.boot.java.mod.client;
}
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong><code class="code">requires transitive</code> directive</strong></span>
				</p>
				<p>
					The module readability relationship is not transitive by default. In our example <code class="code">by.boot.java.mod.logger</code> module  can read <code class="code">java.logging</code> module,
					and <code class="code">by.boot.java.mod.client</code> module can read <code class="code">by.boot.java.mod.logger</code>. But <code class="code">by.boot.java.mod.client</code> cannot read classes from 
					<code class="code">java.logging</code> module. 
				</p>
				<p>
					Let's update code of <code class="code">MyLogger</code> and add <code class="code">getLog</code> method:
					</p><pre class="programlisting">
public class MyLogger {
	...    
    public static Logger getLog() {
        return LOG;
    }
}
					</pre><p>
					Re-compile the code:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p ./mod1;./mod2 ./mod1/module-info.java ./mod1/by/boot/java/pkg/logger/MyLogger.java
					</pre><p>
					Now <code class="code">MyLogger</code> class returns to outer world <code class="code">java.util.logging</code> package's type.
				</p>
				<p>
					Then update code of <code class="code">MyClient</code> class to get instance of <code class="code">java.util.logging.Logger</code> class:
					</p><pre class="programlisting">
import java.util.logging.Logger;

public class MyClient {
    public static void main(String[] args) {        
        ...
        Logger l = MyLogger.getLog();
    }
}
					</pre><p>
					Try to compile:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p ./mod1;./mod2 ./mod2/module-info.java ./mod2/by/boot/java/pkg/client/MyClient.java
.\mod2\by\boot\java\pkg\client\MyClient.java:3: error: package by.boot.java.pkg.logger is not visible
import by.boot.java.pkg.logger.MyLogger;
                       ^
  (package by.boot.java.pkg.logger is declared in module by.boot.java.mod.logger, which does not export it)
.\mod2\by\boot\java\pkg\client\MyClient.java:4: error: package java.util.logging is not visible
import java.util.logging.Logger;
                ^
  (package java.util.logging is declared in module java.logging, but module by.boot.java.mod.client does not read it)
2 errors
					</pre><p>
					As it shows, <code class="code">java.logging</code> module (and specifically <code class="code">java.util.logging.Logger</code>) is not 
					visible in <code class="code">by.boot.java.mod.client</code>. 
				</p>
				<p>
					It is the same situation we had in the beginning, and it can be resolved by adding <code class="code">requires java.logging;</code> directive
					to <code class="code">by.boot.java.mod.client</code> module's <code class="code">module-info.java</code>.
				</p>
				<p>
					This can be a tedious task when many modules depend on each other. Since this is a common usage scenario, Java 11 provides 
					built-in support for it. The <code class="code">requires</code> declaration can be extended to add the modifier 
					<code class="code">transitive</code> to declare the dependency as transitive. The transitive modules that a module
					depends on are readable by any module that depends upon this module. This is called implicit readability.
				</p>
				<p>
					In order to fix, edit <code class="code">module-info.java</code> of <code class="code">by.boot.java.mod.logger</code> module adding <code class="code">transitive</code> modifier:
					</p><pre class="programlisting">
module by.boot.java.mod.logger {
    requires transitive java.logging;
    exports by.boot.java.pkg.logger to by.boot.java.mod.client;
    opens by.boot.java.pkg.logger to by.boot.java.mod.client;
}
					</pre><p>
					Now try to compile the code again, and it compiles without errors:
					</p><pre class="programlisting">
C:\1Z0-817&gt;javac -p ./mod1;./mod2 ./mod1/module-info.java ./mod1/by/boot/java/pkg/logger/MyLogger.java

C:\1Z0-817&gt;javac -p ./mod1;./mod2 ./mod2/module-info.java ./mod2/by/boot/java/pkg/client/MyClient.java
					</pre><p>
				</p>
			</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch01.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch01s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;1.&nbsp;Understanding Modules&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;1.3.&nbsp;
					   Describe how a modular project is compiled and run
				</td></tr></table></div></body></html>
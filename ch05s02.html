<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>5.2.&nbsp; Use Files class to check, delete, copy or move a file or directory</title><link rel="stylesheet" type="text/css" href="ocpjd11-upgrade-guide.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Exam 1Z0-817: Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Study Guide"><link rel="up" href="ch05.html" title="Chapter&nbsp;5.&nbsp;Java File I/O (NIO.2)"><link rel="prev" href="ch05.html" title="Chapter&nbsp;5.&nbsp;Java File I/O (NIO.2)"><link rel="next" href="ch05s03.html" title="5.3.&nbsp; Use Stream API with Files"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.2.&nbsp;
					 Use <code class="code">Files</code> class to check, delete, copy or move a file or directory
				</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;5.&nbsp;Java File I/O (NIO.2)</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch05s03.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c5s2"></a>5.2.&nbsp;
					 Use <code class="code">Files</code> class to check, delete, copy or move a file or directory
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="bi01.html#NIO_TUTORIAL" title="File I/O (Featuring NIO.2)">[NIO_TUTORIAL]</a> File I/O (Featuring NIO.2)
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					The <code class="code">java.nio.file.Files</code> class consists of <code class="code">static</code> methods that use <code class="code">Path</code> objects to
					work with files and directories.
				</p>
				<p>
					With file I/O, unexpected conditions are a fact of life: a file exists (or doesn't exist) when expected, the program does not have access to the file system,
					the default file system implementation does not support a particular function, and so on. All methods that access the file system can throw an <code class="code">java.io.IOException</code>.
					It is best practice to catch these exceptions by embedding these methods into a "try-with-resources" statement, introduced in the Java SE 7.0 release.
				</p>
				<p>
					In addition to <code class="code">IOException</code>, many specific exceptions extend <code class="code">FileSystemException</code>. This class has some useful methods that return the file
					involved (<code class="code">getFile</code>), the detailed message string (<code class="code">getMessage</code>), the reason why the file system operation failed (<code class="code">getReason</code>), and
					the "other" file involved, if any (<code class="code">getOtherFile</code>).
				</p>
				<p>
					Several <code class="code">Files</code> methods accept an arbitrary number of arguments when flags are specified. For example, in the following method signature, the ellipses notation
					after the <code class="code">CopyOption</code> argument indicates that the method accepts a variable number of arguments, or varargs, as they are typically called:
					</p><pre class="programlisting">
Files.move(Path, Path, CopyOption...);
					</pre><p>
				</p>
				<p>
					When a method accepts a varargs argument, you can pass it a comma-separated list of values or an array (<code class="code">CopyOption[]</code>) of values:
					</p><pre class="programlisting">
import static java.nio.file.StandardCopyOption.*;
...
Path source = ...;
Path target = ...;
Files.move(source, target, REPLACE_EXISTING, ATOMIC_MOVE);
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Copy a file</strong></span>
				</p>
				<p>
					To copy one file to another you would use the <code class="code">Files.copy</code> method:
					</p><pre class="programlisting">
Files.copy(Path source, Path target, CopyOption... options);
					</pre><p>
					 The <code class="code">options</code> argument are enums that specify how the file should be copied. There are actually two different <code class="code">Enum</code> classes,
					 <code class="code">LinkOption</code> and <code class="code">StandardCopyOption</code>, but both implement the <code class="code">CopyOption</code> interface.
				</p>
				<p>
					Here is the list of available options for <code class="code">Files.copy</code>:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">LinkOption.NOFOLLOW_LINKS</code>
							</p>
							<p>
								Indicates that symbolic links should NOT be followed. If the file to be copied is a symbolic link, the link is copied (and not the target of the link).
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">StandardCopyOption.COPY_ATTRIBUTES</code>
							</p>
							<p>
								Copies the file attributes associated with the file to the target file. The exact file attributes supported are file system and platform dependent, but
								last-modified-time is supported across platforms and is copied to the target file.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">StandardCopyOption.REPLACE_EXISTING</code>
							</p>
							<p>
								Performs the copy even when the target file already exists. If the target is a symbolic link, the link itself is copied (and not the target of the link).
								If the target is a non-empty directory, the copy fails with the <code class="code">FileAlreadyExistsException</code> exception.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					There is also a <code class="code">StandardCopyOption.ATOMIC_MOVE</code> enum, but if this option is specified, an <code class="code">UsupportedOperationException</code> is thrown. If no options
					are specified, the default is to throw an error if the target file exists or is a symbolic link.
				</p>
				<p>
					<span class="bold"><strong>Move a file</strong></span>
				</p>
				<p>
					You can move a file by using the following method:
					</p><pre class="programlisting">
Files.move(Path source, Path target, CopyOption... options);
					</pre><p>
				</p>
				<p>
					The available <code class="code">StandardCopyOptions</code> enums available are:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">StandardCopyOption.REPLACE_EXISTING</code>
							</p>
							<p>
								Performs the move even when the target file already exists. If the target is a symbolic link, the symbolic link is replaced but what it points to is not affected.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">StandardCopyOption.ATOMIC_MOVE</code>
							</p>
							<p>
								Performs the move as an atomic file operation. If the file system does not support an atomic move, an exception is thrown. With an <code class="code">ATOMIC_MOVE</code> you can
								move a file into a directory and be guaranteed that any process watching the directory accesses a complete file.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					If <code class="code">Files.move(...)</code> is called with <code class="code">StandardCopyOption.COPY_ATTRIBUTES</code> an <code class="code">UnsupportedOperationException</code> is thrown.
				</p>
				<p>
					<span class="bold"><strong>Reading, Writing, and Creating Files</strong></span>
				</p>
				<p>
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							<p>
								<span class="bold"><strong>Commonly used methods for small files</strong></span>
							</p>
							<p>
								If you have a small file and you would like to read its entire contents in one pass, you can use the <code class="code">readAllBytes(Path)</code> or <code class="code">readAllLines(Path, Charset)</code>
								method. These methods take care of most of the work for you, such as opening and closing the stream, but are not intended for handling large files. The following code shows
								how to use the <code class="code">readAllBytes</code> method:
								</p><pre class="programlisting">
Path file = ...;
byte[] fileArray;
fileArray = Files.readAllBytes(file);
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong>Buffered I/O methods for text files</strong></span>
							</p>
							<p>
								The <code class="code">java.nio.file</code> package supports channel I/O, which moves data in buffers, bypassing some of the layers that can bottleneck stream I/O.
							</p>
							<p>
								The <code class="code">newBufferedReader(Path, Charset)</code> method opens a file for reading, returning a <code class="code">BufferedReader</code> that can be used to read text from
								a file in an efficient manner.
							</p>
							<p>
								The following code snippet shows how to use the <code class="code">newBufferedReader</code> method to read from a file. The file is encoded in "<code class="code">US-ASCII</code>"
								</p><pre class="programlisting">
Charset charset = Charset.forName("US-ASCII");
try (BufferedReader reader = Files.newBufferedReader(file, charset)) {
    String line = null;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (NoSuchFileException  x ) {
    System.err.format("No such file: %s", x.getFile());
} catch (IOException  x) {
    System.err.println(x);
}
								</pre><p>
							</p>
							<p>
								You can use the <code class="code">newBufferedWriter(Path, Charset, OpenOption...)</code> method to write to a file using a <code class="code">BufferedWriter</code>:
								</p><pre class="programlisting">
/**
 * Opens or creates a file for writing, returning a BufferedWriter that may be used to write text to the
 * file in an efficient manner. The options parameter specifies how the the file is created or opened.
 * If no options are present then this method works as if the CREATE, TRUNCATE_EXISTING, and WRITE options
 * are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or
 * initially truncating an existing regular-file to a size of 0 if it exists.
 *
 * The Writer methods to write text throw IOException if the text cannot be encoded using the specified charset.
 */
public static BufferedWriter newBufferedWriter(Path path,
                                               Charset cs,
                                               OpenOption... options) throws IOException
								</pre><p>
							</p>
							<p>
								The following code snippet shows how to create a file encoded in "US-ASCII" using this method:
								</p><pre class="programlisting">
Charset charset = Charset.forName("US-ASCII");
String s = "ABC";
try (BufferedWriter writer = Files.newBufferedWriter(file, charset)) {
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
								</pre><p>
							</p>
						</li><li class="listitem">
							<p>
								<span class="bold"><strong>Methods for unbuffered streams and interoperable with <code class="code">java.io</code> APIs</strong></span>
							</p>
							<p>
								To open a file for reading, you can use the <code class="code">newInputStream(Path, OpenOption...)</code> method. This method returns an unbuffered input stream for reading
								bytes from the file.
								</p><pre class="programlisting">
try (InputStream in = Files.newInputStream(file);
    BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {
    String line = null;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (NoSuchFileException  x) {
    System.err.println("No such file exists: " + x.getFile());
} catch (IOException  x) {
    System.err.println(x);
}
								</pre><p>
							</p>
						</li></ol></div><p>
				</p>
				<p>
					Several of the <code class="code">Files</code> methods take an optional <code class="code">OpenOptions</code> parameter. This parameter is optional and the API tells you what the default behavior
					is for the method when none is specified. The following <code class="code">StandardOpenOptions</code> enum constants are supported:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">APPEND</code> - If the file is opened for <code class="code">WRITE</code> access then bytes will be written to the end of the file rather than the beginning.
								If the file is opened for write access by other programs, then it is file system specific if writing to the end of the file is atomic.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">CREATE</code> - Create a new file if it does not exist. This option is ignored if the <code class="code">CREATE_NEW</code> option is also set. The check for the
								existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">CREATE_NEW</code> - Create a new file, failing if the file already exists. The check for the existence of the file and the creation of the file if it
								does not exist is atomic with respect to other file system operations.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">DELETE_ON_CLOSE</code> - Delete on close. When this option is present then the implementation makes a best effort attempt to delete the file when
								closed by the appropriate close method. If the close method is not invoked then a best effort attempt is made to delete the file when the Java virtual
								machine terminates (either normally, as defined by the Java Language Specification, or where possible, abnormally). This option is primarily intended for
								use with work files that are used solely by a single instance of the Java virtual machine. This option is not recommended for use when opening files that
								are open concurrently by other entities. Many of the details as to when and how the file is deleted are implementation specific and therefore not specified.
								In particular, an implementation may be unable to guarantee that it deletes the expected file when replaced by an attacker while the file is open. Consequently,
								security sensitive applications should take care when using this option.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">DSYNC</code> - Requires that every update to the file's content be written synchronously to the underlying storage device.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">READ</code> - Open for read access.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">SPARSE</code> - Sparse file. When used with the <code class="code">CREATE_NEW</code> option then this option provides a hint that the new file will be sparse. The
								option is ignored when the file system does not support the creation of sparse files.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">SYNC</code> - Requires that every update to the file's content or metadata be written synchronously to the underlying storage device.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">TRUNCATE_EXISTING</code> - If the file already exists and it is opened for <code class="code">WRITE</code> access, then its length is truncated to 0. This option is
								ignored if the file is opened only for <code class="code">READ</code> access.
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">WRITE</code> - Open for write access.
							</p>
						</li></ul></div><p>
				</p>
				<p>
					<span class="bold"><strong>Glob argument</strong></span>
				</p>
				<p>
					The <code class="code">newDirectoryStream</code> method in the <code class="code">Files</code> class accepts a glob argument:
					</p><pre class="programlisting">

/**
 * Opens a directory, returning a DirectoryStream to iterate over the entries in the directory.
 * The elements returned by the directory stream's iterator are of type Path, each one representing
 * an entry in the directory. The Path objects are obtained as if by resolving the name of the
 * directory entry against dir. The entries returned by the iterator are filtered by matching the
 * String representation of their file names against the given globbing pattern.
 */
public static DirectoryStream&lt;Path&gt; newDirectoryStream(Path dir, String glob) throws IOException;

					</pre><p>
				</p>
				<p>
					You can use <code class="code">glob</code> syntax to specify pattern-matching behavior. A <code class="code">glob</code> pattern is specified as a string and is matched against other strings, such
					as directory or file names. For example:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<code class="code">*.java</code> - Matches a path that represents a file name ending in <code class="code">.java</code>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">*.*</code> - Matches file names containing a dot
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">*.{java,class}</code> - Matches file names ending with <code class="code">.java</code> or <code class="code">.class</code>
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">foo.?</code> - 	Matches file names starting with <code class="code">foo.</code> and a single character extension
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">/home/*/*</code> - Matches <code class="code">/home/mikalai/data</code> on UNIX platforms
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">/home/**</code> - Matches <code class="code">/home/mikalai</code> and <code class="code">/home/mikalai/data</code> on UNIX platforms
							</p>
						</li><li class="listitem">
							<p>
								<code class="code">C:\\*</code> - Matches <code class="code">C:\foo</code> and <code class="code">C:\bar</code> on the Windows platform (note that the backslash is escaped; as a
								string literal in the Java Language the pattern would be "<code class="code">C:\\\\*</code>")
							</p>
						</li></ul></div><p>
				</p>
				<p>
					<span class="bold"><strong>Creating temporary files</strong></span>
				</p>
				<p>
					You can create a temporary file using one of the following <code class="code">Files.createTempFile</code> methods:
					</p><pre class="programlisting">

/**
 * Creates a new empty file in the specified directory, using the given prefix and suffix strings to generate
 * its name. The resulting Path is associated with the same FileSystem as the given directory.
 *
 * The details as to how the name of the file is constructed is implementation dependent and therefore not specified.
 * Where possible the prefix and suffix are used to construct candidate names in the same manner as the
 * File.createTempFile(String,String,File) method.
 *
 * As with the File.createTempFile methods, this method is only part of a temporary-file facility. Where used as a work
 * files, the resulting file may be opened using the DELETE_ON_CLOSE option so that the file is deleted when the appropriate
 * close method is invoked. Alternatively, a shutdown-hook, or the File.deleteOnExit() mechanism may be used to delete the
 * file automatically.
 *
 * The attrs parameter is optional file-attributes to set atomically when creating the file. Each attribute is identified by
 * its name. If more than one attribute of the same name is included in the array then all but the last occurrence is ignored.
 * When no file attributes are specified, then the resulting file may have more restrictive access permissions to files
 * created by the File.createTempFile(String,String,File) method.
 */
 public static Path createTempFile(Path dir,
                  String prefix,
                  String suffix,
                  FileAttribute&lt;?&gt;... attrs)
                           throws IOException;

/**
 * Creates an empty file in the default temporary-file directory, using the given prefix and suffix to generate its name.
 * The resulting Path is associated with the default FileSystem.
 *
 * This method works in exactly the manner specified by the createTempFile(Path,String,String,FileAttribute[]) method for
 * the case that the dir parameter is the temporary-file directory.
 */
 public static Path createTempFile(String prefix,
                  String suffix,
                  FileAttribute&lt;?&gt;... attrs)
                           throws IOException;

					</pre><p>
				</p>
				<p>
					The first method allows the code to specify a directory for the temporary file and the second method creates a new file in the default
					temporary-file directory. Both methods allow you to specify a suffix for the filename and the first method allows you to also specify a
					prefix. The following code snippet gives an example of the second method:
					</p><pre class="programlisting">
try {
    Path tempFile = Files.createTempFile(null, ".myapp");
    System.out.format("The temporary file: %s%n", tempFile);
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
					</pre><p>
					The result of running this file would be something like the following:
					</p><pre class="programlisting">
The temporary file: C:\Users\IBM_AD~1\AppData\Local\Temp\3900024882240192379.myapp
					</pre><p>
				</p>
				<p>
					Another example:
					</p><pre class="programlisting">
try {
    Path tempFile = Files.createTempFile("mz", ".myapp");
    System.out.format("The temporary file: %s%n", tempFile);
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
}
					</pre><p>
					produces:
					</p><pre class="programlisting">
The temporary file: C:\Users\IBM_AD~1\AppData\Local\Temp\mz5583470123941111323.myapp
					</pre><p>
				</p>
				<p>
					A temporary file is just a simple file until YOU make sure that it is truly temporary, which means that an automatic mechanism must delete
					temporary files periodically or at a specified time. There are three approaches to automatic cleanup of temporary files:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								automatic file cleanup via <code class="code">File.deleteOnExit()</code>
							</p>
						</li><li class="listitem">
							<p>
								automatic file cleanup via shutdown-hook: <code class="code">Runtime.getRuntime().addShutdownHook(new Thread() { ... });</code>
							</p>
						</li><li class="listitem">
							<p>
								automatic file cleanup via <code class="code">StandardOpenOption.DELETE_ON_CLOSE</code>
							</p>
						</li></ul></div><p>
				</p>
				<p>
					Java 11 added following new methods to <code class="code">java.nio.file.Files</code> class to directly read <code class="code">String</code> from a file and to directly 
					write <code class="code">String</code> to a file:
					</p><pre class="programlisting">
 /**
  * Reads all content from a file into a string, decoding from bytes to characters
  * using the StandardCharsets.UTF_8 charset.
  *
  * The method ensures that the file is closed when all content have been read
  * or an I/O error, or other runtime exception, is thrown.
  */
public static String readString(Path path) throws IOException


 /**
  * Reads all characters from a file into a string, decoding from bytes to characters
  * using the specified charset.
  *
  * The method ensures that the file is closed when all content have been read
  * or an I/O error, or other runtime exception, is thrown.
  *
  *  This method reads all content including the line separators in the middle
  * and/or at the end. The resulting string will contain line separators as they
  * appear in the file.
  *
  *
  * This method is intended for simple cases where it is appropriate and convenient
  * to read the content of a file into a String. It is not intended for reading
  * very large files.
  */
public static String readString(Path path, Charset cs) throws IOException
					</pre><p>
					</p><pre class="programlisting">
 /**
  * Write a CharSequence to a file.
  * Characters are encoded into bytes using the StandardCharsets.UTF_8 charset.
  *
  */					
public static Path writeString(Path path, CharSequence csq, OpenOption... options) throws IOException
    
    
 /**
  * Write a CharSequence to a file.
  *
  * Characters are encoded into bytes using the specified charset.
  *
  * All characters are written as they are, including the line separators in
  * the char sequence. No extra characters are added.
  *
  * The options parameter specifies how the file is created
  * or opened. If no options are present then this method works as if the
  * StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, 
  * and StandardOpenOption.WRITE options are present. In other words, it
  * opens the file for writing, creating the file if it doesn't exist, or
  * initially truncating an existing regular file to a size of 0.
  */                          
public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options) throws IOException					
					</pre><p>
				</p>
			</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch05s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;5.&nbsp;Java File I/O (NIO.2)&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;5.3.&nbsp;
					 Use Stream API with <code class="code">Files</code>
				</td></tr></table></div></body></html>
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>8.3.&nbsp; Use built-in functional interfaces including Predicate, Consumer, Function, and Supplier</title><link rel="stylesheet" type="text/css" href="ocpjd11-upgrade-guide.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Exam 1Z0-817: Upgrade OCP Java 6, 7 &amp; 8 to Java SE 11 Developer Study Guide"><link rel="up" href="ch08.html" title="Chapter&nbsp;8.&nbsp;Lambda Expressions"><link rel="prev" href="ch08s02.html" title="8.2.&nbsp; Use lambda expressions and method references"><link rel="next" href="ch08s04.html" title="8.4.&nbsp; Use primitive and binary variations of base interfaces of java.util.function package"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">8.3.&nbsp;
					Use built-in functional interfaces including <code class="code">Predicate</code>, <code class="code">Consumer</code>, <code class="code">Function</code>, and <code class="code">Supplier</code>
				</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch08s02.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;8.&nbsp;Lambda Expressions</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch08s04.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c8s3"></a>8.3.&nbsp;
					Use built-in functional interfaces including <code class="code">Predicate</code>, <code class="code">Consumer</code>, <code class="code">Function</code>, and <code class="code">Supplier</code>
				</h2></div></div></div>
				
				<div class="note" style="margin-left: 0.1in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="81px"><img alt="[Note]" src="images.admon/note.gif"></td><th align="left"></th></tr><tr><td align="left" valign="top">
					<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
							<p>
								<a class="xref" href="bi01.html#JAVA_UTIL_FUNCTION" title="Java SE 11 Java Doc - Package java.util.function">[JAVA_UTIL_FUNCTION]</a> Java SE 11 Java Doc - Package java.util.function
							</p>
						</li></ul></div>
				</td></tr></table></div>
				<p>
					<span class="bold"><strong>Develop code that uses the <code class="code">Function</code> interface</strong></span>
				</p>
				<p>
					A <code class="code">java.util.function.Function</code> is a Java 8 functional interface whose sole purpose is to return any result
					by working on a single input argument. It accepts an argument of type <code class="code">T</code> and returns a result of type
					<code class="code">R</code>, by applying specified logic on the input via the <code class="code">apply</code> method. The
					interface definition shown here:
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Function&lt;T extends Object, R extends Object&gt; {

    public R apply(T t);

    ...

}

					</pre><p>
				</p>
				<p>
					A <code class="code">Function</code> interface is used in cases when you want to encapsulate some code into a method which accepts some value as
					an input parameter and then returns another value after performing required operations on the input. The input parameter type and
					the return type of the method can either be same or different:
					</p><pre class="programlisting">

Function&lt;String, Boolean&gt; f = s -&gt; new Boolean(s);

System.out.println(f.apply("TRUE"));
System.out.println(f.apply("true"));
System.out.println(f.apply("Java8"));
System.out.println(f.apply(null));

					</pre><p>
					Output:
					</p><pre class="programlisting">
true
true
false
false
					</pre><p>
				</p>				
				<p>
					<span class="bold"><strong>Develop code that uses the <code class="code">Consumer</code> interface</strong></span>
				</p>
				<p>
					The <code class="code">java.util.function.Consumer&lt;T&gt;</code> interface defines an <code class="code">abstract</code> method
					named <code class="code">accept</code> that takes an object of generic type <code class="code">T</code> and returns no result
					(<code class="code">void</code>):
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Consumer&lt;T extends Object&gt; {

    public void accept(T t);

    ...
}

					</pre><p>
				</p>
				<p>
					You might use this interface when you need to access an object of type <code class="code">T</code> and
					perform some operations on it. For example, you can use it to create a method <code class="code">processList</code>,
					which takes a list of objects and applies an operation on each
					element of that list. In the following listing you use this <code class="code">processList</code> method combined with a
					lambda to print all the elements of the list:
					</p><pre class="programlisting">

public class ConsumerDemo&lt;T extends Object&gt; {

    public void processList(List&lt;T&gt; list, Consumer&lt;T&gt; cons) {
        for(T s : list) {
            cons.accept(s);
        }
    }

    public static void main(String[] args) {
        List&lt;String&gt; l = Arrays.asList(new String[] {"Java", "8", "is", "great", "!"});
        Consumer&lt;String&gt; c = s -&gt; System.out.print(String.format("%s ", s));
        new ConsumerDemo&lt;String&gt;().processList(l, c);
    }
}

					</pre><p>
					output is:
					</p><pre class="programlisting">
Java 8 is great !
					</pre><p>
				</p>
				<p>
					<span class="bold"><strong>Develop code that uses the <code class="code">Supplier</code> interface</strong></span>
				</p>
				<p>
					The <code class="code">java.util.function.Supplier&lt;T&gt;</code> is a functional interface in Java 8, with one <code class="code">abstract</code>
					method named <code class="code">T get()</code> that returns an instance of <code class="code">T</code>. In other words, this is a factory that
					keeps on giving without expecting anything as input.
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Supplier&lt;T extends Object&gt; {

    public T get();

}
					</pre><p>
				</p>
				<p>
					In the most basic form a <code class="code">Supplier</code> will return an instance. For example, we could implement
					<code class="code">Supplier&lt;Book&gt;</code> to return an instance of <code class="code">Book</code>, like so:
					</p><pre class="programlisting">

public class Book {
    String title;
    String author;

    public Book(String t, String a) {
        title = t;
        author = a;
    }

    public String toString() {
        return title + " by " + author;
    }
}

...
...
Supplier&lt;Book&gt; s1 = () -&gt; new Book("Upgrade to Java 8 Guide", "Mikalai Zaikin");
Supplier&lt;Book&gt; s2 = () -&gt; { return new Book("Upgrade to Java 11 Guide", "Mikalai Zaikin"); };

System.out.println(s1.get());
System.out.println(s2.get());

					</pre><p>
					output:
					</p><pre class="programlisting">
Upgrade to Java 8 Guide by Mikalai Zaikin
Upgrade to Java 11 Guide by Mikalai Zaikin
					</pre><p>
					Alternatively, we could use a constructor reference (<code class="code">T::new</code>) instead of the traditional
					(<code class="code">new T()</code>) syntax to instantiate an instance. A constructor reference is much like a
					method reference, except it is a reference to a constructor instead of a method.
					We can use a constructor reference anywhere a lambda expression does
					nothing more than instantiate an instance. The only limitation with <code class="code">Supplier</code>
					that constructor must take no arguments. For example:
					</p><pre class="programlisting">

public class Book {
    String title;
    String author;

    public Book() {
        title = "Default title";
        author = "Default author";
    }

    public String toString() {
        return title + " by " + author;
    }
}
...
...
Supplier&lt;Book&gt; s1 = Book::new;
System.out.println(s1.get());

					</pre><p>
					output:
					</p><pre class="programlisting">
Default title by Default author
					</pre><p>
				</p>
				<p>
					 <span class="bold"><strong>Develop code that uses the <code class="code">UnaryOperator</code> interface</strong></span>
				</p>
				<p>
					The <code class="code">java.util.function.UnaryOperator</code> is a Java 8 functional interface that extends
					<code class="code">java.util.function.Function</code>:
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface UnaryOperator&lt;T extends Object&gt; extends Function&lt;T, T&gt; {

    ...

}

					</pre><p>
					The <code class="code">UnaryOperator</code> is used to work on a single
					operand and it returns the same type as an operand. <code class="code">UnaryOperator</code> can be used as
					lambda expression to pass as an argument. While defining <code class="code">UnaryOperator</code>, we need to define
					<code class="code">T apply(T t)</code> method inherited from <code class="code">java.util.function.Function</code>.
					</p><pre class="programlisting">

UnaryOperator&lt;String&gt; uo = s -&gt; s + " is great !";
System.out.print(uo.apply("Java 11"));

					</pre><p>
					output:
					</p><pre class="programlisting">
Java 11 is great !
					</pre><p>
				</p>
				<p>
					 <span class="bold"><strong>Develop code that uses the <code class="code">Predicate</code> interface</strong></span>
				</p>
				<p>
					The <code class="code">java.util.function.Predicate&lt;T&gt;</code> interface defines an abstract method named
					<code class="code">test(T t)</code> that accepts an object of generic type <code class="code">T</code> and returns a
					<code class="code">boolean</code> primitive.
					</p><pre class="programlisting">

package java.util.function;

@FunctionalInterface
public interface Predicate&lt;T extends Object&gt; {

    public boolean test(T t);

    ...

}

					</pre><p>
				</p>
				<p>
					You might want to use this interface when you need to represent a <code class="code">boolean</code> expression that uses an object
					of type <code class="code">T</code>. For example, you can define a lambda that accepts <code class="code">String</code> objects,
					as shown in the following listing:
					</p><pre class="programlisting">

Predicate&lt;String&gt; longString = s -&gt; s.length() &gt; 5;

// Will print true
System.out.print(longString.test("Hi there !"));

					</pre><p>
				</p>
				<p>
					Predicates may also be passed into functions:
					</p><pre class="programlisting">

Predicate&lt;String&gt; longString = s -&gt; s.length() &gt; 5;
validateString("Hello again !", longString);
...
...
void validateString(String s, Predicate&lt;String&gt; p) {
    if (p.test(s)) {
        System.out.print("Test passed !");
    }
}

					</pre><p>
				</p>
			</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch08s02.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch08.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch08s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">8.2.&nbsp;
					Use lambda expressions and method references
				&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;8.4.&nbsp;
					Use primitive and binary variations of base interfaces of <code class="code">java.util.function</code> package
				</td></tr></table></div></body></html>